{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n */\nvar events_1 = require(\"events\");\nvar device_1 = require(\"./device\");\nvar errors_1 = require(\"./errors\");\nvar log_1 = require(\"./log\");\nvar outputdevicecollection_1 = require(\"./outputdevicecollection\");\nvar mediadeviceinfo_1 = require(\"./shims/mediadeviceinfo\");\nvar util_1 = require(\"./util\");\n/**\n * Aliases for audio kinds, used for labelling.\n * @private\n */\nvar kindAliases = {\n  audioinput: 'Audio Input',\n  audiooutput: 'Audio Output'\n};\n/**\n * Provides input and output audio-based functionality in one convenient class.\n * @publicapi\n */\nvar AudioHelper = /** @class */function (_super) {\n  __extends(AudioHelper, _super);\n  /**\n   * @constructor\n   * @private\n   * @param onActiveOutputsChanged - A callback to be called when the user changes the active output devices.\n   * @param onActiveInputChanged - A callback to be called when the user changes the active input device.\n   * @param [options]\n   */\n  function AudioHelper(onActiveOutputsChanged, onActiveInputChanged, options) {\n    var _a;\n    var _this = _super.call(this) || this;\n    /**\n     * A Map of all audio input devices currently available to the browser by their device ID.\n     */\n    _this.availableInputDevices = new Map();\n    /**\n     * A Map of all audio output devices currently available to the browser by their device ID.\n     */\n    _this.availableOutputDevices = new Map();\n    /**\n     * The currently set audio constraints set by setAudioConstraints().\n     */\n    _this._audioConstraints = null;\n    /**\n     * The audio stream of the default device.\n     * This is populated when _openDefaultDeviceWithConstraints is called,\n     * See _selectedInputDeviceStream for differences.\n     * TODO: Combine these two workflows (3.x?)\n     */\n    _this._defaultInputDeviceStream = null;\n    /**\n     * Whether each sound is enabled.\n     */\n    _this._enabledSounds = (_a = {}, _a[device_1.default.SoundName.Disconnect] = true, _a[device_1.default.SoundName.Incoming] = true, _a[device_1.default.SoundName.Outgoing] = true, _a);\n    /**\n     * The current input device.\n     */\n    _this._inputDevice = null;\n    /**\n     * The internal promise created when calling setInputDevice\n     */\n    _this._inputDevicePromise = null;\n    /**\n     * Whether the {@link AudioHelper} is currently polling the input stream's volume.\n     */\n    _this._isPollingInputVolume = false;\n    /**\n     * An instance of Logger to use.\n     */\n    _this._log = new log_1.default('AudioHelper');\n    /**\n     * Internal reference to the processed stream\n     */\n    _this._processedStream = null;\n    /**\n     * The selected input stream coming from the microphone device.\n     * This is populated when the setInputDevice is called, meaning,\n     * the end user manually selected it, which is different than\n     * the defaultInputDeviceStream.\n     * TODO: Combine these two workflows (3.x?)\n     */\n    _this._selectedInputDeviceStream = null;\n    /**\n     * A record of unknown devices (Devices without labels)\n     */\n    _this._unknownDeviceIndexes = {\n      audioinput: {},\n      audiooutput: {}\n    };\n    /**\n     * Update the available input and output devices\n     * @private\n     */\n    _this._updateAvailableDevices = function () {\n      if (!_this._mediaDevices || !_this._enumerateDevices) {\n        return Promise.reject('Enumeration not supported');\n      }\n      return _this._enumerateDevices().then(function (devices) {\n        _this._updateDevices(devices.filter(function (d) {\n          return d.kind === 'audiooutput';\n        }), _this.availableOutputDevices, _this._removeLostOutput);\n        _this._updateDevices(devices.filter(function (d) {\n          return d.kind === 'audioinput';\n        }), _this.availableInputDevices, _this._removeLostInput);\n        var defaultDevice = _this.availableOutputDevices.get('default') || Array.from(_this.availableOutputDevices.values())[0];\n        [_this.speakerDevices, _this.ringtoneDevices].forEach(function (outputDevices) {\n          if (!outputDevices.get().size && _this.availableOutputDevices.size && _this.isOutputSelectionSupported) {\n            outputDevices.set(defaultDevice.deviceId).catch(function (reason) {\n              _this._log.warn(\"Unable to set audio output devices. \" + reason);\n            });\n          }\n        });\n      });\n    };\n    /**\n     * Remove an input device from inputs\n     * @param lostDevice\n     * @returns Whether the device was active\n     */\n    _this._removeLostInput = function (lostDevice) {\n      if (!_this.inputDevice || _this.inputDevice.deviceId !== lostDevice.deviceId) {\n        return false;\n      }\n      _this._destroyProcessedStream();\n      _this._replaceStream(null);\n      _this._inputDevice = null;\n      _this._maybeStopPollingVolume();\n      var defaultDevice = _this.availableInputDevices.get('default') || Array.from(_this.availableInputDevices.values())[0];\n      if (defaultDevice) {\n        _this.setInputDevice(defaultDevice.deviceId);\n      }\n      return true;\n    };\n    /**\n     * Remove an input device from outputs\n     * @param lostDevice\n     * @returns Whether the device was active\n     */\n    _this._removeLostOutput = function (lostDevice) {\n      var wasSpeakerLost = _this.speakerDevices.delete(lostDevice);\n      var wasRingtoneLost = _this.ringtoneDevices.delete(lostDevice);\n      return wasSpeakerLost || wasRingtoneLost;\n    };\n    options = Object.assign({\n      AudioContext: typeof AudioContext !== 'undefined' && AudioContext,\n      setSinkId: typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId\n    }, options);\n    _this._beforeSetInputDevice = options.beforeSetInputDevice || function () {\n      return Promise.resolve();\n    };\n    _this._updateUserOptions(options);\n    _this._audioProcessorEventObserver = options.audioProcessorEventObserver;\n    _this._mediaDevices = options.mediaDevices || navigator.mediaDevices;\n    _this._onActiveInputChanged = onActiveInputChanged;\n    _this._enumerateDevices = typeof options.enumerateDevices === 'function' ? options.enumerateDevices : _this._mediaDevices && _this._mediaDevices.enumerateDevices.bind(_this._mediaDevices);\n    var isAudioContextSupported = !!(options.AudioContext || options.audioContext);\n    var isEnumerationSupported = !!_this._enumerateDevices;\n    if (options.enabledSounds) {\n      _this._enabledSounds = options.enabledSounds;\n    }\n    var isSetSinkSupported = typeof options.setSinkId === 'function';\n    _this.isOutputSelectionSupported = isEnumerationSupported && isSetSinkSupported;\n    _this.isVolumeSupported = isAudioContextSupported;\n    if (_this.isVolumeSupported) {\n      _this._audioContext = options.audioContext || options.AudioContext && new options.AudioContext();\n      if (_this._audioContext) {\n        _this._inputVolumeAnalyser = _this._audioContext.createAnalyser();\n        _this._inputVolumeAnalyser.fftSize = 32;\n        _this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;\n      }\n    }\n    _this.ringtoneDevices = new outputdevicecollection_1.default('ringtone', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n    _this.speakerDevices = new outputdevicecollection_1.default('speaker', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n    _this.addListener('newListener', function (eventName) {\n      if (eventName === 'inputVolume') {\n        _this._maybeStartPollingVolume();\n      }\n    });\n    _this.addListener('removeListener', function (eventName) {\n      if (eventName === 'inputVolume') {\n        _this._maybeStopPollingVolume();\n      }\n    });\n    _this.once('newListener', function () {\n      // NOTE (rrowland): Ideally we would only check isEnumerationSupported here, but\n      //   in at least one browser version (Tested in FF48) enumerateDevices actually\n      //   returns bad data for the listed devices. Instead, we check for\n      //   isOutputSelectionSupported to avoid these quirks that may negatively affect customers.\n      if (!_this.isOutputSelectionSupported) {\n        _this._log.warn('Warning: This browser does not support audio output selection.');\n      }\n      if (!_this.isVolumeSupported) {\n        _this._log.warn(\"Warning: This browser does not support Twilio's volume indicator feature.\");\n      }\n    });\n    if (isEnumerationSupported) {\n      _this._initializeEnumeration();\n    }\n    // NOTE (kchoy): Currently microphone permissions are not supported in firefox, and Safari V15 and older.\n    // https://github.com/mozilla/standards-positions/issues/19#issuecomment-370158947\n    // https://caniuse.com/permissions-api\n    if (navigator && navigator.permissions && typeof navigator.permissions.query === 'function') {\n      navigator.permissions.query({\n        name: 'microphone'\n      }).then(function (microphonePermissionStatus) {\n        if (microphonePermissionStatus.state !== 'granted') {\n          var handleStateChange = function () {\n            _this._updateAvailableDevices();\n            _this._stopMicrophonePermissionListener();\n          };\n          microphonePermissionStatus.addEventListener('change', handleStateChange);\n          _this._microphonePermissionStatus = microphonePermissionStatus;\n          _this._onMicrophonePermissionStatusChanged = handleStateChange;\n        }\n      }).catch(function (reason) {\n        return _this._log.warn(\"Warning: unable to listen for microphone permission changes. \" + reason);\n      });\n    } else {\n      _this._log.warn('Warning: current browser does not support permissions API.');\n    }\n    return _this;\n  }\n  Object.defineProperty(AudioHelper.prototype, \"audioConstraints\", {\n    /**\n     * The currently set audio constraints set by setAudioConstraints(). Starts as null.\n     */\n    get: function () {\n      return this._audioConstraints;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"inputDevice\", {\n    /**\n     * The active input device. Having no inputDevice specified by `setInputDevice()`\n     * will disable input selection related functionality.\n     */\n    get: function () {\n      return this._inputDevice;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"inputStream\", {\n    /**\n     * The current input stream coming from the microphone device or\n     * the processed audio stream if there is an {@link AudioProcessor}.\n     */\n    get: function () {\n      return this._processedStream || this._selectedInputDeviceStream;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"processedStream\", {\n    /**\n     * The processed stream if an {@link AudioProcessor} was previously added.\n     */\n    get: function () {\n      return this._processedStream;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Destroy this AudioHelper instance\n   * @private\n   */\n  AudioHelper.prototype._destroy = function () {\n    this._stopDefaultInputDeviceStream();\n    this._stopSelectedInputDeviceStream();\n    this._destroyProcessedStream();\n    this._maybeStopPollingVolume();\n    this.removeAllListeners();\n    this._stopMicrophonePermissionListener();\n    this._unbind();\n  };\n  /**\n   * Promise to wait for the input device, if setInputDevice is called outside of the SDK\n   * @private\n   */\n  AudioHelper.prototype._getInputDevicePromise = function () {\n    return this._inputDevicePromise;\n  };\n  /**\n   * Start polling volume if it's supported and there's an input stream to poll.\n   * @private\n   */\n  AudioHelper.prototype._maybeStartPollingVolume = function () {\n    var _this = this;\n    if (!this.isVolumeSupported || !this.inputStream) {\n      return;\n    }\n    this._updateVolumeSource();\n    if (this._isPollingInputVolume || !this._inputVolumeAnalyser) {\n      return;\n    }\n    var bufferLength = this._inputVolumeAnalyser.frequencyBinCount;\n    var buffer = new Uint8Array(bufferLength);\n    this._isPollingInputVolume = true;\n    var emitVolume = function () {\n      if (!_this._isPollingInputVolume) {\n        return;\n      }\n      if (_this._inputVolumeAnalyser) {\n        _this._inputVolumeAnalyser.getByteFrequencyData(buffer);\n        var inputVolume = util_1.average(buffer);\n        _this.emit('inputVolume', inputVolume / 255);\n      }\n      requestAnimationFrame(emitVolume);\n    };\n    requestAnimationFrame(emitVolume);\n  };\n  /**\n   * Stop polling volume if it's currently polling and there are no listeners.\n   * @private\n   */\n  AudioHelper.prototype._maybeStopPollingVolume = function () {\n    if (!this.isVolumeSupported) {\n      return;\n    }\n    if (!this._isPollingInputVolume || this.inputStream && this.listenerCount('inputVolume')) {\n      return;\n    }\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n      delete this._inputVolumeSource;\n    }\n    this._isPollingInputVolume = false;\n  };\n  /**\n   * Call getUserMedia with specified constraints\n   * @private\n   */\n  AudioHelper.prototype._openDefaultDeviceWithConstraints = function (constraints) {\n    var _this = this;\n    this._log.info('Opening default device with constraints', constraints);\n    return this._getUserMedia(constraints).then(function (stream) {\n      _this._log.info('Opened default device. Updating available devices.');\n      // Ensures deviceId's and labels are populated after the gUM call\n      // by calling enumerateDevices\n      _this._updateAvailableDevices().catch(function (error) {\n        // Ignore error, we don't want to break the call flow\n        _this._log.warn('Unable to updateAvailableDevices after gUM call', error);\n      });\n      _this._defaultInputDeviceStream = stream;\n      return _this._maybeCreateProcessedStream(stream);\n    });\n  };\n  /**\n   * Stop the default audio stream\n   * @private\n   */\n  AudioHelper.prototype._stopDefaultInputDeviceStream = function () {\n    if (this._defaultInputDeviceStream) {\n      this._log.info('stopping default device stream');\n      this._defaultInputDeviceStream.getTracks().forEach(function (track) {\n        return track.stop();\n      });\n      this._defaultInputDeviceStream = null;\n      this._destroyProcessedStream();\n    }\n  };\n  /**\n   * Unbind the listeners from mediaDevices.\n   * @private\n   */\n  AudioHelper.prototype._unbind = function () {\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      throw new errors_1.NotSupportedError('Enumeration is not supported');\n    }\n    if (this._mediaDevices.removeEventListener) {\n      this._mediaDevices.removeEventListener('devicechange', this._updateAvailableDevices);\n    }\n  };\n  /**\n   * Update AudioHelper options that can be changed by the user\n   * @private\n   */\n  AudioHelper.prototype._updateUserOptions = function (options) {\n    if (typeof options.enumerateDevices === 'function') {\n      this._enumerateDevices = options.enumerateDevices;\n    }\n    if (typeof options.getUserMedia === 'function') {\n      this._getUserMedia = options.getUserMedia;\n    }\n  };\n  /**\n   * Adds an {@link AudioProcessor} object. Once added, the AudioHelper will route\n   * the input audio stream through the processor before sending the audio\n   * stream to Twilio. Only one AudioProcessor can be added at this time.\n   *\n   * See the {@link AudioProcessor} interface for an example.\n   *\n   * @param processor The AudioProcessor to add.\n   * @returns\n   */\n  AudioHelper.prototype.addProcessor = function (processor) {\n    this._log.debug('.addProcessor');\n    if (this._processor) {\n      throw new errors_1.NotSupportedError('Adding multiple AudioProcessors is not supported at this time.');\n    }\n    if (typeof processor !== 'object' || processor === null) {\n      throw new errors_1.InvalidArgumentError('Missing AudioProcessor argument.');\n    }\n    if (typeof processor.createProcessedStream !== 'function') {\n      throw new errors_1.InvalidArgumentError('Missing createProcessedStream() method.');\n    }\n    if (typeof processor.destroyProcessedStream !== 'function') {\n      throw new errors_1.InvalidArgumentError('Missing destroyProcessedStream() method.');\n    }\n    this._processor = processor;\n    this._audioProcessorEventObserver.emit('add');\n    return this._restartStreams();\n  };\n  /**\n   * Enable or disable the disconnect sound.\n   * @param doEnable Passing `true` will enable the sound and `false` will disable the sound.\n   * Not passing this parameter will not alter the enable-status of the sound.\n   * @returns The enable-status of the sound.\n   */\n  AudioHelper.prototype.disconnect = function (doEnable) {\n    this._log.debug('.disconnect', doEnable);\n    return this._maybeEnableSound(device_1.default.SoundName.Disconnect, doEnable);\n  };\n  /**\n   * Enable or disable the incoming sound.\n   * @param doEnable Passing `true` will enable the sound and `false` will disable the sound.\n   * Not passing this parameter will not alter the enable-status of the sound.\n   * @returns The enable-status of the sound.\n   */\n  AudioHelper.prototype.incoming = function (doEnable) {\n    this._log.debug('.incoming', doEnable);\n    return this._maybeEnableSound(device_1.default.SoundName.Incoming, doEnable);\n  };\n  /**\n   * Enable or disable the outgoing sound.\n   * @param doEnable Passing `true` will enable the sound and `false` will disable the sound.\n   * Not passing this parameter will not alter the enable-status of the sound.\n   * @returns The enable-status of the sound.\n   */\n  AudioHelper.prototype.outgoing = function (doEnable) {\n    this._log.debug('.outgoing', doEnable);\n    return this._maybeEnableSound(device_1.default.SoundName.Outgoing, doEnable);\n  };\n  /**\n   * Removes an {@link AudioProcessor}. Once removed, the AudioHelper will start using\n   * the audio stream from the selected input device for existing or future calls.\n   *\n   * @param processor The AudioProcessor to remove.\n   * @returns\n   */\n  AudioHelper.prototype.removeProcessor = function (processor) {\n    this._log.debug('.removeProcessor');\n    if (typeof processor !== 'object' || processor === null) {\n      throw new errors_1.InvalidArgumentError('Missing AudioProcessor argument.');\n    }\n    if (this._processor !== processor) {\n      throw new errors_1.InvalidArgumentError('Cannot remove an AudioProcessor that has not been previously added.');\n    }\n    this._destroyProcessedStream();\n    this._processor = null;\n    this._audioProcessorEventObserver.emit('remove');\n    return this._restartStreams();\n  };\n  /**\n   * Set the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. Any deviceId specified here will be ignored. Instead, device IDs should\n   * be specified using {@link AudioHelper#setInputDevice}. The returned Promise resolves\n   * when the media is successfully reacquired, or immediately if no input device is set.\n   * @param audioConstraints - The MediaTrackConstraints to apply.\n   */\n  AudioHelper.prototype.setAudioConstraints = function (audioConstraints) {\n    this._log.debug('.setAudioConstraints', audioConstraints);\n    this._audioConstraints = Object.assign({}, audioConstraints);\n    delete this._audioConstraints.deviceId;\n    return this.inputDevice ? this._setInputDevice(this.inputDevice.deviceId, true) : Promise.resolve();\n  };\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   */\n  AudioHelper.prototype.setInputDevice = function (deviceId) {\n    this._log.debug('.setInputDevice', deviceId);\n    return this._setInputDevice(deviceId, false);\n  };\n  /**\n   * Unset the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. The returned Promise resolves when the media is successfully reacquired,\n   * or immediately if no input device is set.\n   */\n  AudioHelper.prototype.unsetAudioConstraints = function () {\n    this._log.debug('.unsetAudioConstraints');\n    this._audioConstraints = null;\n    return this.inputDevice ? this._setInputDevice(this.inputDevice.deviceId, true) : Promise.resolve();\n  };\n  /**\n   * Unset the input device, stopping the tracks. This should only be called when not in a connection, and\n   *   will not allow removal of the input device during a live call.\n   */\n  AudioHelper.prototype.unsetInputDevice = function () {\n    var _this = this;\n    this._log.debug('.unsetInputDevice', this.inputDevice);\n    if (!this.inputDevice) {\n      return Promise.resolve();\n    }\n    this._destroyProcessedStream();\n    return this._onActiveInputChanged(null).then(function () {\n      _this._replaceStream(null);\n      _this._inputDevice = null;\n      _this._maybeStopPollingVolume();\n    });\n  };\n  /**\n   * Destroys processed stream and update references\n   */\n  AudioHelper.prototype._destroyProcessedStream = function () {\n    if (this._processor && this._processedStream) {\n      this._log.info('destroying processed stream');\n      var processedStream = this._processedStream;\n      this._processedStream.getTracks().forEach(function (track) {\n        return track.stop();\n      });\n      this._processedStream = null;\n      this._processor.destroyProcessedStream(processedStream);\n      this._audioProcessorEventObserver.emit('destroy');\n    }\n  };\n  /**\n   * Get the index of an un-labeled Device.\n   * @param mediaDeviceInfo\n   * @returns The index of the passed MediaDeviceInfo\n   */\n  AudioHelper.prototype._getUnknownDeviceIndex = function (mediaDeviceInfo) {\n    var id = mediaDeviceInfo.deviceId;\n    var kind = mediaDeviceInfo.kind;\n    var index = this._unknownDeviceIndexes[kind][id];\n    if (!index) {\n      index = Object.keys(this._unknownDeviceIndexes[kind]).length + 1;\n      this._unknownDeviceIndexes[kind][id] = index;\n    }\n    return index;\n  };\n  /**\n   * Initialize output device enumeration.\n   */\n  AudioHelper.prototype._initializeEnumeration = function () {\n    var _this = this;\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      throw new errors_1.NotSupportedError('Enumeration is not supported');\n    }\n    if (this._mediaDevices.addEventListener) {\n      this._mediaDevices.addEventListener('devicechange', this._updateAvailableDevices);\n    }\n    this._updateAvailableDevices().then(function () {\n      if (!_this.isOutputSelectionSupported) {\n        return;\n      }\n      Promise.all([_this.speakerDevices.set('default'), _this.ringtoneDevices.set('default')]).catch(function (reason) {\n        _this._log.warn(\"Warning: Unable to set audio output devices. \" + reason);\n      });\n    });\n  };\n  /**\n   * Route input stream to the processor if it exists\n   */\n  AudioHelper.prototype._maybeCreateProcessedStream = function (stream) {\n    var _this = this;\n    if (this._processor) {\n      this._log.info('Creating processed stream');\n      return this._processor.createProcessedStream(stream).then(function (processedStream) {\n        _this._processedStream = processedStream;\n        _this._audioProcessorEventObserver.emit('create');\n        return _this._processedStream;\n      });\n    }\n    return Promise.resolve(stream);\n  };\n  /**\n   * Set whether the sound is enabled or not\n   * @param soundName\n   * @param doEnable\n   * @returns Whether the sound is enabled or not\n   */\n  AudioHelper.prototype._maybeEnableSound = function (soundName, doEnable) {\n    if (typeof doEnable !== 'undefined') {\n      this._enabledSounds[soundName] = doEnable;\n    }\n    return this._enabledSounds[soundName];\n  };\n  /**\n   * Stop the tracks on the current input stream before replacing it with the passed stream.\n   * @param stream - The new stream\n   */\n  AudioHelper.prototype._replaceStream = function (stream) {\n    this._log.info('Replacing with new stream.');\n    if (this._selectedInputDeviceStream) {\n      this._log.info('Old stream detected. Stopping tracks.');\n      this._stopSelectedInputDeviceStream();\n    }\n    this._selectedInputDeviceStream = stream;\n  };\n  /**\n   * Restart the active streams\n   */\n  AudioHelper.prototype._restartStreams = function () {\n    if (this.inputDevice && this._selectedInputDeviceStream) {\n      this._log.info('Restarting selected input device');\n      return this._setInputDevice(this.inputDevice.deviceId, true);\n    }\n    if (this._defaultInputDeviceStream) {\n      var defaultDevice = this.availableInputDevices.get('default') || Array.from(this.availableInputDevices.values())[0];\n      this._log.info('Restarting default input device, now becoming selected.');\n      return this._setInputDevice(defaultDevice.deviceId, true);\n    }\n    return Promise.resolve();\n  };\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   * @param forceGetUserMedia - If true, getUserMedia will be called even if\n   *   the specified device is already active.\n   */\n  AudioHelper.prototype._setInputDevice = function (deviceId, forceGetUserMedia) {\n    return __awaiter(this, void 0, void 0, function () {\n      var setInputDevice;\n      var _this = this;\n      return __generator(this, function (_a) {\n        setInputDevice = function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var device, constraints;\n            var _this = this;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4 /*yield*/, this._beforeSetInputDevice()];\n                case 1:\n                  _a.sent();\n                  if (typeof deviceId !== 'string') {\n                    return [2 /*return*/, Promise.reject(new errors_1.InvalidArgumentError('Must specify the device to set'))];\n                  }\n                  device = this.availableInputDevices.get(deviceId);\n                  if (!device) {\n                    return [2 /*return*/, Promise.reject(new errors_1.InvalidArgumentError(\"Device not found: \" + deviceId))];\n                  }\n                  this._log.info('Setting input device. ID: ' + deviceId);\n                  if (this._inputDevice && this._inputDevice.deviceId === deviceId && this._selectedInputDeviceStream) {\n                    if (!forceGetUserMedia) {\n                      return [2 /*return*/, Promise.resolve()];\n                    }\n                    // If the currently active track is still in readyState `live`, gUM may return the same track\n                    // rather than returning a fresh track.\n                    this._log.info('Same track detected on setInputDevice, stopping old tracks.');\n                    this._stopSelectedInputDeviceStream();\n                  }\n                  // Release the default device in case it was created previously\n                  this._stopDefaultInputDeviceStream();\n                  constraints = {\n                    audio: Object.assign({\n                      deviceId: {\n                        exact: deviceId\n                      }\n                    }, this.audioConstraints)\n                  };\n                  this._log.info('setInputDevice: getting new tracks.');\n                  return [2 /*return*/, this._getUserMedia(constraints).then(function (originalStream) {\n                    _this._destroyProcessedStream();\n                    return _this._maybeCreateProcessedStream(originalStream).then(function (newStream) {\n                      _this._log.info('setInputDevice: invoking _onActiveInputChanged.');\n                      return _this._onActiveInputChanged(newStream).then(function () {\n                        _this._replaceStream(originalStream);\n                        _this._inputDevice = device;\n                        _this._maybeStartPollingVolume();\n                      });\n                    });\n                  })];\n              }\n            });\n          });\n        };\n        return [2 /*return*/, this._inputDevicePromise = setInputDevice().finally(function () {\n          _this._inputDevicePromise = null;\n        })];\n      });\n    });\n  };\n  /**\n   * Remove event listener for microphone permissions\n   */\n  AudioHelper.prototype._stopMicrophonePermissionListener = function () {\n    var _a;\n    if ((_a = this._microphonePermissionStatus) === null || _a === void 0 ? void 0 : _a.removeEventListener) {\n      this._microphonePermissionStatus.removeEventListener('change', this._onMicrophonePermissionStatusChanged);\n    }\n  };\n  /**\n   * Stop the selected audio stream\n   */\n  AudioHelper.prototype._stopSelectedInputDeviceStream = function () {\n    if (this._selectedInputDeviceStream) {\n      this._log.info('Stopping selected device stream');\n      this._selectedInputDeviceStream.getTracks().forEach(function (track) {\n        return track.stop();\n      });\n    }\n  };\n  /**\n   * Update a set of devices.\n   * @param updatedDevices - An updated list of available Devices\n   * @param availableDevices - The previous list of available Devices\n   * @param removeLostDevice - The method to call if a previously available Device is\n   *   no longer available.\n   */\n  AudioHelper.prototype._updateDevices = function (updatedDevices, availableDevices, removeLostDevice) {\n    var _this = this;\n    var updatedDeviceIds = updatedDevices.map(function (d) {\n      return d.deviceId;\n    });\n    var knownDeviceIds = Array.from(availableDevices.values()).map(function (d) {\n      return d.deviceId;\n    });\n    var lostActiveDevices = [];\n    // Remove lost devices\n    var lostDeviceIds = util_1.difference(knownDeviceIds, updatedDeviceIds);\n    lostDeviceIds.forEach(function (lostDeviceId) {\n      var lostDevice = availableDevices.get(lostDeviceId);\n      if (lostDevice) {\n        availableDevices.delete(lostDeviceId);\n        if (removeLostDevice(lostDevice)) {\n          lostActiveDevices.push(lostDevice);\n        }\n      }\n    });\n    // Add any new devices, or devices with updated labels\n    var deviceChanged = false;\n    updatedDevices.forEach(function (newDevice) {\n      var existingDevice = availableDevices.get(newDevice.deviceId);\n      var newMediaDeviceInfo = _this._wrapMediaDeviceInfo(newDevice);\n      if (!existingDevice || existingDevice.label !== newMediaDeviceInfo.label) {\n        availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);\n        deviceChanged = true;\n      }\n    });\n    if (deviceChanged || lostDeviceIds.length) {\n      // Force a new gUM in case the underlying tracks of the active stream have changed. One\n      //   reason this might happen is when `default` is selected and set to a USB device,\n      //   then that device is unplugged or plugged back in. We can't check for the 'ended'\n      //   event or readyState because it is asynchronous and may take upwards of 5 seconds,\n      //   in my testing. (rrowland)\n      var defaultId_1 = 'default';\n      // this.inputDevice is not null if audio.setInputDevice() was explicitly called\n      var isInputDeviceSet = this.inputDevice && this.inputDevice.deviceId === defaultId_1;\n      // If this.inputDevice is null, and default stream is not null, it means\n      // the user is using the default stream and did not explicitly call audio.setInputDevice()\n      var isDefaultDeviceSet = this._defaultInputDeviceStream && this.availableInputDevices.get(defaultId_1);\n      if (isInputDeviceSet || isDefaultDeviceSet) {\n        this._log.warn(\"Calling getUserMedia after device change to ensure that the           tracks of the active device (default) have not gone stale.\");\n        // NOTE(csantos): Updating the stream in the same execution context as the devicechange event\n        // causes the new gUM call to fail silently. Meaning, the gUM call may succeed,\n        // but it won't actually update the stream. We need to update the stream in a different\n        // execution context (setTimeout) to properly update the stream.\n        setTimeout(function () {\n          _this._setInputDevice(defaultId_1, true);\n        }, 0);\n      }\n      this._log.debug('#deviceChange', lostActiveDevices);\n      this.emit('deviceChange', lostActiveDevices);\n    }\n  };\n  /**\n   * Disconnect the old input volume source, and create and connect a new one with the current\n   * input stream.\n   */\n  AudioHelper.prototype._updateVolumeSource = function () {\n    if (!this.inputStream || !this._audioContext || !this._inputVolumeAnalyser) {\n      return;\n    }\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n    }\n    try {\n      this._inputVolumeSource = this._audioContext.createMediaStreamSource(this.inputStream);\n      this._inputVolumeSource.connect(this._inputVolumeAnalyser);\n    } catch (ex) {\n      this._log.warn('Unable to update volume source', ex);\n      delete this._inputVolumeSource;\n    }\n  };\n  /**\n   * Convert a MediaDeviceInfo to a IMediaDeviceInfoShim.\n   * @param mediaDeviceInfo - The info to convert\n   * @returns The converted shim\n   */\n  AudioHelper.prototype._wrapMediaDeviceInfo = function (mediaDeviceInfo) {\n    var options = {\n      deviceId: mediaDeviceInfo.deviceId,\n      groupId: mediaDeviceInfo.groupId,\n      kind: mediaDeviceInfo.kind,\n      label: mediaDeviceInfo.label\n    };\n    if (!options.label) {\n      if (options.deviceId === 'default') {\n        options.label = 'Default';\n      } else {\n        var index = this._getUnknownDeviceIndex(mediaDeviceInfo);\n        options.label = \"Unknown \" + kindAliases[options.kind] + \" Device \" + index;\n      }\n    }\n    return new mediadeviceinfo_1.default(options);\n  };\n  return AudioHelper;\n}(events_1.EventEmitter);\n(function (AudioHelper) {})(AudioHelper || (AudioHelper = {}));\nexports.default = AudioHelper;","map":{"version":3,"names":["events_1","require","device_1","errors_1","log_1","outputdevicecollection_1","mediadeviceinfo_1","util_1","kindAliases","audioinput","audiooutput","AudioHelper","_super","__extends","onActiveOutputsChanged","onActiveInputChanged","options","_this","call","availableInputDevices","Map","availableOutputDevices","_audioConstraints","_defaultInputDeviceStream","_enabledSounds","_a","default","SoundName","Disconnect","Incoming","Outgoing","_inputDevice","_inputDevicePromise","_isPollingInputVolume","_log","_processedStream","_selectedInputDeviceStream","_unknownDeviceIndexes","_updateAvailableDevices","_mediaDevices","_enumerateDevices","Promise","reject","then","devices","_updateDevices","filter","d","kind","_removeLostOutput","_removeLostInput","defaultDevice","get","Array","from","values","speakerDevices","ringtoneDevices","forEach","outputDevices","size","isOutputSelectionSupported","set","deviceId","catch","reason","warn","lostDevice","inputDevice","_destroyProcessedStream","_replaceStream","_maybeStopPollingVolume","setInputDevice","wasSpeakerLost","delete","wasRingtoneLost","Object","assign","AudioContext","setSinkId","HTMLAudioElement","prototype","_beforeSetInputDevice","beforeSetInputDevice","resolve","_updateUserOptions","_audioProcessorEventObserver","audioProcessorEventObserver","mediaDevices","navigator","_onActiveInputChanged","enumerateDevices","bind","isAudioContextSupported","audioContext","isEnumerationSupported","enabledSounds","isSetSinkSupported","isVolumeSupported","_audioContext","_inputVolumeAnalyser","createAnalyser","fftSize","smoothingTimeConstant","addListener","eventName","_maybeStartPollingVolume","once","_initializeEnumeration","permissions","query","name","microphonePermissionStatus","state","handleStateChange","_stopMicrophonePermissionListener","addEventListener","_microphonePermissionStatus","_onMicrophonePermissionStatusChanged","defineProperty","_destroy","_stopDefaultInputDeviceStream","_stopSelectedInputDeviceStream","removeAllListeners","_unbind","_getInputDevicePromise","inputStream","_updateVolumeSource","bufferLength","frequencyBinCount","buffer","Uint8Array","emitVolume","getByteFrequencyData","inputVolume","average","emit","requestAnimationFrame","listenerCount","_inputVolumeSource","disconnect","_openDefaultDeviceWithConstraints","constraints","info","_getUserMedia","stream","error","_maybeCreateProcessedStream","getTracks","track","stop","NotSupportedError","removeEventListener","getUserMedia","addProcessor","processor","debug","_processor","InvalidArgumentError","createProcessedStream","destroyProcessedStream","_restartStreams","doEnable","_maybeEnableSound","incoming","outgoing","removeProcessor","setAudioConstraints","audioConstraints","_setInputDevice","unsetAudioConstraints","unsetInputDevice","processedStream","_getUnknownDeviceIndex","mediaDeviceInfo","id","index","keys","length","all","soundName","forceGetUserMedia","__awaiter","sent","device","audio","exact","originalStream","newStream","finally","updatedDevices","availableDevices","removeLostDevice","updatedDeviceIds","map","knownDeviceIds","lostActiveDevices","lostDeviceIds","difference","lostDeviceId","push","deviceChanged","newDevice","existingDevice","newMediaDeviceInfo","_wrapMediaDeviceInfo","label","defaultId_1","isInputDeviceSet","isDefaultDeviceSet","setTimeout","createMediaStreamSource","connect","ex","groupId","EventEmitter","exports"],"sources":["C:\\Users\\91629\\Desktop\\Delote\\New folder\\calling software\\node_modules\\@twilio\\voice-sdk\\lib\\twilio\\audiohelper.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n */\nimport { EventEmitter } from 'events';\nimport AudioProcessor from './audioprocessor';\nimport { AudioProcessorEventObserver } from './audioprocessoreventobserver';\nimport Device from './device';\nimport { InvalidArgumentError, NotSupportedError } from './errors';\nimport Log from './log';\nimport OutputDeviceCollection from './outputdevicecollection';\nimport MediaDeviceInfoShim from './shims/mediadeviceinfo';\nimport { average, difference, isFirefox } from './util';\n\n/**\n * Aliases for audio kinds, used for labelling.\n * @private\n */\nconst kindAliases: Record<string, string> = {\n  audioinput: 'Audio Input',\n  audiooutput: 'Audio Output',\n};\n\n/**\n * Provides input and output audio-based functionality in one convenient class.\n * @publicapi\n */\nclass AudioHelper extends EventEmitter {\n  /**\n   * The currently set audio constraints set by setAudioConstraints(). Starts as null.\n   */\n  get audioConstraints(): MediaTrackConstraints | null { return this._audioConstraints; }\n\n  /**\n   * A Map of all audio input devices currently available to the browser by their device ID.\n   */\n  availableInputDevices: Map<string, MediaDeviceInfo> = new Map();\n\n  /**\n   * A Map of all audio output devices currently available to the browser by their device ID.\n   */\n  availableOutputDevices: Map<string, MediaDeviceInfo> = new Map();\n\n  /**\n   * The active input device. Having no inputDevice specified by `setInputDevice()`\n   * will disable input selection related functionality.\n   */\n  get inputDevice(): MediaDeviceInfo | null { return this._inputDevice; }\n\n  /**\n   * The current input stream coming from the microphone device or\n   * the processed audio stream if there is an {@link AudioProcessor}.\n   */\n  get inputStream(): MediaStream | null { return this._processedStream || this._selectedInputDeviceStream; }\n\n  /**\n   * False if the browser does not support `HTMLAudioElement.setSinkId()` or\n   * `MediaDevices.enumerateDevices()` and Twilio cannot facilitate output selection functionality.\n   */\n  isOutputSelectionSupported: boolean;\n\n  /**\n   * False if the browser does not support AudioContext and Twilio can not analyse the volume\n   * in real-time.\n   */\n  isVolumeSupported: boolean;\n\n  /**\n   * The processed stream if an {@link AudioProcessor} was previously added.\n   */\n  get processedStream(): MediaStream | null { return this._processedStream; }\n\n  /**\n   * The current set of output devices that incoming ringtone audio is routed through.\n   * These are the sounds that may play while the user is away from the machine or not wearing\n   * their headset. It is important that this audio is heard. If all specified\n   * devices lost, this Set will revert to contain only the \"default\" device.\n   */\n  ringtoneDevices: OutputDeviceCollection;\n\n  /**\n   * The current set of output devices that call audio (`[voice, outgoing, disconnect, dtmf]`)\n   * is routed through. These are the sounds that are initiated by the user, or played while\n   * the user is otherwise present at the endpoint. If all specified devices are lost,\n   * this Set will revert to contain only the \"default\" device.\n   */\n  speakerDevices: OutputDeviceCollection;\n\n  /**\n   * The currently set audio constraints set by setAudioConstraints().\n   */\n  private _audioConstraints: MediaTrackConstraints | null = null;\n\n  /**\n   * An AudioContext to use.\n   */\n  private _audioContext?: AudioContext;\n\n  /**\n   * The AudioProcessorEventObserver instance to use\n   */\n  private _audioProcessorEventObserver: AudioProcessorEventObserver;\n\n  /**\n   * Promise to wait for before setting the input device.\n   */\n  private _beforeSetInputDevice: () => Promise<any>;\n\n  /**\n   * The audio stream of the default device.\n   * This is populated when _openDefaultDeviceWithConstraints is called,\n   * See _selectedInputDeviceStream for differences.\n   * TODO: Combine these two workflows (3.x?)\n   */\n  private _defaultInputDeviceStream: MediaStream | null = null;\n\n  /**\n   * Whether each sound is enabled.\n   */\n  private _enabledSounds: Record<Device.ToggleableSound, boolean> = {\n    [Device.SoundName.Disconnect]: true,\n    [Device.SoundName.Incoming]: true,\n    [Device.SoundName.Outgoing]: true,\n  };\n\n  /**\n   * The enumerateDevices method to use\n   */\n  private _enumerateDevices: any;\n\n  /**\n   * The `getUserMedia()` function to use.\n   */\n  private _getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>;\n\n  /**\n   * The current input device.\n   */\n  private _inputDevice: MediaDeviceInfo | null = null;\n\n  /**\n   * The internal promise created when calling setInputDevice\n   */\n  private _inputDevicePromise: Promise<void> | null = null;\n\n  /**\n   * An AnalyserNode to use for input volume.\n   */\n  private _inputVolumeAnalyser?: AnalyserNode;\n\n  /**\n   * An MediaStreamSource to use for input volume.\n   */\n  private _inputVolumeSource?: MediaStreamAudioSourceNode;\n\n  /**\n   * Whether the {@link AudioHelper} is currently polling the input stream's volume.\n   */\n  private _isPollingInputVolume: boolean = false;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = new Log('AudioHelper');\n\n  /**\n   * The MediaDevices instance to use.\n   */\n  private _mediaDevices: AudioHelper.MediaDevicesLike | null;\n\n  /**\n   * The microphone permission status\n   */\n  private _microphonePermissionStatus: PermissionStatus | null;\n\n  /**\n   * Called with the new input stream when the active input is changed.\n   */\n  private _onActiveInputChanged: (stream: MediaStream | null) => Promise<void>;\n\n  /**\n   * Handler for microphone permission status change\n   */\n  private _onMicrophonePermissionStatusChanged: () => void;\n\n  /**\n   * Internal reference to the processed stream\n   */\n  private _processedStream: MediaStream | null = null;\n\n  /**\n   * Internal reference to the added AudioProcessor\n   */\n  private _processor: AudioProcessor | null;\n\n  /**\n   * The selected input stream coming from the microphone device.\n   * This is populated when the setInputDevice is called, meaning,\n   * the end user manually selected it, which is different than\n   * the defaultInputDeviceStream.\n   * TODO: Combine these two workflows (3.x?)\n   */\n  private _selectedInputDeviceStream: MediaStream | null = null;\n\n  /**\n   * A record of unknown devices (Devices without labels)\n   */\n  private _unknownDeviceIndexes: Record<string, Record<string, number>> = {\n    audioinput: { },\n    audiooutput: { },\n  };\n\n  /**\n   * @constructor\n   * @private\n   * @param onActiveOutputsChanged - A callback to be called when the user changes the active output devices.\n   * @param onActiveInputChanged - A callback to be called when the user changes the active input device.\n   * @param [options]\n   */\n  constructor(onActiveOutputsChanged: (type: 'ringtone' | 'speaker', outputIds: string[]) => Promise<void>,\n              onActiveInputChanged: (stream: MediaStream | null) => Promise<void>,\n              options?: AudioHelper.Options) {\n    super();\n\n    options = Object.assign({\n      AudioContext: typeof AudioContext !== 'undefined' && AudioContext,\n      setSinkId: typeof HTMLAudioElement !== 'undefined' && (HTMLAudioElement.prototype as any).setSinkId,\n    }, options);\n\n    this._beforeSetInputDevice = options.beforeSetInputDevice || (() => Promise.resolve());\n\n    this._updateUserOptions(options);\n\n    this._audioProcessorEventObserver = options.audioProcessorEventObserver;\n    this._mediaDevices = options.mediaDevices || navigator.mediaDevices;\n    this._onActiveInputChanged = onActiveInputChanged;\n    this._enumerateDevices = typeof options.enumerateDevices === 'function'\n      ? options.enumerateDevices\n      : this._mediaDevices && this._mediaDevices.enumerateDevices.bind(this._mediaDevices);\n\n    const isAudioContextSupported: boolean = !!(options.AudioContext || options.audioContext);\n    const isEnumerationSupported: boolean = !!this._enumerateDevices;\n\n    if (options.enabledSounds) {\n      this._enabledSounds = options.enabledSounds;\n    }\n\n    const isSetSinkSupported: boolean = typeof options.setSinkId === 'function';\n    this.isOutputSelectionSupported = isEnumerationSupported && isSetSinkSupported;\n    this.isVolumeSupported = isAudioContextSupported;\n\n    if (this.isVolumeSupported) {\n      this._audioContext = options.audioContext || options.AudioContext && new options.AudioContext();\n      if (this._audioContext) {\n        this._inputVolumeAnalyser = this._audioContext.createAnalyser();\n        this._inputVolumeAnalyser.fftSize = 32;\n        this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;\n      }\n    }\n\n    this.ringtoneDevices = new OutputDeviceCollection('ringtone',\n      this.availableOutputDevices, onActiveOutputsChanged, this.isOutputSelectionSupported);\n    this.speakerDevices = new OutputDeviceCollection('speaker',\n      this.availableOutputDevices, onActiveOutputsChanged, this.isOutputSelectionSupported);\n\n    this.addListener('newListener', (eventName: string) => {\n      if (eventName === 'inputVolume') {\n        this._maybeStartPollingVolume();\n      }\n    });\n\n    this.addListener('removeListener', (eventName: string) => {\n      if (eventName === 'inputVolume') {\n        this._maybeStopPollingVolume();\n      }\n    });\n\n    this.once('newListener', () => {\n      // NOTE (rrowland): Ideally we would only check isEnumerationSupported here, but\n      //   in at least one browser version (Tested in FF48) enumerateDevices actually\n      //   returns bad data for the listed devices. Instead, we check for\n      //   isOutputSelectionSupported to avoid these quirks that may negatively affect customers.\n      if (!this.isOutputSelectionSupported) {\n        this._log.warn('Warning: This browser does not support audio output selection.');\n      }\n\n      if (!this.isVolumeSupported) {\n        this._log.warn(`Warning: This browser does not support Twilio's volume indicator feature.`);\n      }\n    });\n\n    if (isEnumerationSupported) {\n      this._initializeEnumeration();\n    }\n\n    // NOTE (kchoy): Currently microphone permissions are not supported in firefox, and Safari V15 and older.\n    // https://github.com/mozilla/standards-positions/issues/19#issuecomment-370158947\n    // https://caniuse.com/permissions-api\n    if (navigator && navigator.permissions && typeof navigator.permissions.query === 'function') {\n      navigator.permissions.query({ name: 'microphone' }).then((microphonePermissionStatus) => {\n        if (microphonePermissionStatus.state !== 'granted') {\n          const handleStateChange = () => {\n            this._updateAvailableDevices();\n            this._stopMicrophonePermissionListener();\n          };\n          microphonePermissionStatus.addEventListener('change', handleStateChange);\n          this._microphonePermissionStatus = microphonePermissionStatus;\n          this._onMicrophonePermissionStatusChanged = handleStateChange;\n        }\n      }).catch((reason) => this._log.warn(`Warning: unable to listen for microphone permission changes. ${reason}`));\n    } else {\n      this._log.warn('Warning: current browser does not support permissions API.');\n    }\n  }\n\n  /**\n   * Destroy this AudioHelper instance\n   * @private\n   */\n  _destroy(): void {\n    this._stopDefaultInputDeviceStream();\n    this._stopSelectedInputDeviceStream();\n    this._destroyProcessedStream();\n    this._maybeStopPollingVolume();\n    this.removeAllListeners();\n    this._stopMicrophonePermissionListener();\n    this._unbind();\n  }\n\n  /**\n   * Promise to wait for the input device, if setInputDevice is called outside of the SDK\n   * @private\n   */\n  _getInputDevicePromise(): Promise<void> | null {\n    return this._inputDevicePromise;\n  }\n\n  /**\n   * Start polling volume if it's supported and there's an input stream to poll.\n   * @private\n   */\n  _maybeStartPollingVolume(): void {\n    if (!this.isVolumeSupported || !this.inputStream) { return; }\n\n    this._updateVolumeSource();\n\n    if (this._isPollingInputVolume || !this._inputVolumeAnalyser) { return; }\n\n    const bufferLength: number = this._inputVolumeAnalyser.frequencyBinCount;\n    const buffer: Uint8Array = new Uint8Array(bufferLength);\n\n    this._isPollingInputVolume = true;\n\n    const emitVolume = (): void => {\n      if (!this._isPollingInputVolume) { return; }\n\n      if (this._inputVolumeAnalyser) {\n        this._inputVolumeAnalyser.getByteFrequencyData(buffer);\n        const inputVolume: number = average(buffer);\n\n        this.emit('inputVolume', inputVolume / 255);\n      }\n\n      requestAnimationFrame(emitVolume);\n    };\n\n    requestAnimationFrame(emitVolume);\n  }\n\n  /**\n   * Stop polling volume if it's currently polling and there are no listeners.\n   * @private\n   */\n  _maybeStopPollingVolume(): void {\n    if (!this.isVolumeSupported) { return; }\n\n    if (!this._isPollingInputVolume || (this.inputStream && this.listenerCount('inputVolume'))) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n      delete this._inputVolumeSource;\n    }\n\n    this._isPollingInputVolume = false;\n  }\n\n  /**\n   * Call getUserMedia with specified constraints\n   * @private\n   */\n  _openDefaultDeviceWithConstraints(constraints: MediaStreamConstraints): Promise<MediaStream> {\n    this._log.info('Opening default device with constraints', constraints);\n    return this._getUserMedia(constraints).then((stream: MediaStream) => {\n\n      this._log.info('Opened default device. Updating available devices.');\n      // Ensures deviceId's and labels are populated after the gUM call\n      // by calling enumerateDevices\n      this._updateAvailableDevices().catch(error => {\n        // Ignore error, we don't want to break the call flow\n        this._log.warn('Unable to updateAvailableDevices after gUM call', error);\n      });\n      this._defaultInputDeviceStream = stream;\n      return this._maybeCreateProcessedStream(stream);\n    });\n  }\n\n  /**\n   * Stop the default audio stream\n   * @private\n   */\n  _stopDefaultInputDeviceStream(): void {\n    if (this._defaultInputDeviceStream) {\n      this._log.info('stopping default device stream');\n      this._defaultInputDeviceStream.getTracks().forEach(track => track.stop());\n      this._defaultInputDeviceStream = null;\n      this._destroyProcessedStream();\n    }\n  }\n\n  /**\n   * Unbind the listeners from mediaDevices.\n   * @private\n   */\n  _unbind(): void {\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      throw new NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.removeEventListener) {\n      this._mediaDevices.removeEventListener('devicechange', this._updateAvailableDevices);\n    }\n  }\n\n  /**\n   * Update the available input and output devices\n   * @private\n   */\n  _updateAvailableDevices = (): Promise<void> => {\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      return Promise.reject('Enumeration not supported');\n    }\n\n    return this._enumerateDevices().then((devices: MediaDeviceInfo[]) => {\n      this._updateDevices(devices.filter((d: MediaDeviceInfo) => d.kind === 'audiooutput'),\n        this.availableOutputDevices,\n        this._removeLostOutput);\n\n      this._updateDevices(devices.filter((d: MediaDeviceInfo) => d.kind === 'audioinput'),\n        this.availableInputDevices,\n        this._removeLostInput);\n\n      const defaultDevice = this.availableOutputDevices.get('default')\n        || Array.from(this.availableOutputDevices.values())[0];\n\n      [this.speakerDevices, this.ringtoneDevices].forEach(outputDevices => {\n        if (!outputDevices.get().size && this.availableOutputDevices.size && this.isOutputSelectionSupported) {\n          outputDevices.set(defaultDevice.deviceId)\n            .catch((reason) => {\n              this._log.warn(`Unable to set audio output devices. ${reason}`);\n            });\n        }\n      });\n    });\n  }\n\n  /**\n   * Update AudioHelper options that can be changed by the user\n   * @private\n   */\n  _updateUserOptions(options: AudioHelper.Options): void {\n    if (typeof options.enumerateDevices === 'function') {\n      this._enumerateDevices = options.enumerateDevices;\n    }\n    if (typeof options.getUserMedia === 'function') {\n      this._getUserMedia = options.getUserMedia;\n    }\n  }\n\n  /**\n   * Adds an {@link AudioProcessor} object. Once added, the AudioHelper will route\n   * the input audio stream through the processor before sending the audio\n   * stream to Twilio. Only one AudioProcessor can be added at this time.\n   *\n   * See the {@link AudioProcessor} interface for an example.\n   *\n   * @param processor The AudioProcessor to add.\n   * @returns\n   */\n  addProcessor(processor: AudioProcessor): Promise<void> {\n    this._log.debug('.addProcessor');\n\n    if (this._processor) {\n      throw new NotSupportedError('Adding multiple AudioProcessors is not supported at this time.');\n    }\n\n    if (typeof processor !== 'object' || processor === null) {\n      throw new InvalidArgumentError('Missing AudioProcessor argument.');\n    }\n\n    if (typeof processor.createProcessedStream !== 'function') {\n      throw new InvalidArgumentError('Missing createProcessedStream() method.');\n    }\n\n    if (typeof processor.destroyProcessedStream !== 'function') {\n      throw new InvalidArgumentError('Missing destroyProcessedStream() method.');\n    }\n\n    this._processor = processor;\n    this._audioProcessorEventObserver.emit('add');\n    return this._restartStreams();\n  }\n\n  /**\n   * Enable or disable the disconnect sound.\n   * @param doEnable Passing `true` will enable the sound and `false` will disable the sound.\n   * Not passing this parameter will not alter the enable-status of the sound.\n   * @returns The enable-status of the sound.\n   */\n  disconnect(doEnable?: boolean): boolean {\n    this._log.debug('.disconnect', doEnable);\n    return this._maybeEnableSound(Device.SoundName.Disconnect, doEnable);\n  }\n\n  /**\n   * Enable or disable the incoming sound.\n   * @param doEnable Passing `true` will enable the sound and `false` will disable the sound.\n   * Not passing this parameter will not alter the enable-status of the sound.\n   * @returns The enable-status of the sound.\n   */\n  incoming(doEnable?: boolean): boolean {\n    this._log.debug('.incoming', doEnable);\n    return this._maybeEnableSound(Device.SoundName.Incoming, doEnable);\n  }\n\n  /**\n   * Enable or disable the outgoing sound.\n   * @param doEnable Passing `true` will enable the sound and `false` will disable the sound.\n   * Not passing this parameter will not alter the enable-status of the sound.\n   * @returns The enable-status of the sound.\n   */\n  outgoing(doEnable?: boolean): boolean {\n    this._log.debug('.outgoing', doEnable);\n    return this._maybeEnableSound(Device.SoundName.Outgoing, doEnable);\n  }\n\n  /**\n   * Removes an {@link AudioProcessor}. Once removed, the AudioHelper will start using\n   * the audio stream from the selected input device for existing or future calls.\n   *\n   * @param processor The AudioProcessor to remove.\n   * @returns\n   */\n  removeProcessor(processor: AudioProcessor): Promise<void> {\n    this._log.debug('.removeProcessor');\n\n    if (typeof processor !== 'object' || processor === null) {\n      throw new InvalidArgumentError('Missing AudioProcessor argument.');\n    }\n\n    if (this._processor !== processor) {\n      throw new InvalidArgumentError('Cannot remove an AudioProcessor that has not been previously added.');\n    }\n\n    this._destroyProcessedStream();\n    this._processor = null;\n    this._audioProcessorEventObserver.emit('remove');\n    return this._restartStreams();\n  }\n\n  /**\n   * Set the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. Any deviceId specified here will be ignored. Instead, device IDs should\n   * be specified using {@link AudioHelper#setInputDevice}. The returned Promise resolves\n   * when the media is successfully reacquired, or immediately if no input device is set.\n   * @param audioConstraints - The MediaTrackConstraints to apply.\n   */\n  setAudioConstraints(audioConstraints: MediaTrackConstraints): Promise<void> {\n    this._log.debug('.setAudioConstraints', audioConstraints);\n    this._audioConstraints = Object.assign({ }, audioConstraints);\n    delete this._audioConstraints.deviceId;\n\n    return this.inputDevice\n      ? this._setInputDevice(this.inputDevice.deviceId, true)\n      : Promise.resolve();\n  }\n\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   */\n  setInputDevice(deviceId: string): Promise<void> {\n    this._log.debug('.setInputDevice', deviceId);\n    return this._setInputDevice(deviceId, false);\n  }\n\n  /**\n   * Unset the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. The returned Promise resolves when the media is successfully reacquired,\n   * or immediately if no input device is set.\n   */\n  unsetAudioConstraints(): Promise<void> {\n    this._log.debug('.unsetAudioConstraints');\n    this._audioConstraints = null;\n    return this.inputDevice\n      ? this._setInputDevice(this.inputDevice.deviceId, true)\n      : Promise.resolve();\n  }\n\n  /**\n   * Unset the input device, stopping the tracks. This should only be called when not in a connection, and\n   *   will not allow removal of the input device during a live call.\n   */\n  unsetInputDevice(): Promise<void> {\n    this._log.debug('.unsetInputDevice', this.inputDevice);\n    if (!this.inputDevice) { return Promise.resolve(); }\n\n    this._destroyProcessedStream();\n\n    return this._onActiveInputChanged(null).then(() => {\n      this._replaceStream(null);\n      this._inputDevice = null;\n      this._maybeStopPollingVolume();\n    });\n  }\n\n  /**\n   * Destroys processed stream and update references\n   */\n  private _destroyProcessedStream() {\n    if (this._processor && this._processedStream) {\n      this._log.info('destroying processed stream');\n      const processedStream = this._processedStream;\n      this._processedStream.getTracks().forEach(track => track.stop());\n      this._processedStream = null;\n      this._processor.destroyProcessedStream(processedStream);\n      this._audioProcessorEventObserver.emit('destroy');\n    }\n  }\n\n  /**\n   * Get the index of an un-labeled Device.\n   * @param mediaDeviceInfo\n   * @returns The index of the passed MediaDeviceInfo\n   */\n  private _getUnknownDeviceIndex(mediaDeviceInfo: MediaDeviceInfo): number {\n    const id: string = mediaDeviceInfo.deviceId;\n    const kind: string = mediaDeviceInfo.kind;\n\n    let index: number = this._unknownDeviceIndexes[kind][id];\n    if (!index) {\n      index = Object.keys(this._unknownDeviceIndexes[kind]).length + 1;\n      this._unknownDeviceIndexes[kind][id] = index;\n    }\n\n    return index;\n  }\n\n  /**\n   * Initialize output device enumeration.\n   */\n  private _initializeEnumeration(): void {\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      throw new NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.addEventListener) {\n      this._mediaDevices.addEventListener('devicechange', this._updateAvailableDevices);\n    }\n\n    this._updateAvailableDevices().then(() => {\n      if (!this.isOutputSelectionSupported) { return; }\n\n      Promise.all([\n        this.speakerDevices.set('default'),\n        this.ringtoneDevices.set('default'),\n      ]).catch(reason => {\n        this._log.warn(`Warning: Unable to set audio output devices. ${reason}`);\n      });\n    });\n  }\n\n  /**\n   * Route input stream to the processor if it exists\n   */\n  private _maybeCreateProcessedStream(stream: MediaStream): Promise<MediaStream> {\n    if (this._processor) {\n      this._log.info('Creating processed stream');\n      return this._processor.createProcessedStream(stream).then((processedStream: MediaStream) => {\n        this._processedStream = processedStream;\n        this._audioProcessorEventObserver.emit('create');\n        return this._processedStream;\n      });\n    }\n    return Promise.resolve(stream);\n  }\n\n  /**\n   * Set whether the sound is enabled or not\n   * @param soundName\n   * @param doEnable\n   * @returns Whether the sound is enabled or not\n   */\n  private _maybeEnableSound(soundName: Device.ToggleableSound, doEnable?: boolean): boolean {\n    if (typeof doEnable !== 'undefined') {\n      this._enabledSounds[soundName] = doEnable;\n    }\n    return this._enabledSounds[soundName];\n  }\n\n  /**\n   * Remove an input device from inputs\n   * @param lostDevice\n   * @returns Whether the device was active\n   */\n  private _removeLostInput = (lostDevice: MediaDeviceInfo): boolean => {\n    if (!this.inputDevice || this.inputDevice.deviceId !== lostDevice.deviceId) {\n      return false;\n    }\n\n    this._destroyProcessedStream();\n    this._replaceStream(null);\n    this._inputDevice = null;\n    this._maybeStopPollingVolume();\n\n    const defaultDevice: MediaDeviceInfo = this.availableInputDevices.get('default')\n      || Array.from(this.availableInputDevices.values())[0];\n\n    if (defaultDevice) {\n      this.setInputDevice(defaultDevice.deviceId);\n    }\n\n    return true;\n  }\n\n  /**\n   * Remove an input device from outputs\n   * @param lostDevice\n   * @returns Whether the device was active\n   */\n  private _removeLostOutput = (lostDevice: MediaDeviceInfo): boolean => {\n    const wasSpeakerLost: boolean = this.speakerDevices.delete(lostDevice);\n    const wasRingtoneLost: boolean = this.ringtoneDevices.delete(lostDevice);\n    return wasSpeakerLost || wasRingtoneLost;\n  }\n\n  /**\n   * Stop the tracks on the current input stream before replacing it with the passed stream.\n   * @param stream - The new stream\n   */\n  private _replaceStream(stream: MediaStream | null): void {\n    this._log.info('Replacing with new stream.');\n    if (this._selectedInputDeviceStream) {\n      this._log.info('Old stream detected. Stopping tracks.');\n      this._stopSelectedInputDeviceStream();\n    }\n\n    this._selectedInputDeviceStream = stream;\n  }\n\n  /**\n   * Restart the active streams\n   */\n  private _restartStreams(): Promise<void> {\n    if (this.inputDevice && this._selectedInputDeviceStream) {\n      this._log.info('Restarting selected input device');\n      return this._setInputDevice(this.inputDevice.deviceId, true);\n    }\n\n    if (this._defaultInputDeviceStream) {\n      const defaultDevice = this.availableInputDevices.get('default')\n      || Array.from(this.availableInputDevices.values())[0];\n\n      this._log.info('Restarting default input device, now becoming selected.');\n      return this._setInputDevice(defaultDevice.deviceId, true);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   * @param forceGetUserMedia - If true, getUserMedia will be called even if\n   *   the specified device is already active.\n   */\n  private async _setInputDevice(deviceId: string, forceGetUserMedia: boolean): Promise<void> {\n    const setInputDevice = async () => {\n      await this._beforeSetInputDevice();\n\n      if (typeof deviceId !== 'string') {\n        return Promise.reject(new InvalidArgumentError('Must specify the device to set'));\n      }\n\n      const device: MediaDeviceInfo | undefined = this.availableInputDevices.get(deviceId);\n      if (!device) {\n        return Promise.reject(new InvalidArgumentError(`Device not found: ${deviceId}`));\n      }\n\n      this._log.info('Setting input device. ID: ' + deviceId);\n\n      if (this._inputDevice && this._inputDevice.deviceId === deviceId && this._selectedInputDeviceStream) {\n        if (!forceGetUserMedia) {\n          return Promise.resolve();\n        }\n\n        // If the currently active track is still in readyState `live`, gUM may return the same track\n        // rather than returning a fresh track.\n        this._log.info('Same track detected on setInputDevice, stopping old tracks.');\n        this._stopSelectedInputDeviceStream();\n      }\n\n      // Release the default device in case it was created previously\n      this._stopDefaultInputDeviceStream();\n\n      const constraints = { audio: Object.assign({ deviceId: { exact: deviceId } }, this.audioConstraints) };\n      this._log.info('setInputDevice: getting new tracks.');\n      return this._getUserMedia(constraints).then((originalStream: MediaStream) => {\n\n        this._destroyProcessedStream();\n\n        return this._maybeCreateProcessedStream(originalStream).then((newStream) => {\n          this._log.info('setInputDevice: invoking _onActiveInputChanged.');\n          return this._onActiveInputChanged(newStream).then(() => {\n            this._replaceStream(originalStream);\n            this._inputDevice = device;\n            this._maybeStartPollingVolume();\n          });\n        });\n      });\n    };\n\n    return this._inputDevicePromise = setInputDevice().finally(() => {\n      this._inputDevicePromise = null;\n    });\n  }\n\n  /**\n   * Remove event listener for microphone permissions\n   */\n  private _stopMicrophonePermissionListener(): void {\n    if (this._microphonePermissionStatus?.removeEventListener) {\n      this._microphonePermissionStatus.removeEventListener('change', this._onMicrophonePermissionStatusChanged);\n    }\n  }\n\n  /**\n   * Stop the selected audio stream\n   */\n  private _stopSelectedInputDeviceStream(): void {\n    if (this._selectedInputDeviceStream) {\n      this._log.info('Stopping selected device stream');\n      this._selectedInputDeviceStream.getTracks().forEach(track => track.stop());\n    }\n  }\n\n  /**\n   * Update a set of devices.\n   * @param updatedDevices - An updated list of available Devices\n   * @param availableDevices - The previous list of available Devices\n   * @param removeLostDevice - The method to call if a previously available Device is\n   *   no longer available.\n   */\n  private _updateDevices(updatedDevices: MediaDeviceInfo[],\n                         availableDevices: Map<string, MediaDeviceInfo>,\n                         removeLostDevice: (lostDevice: MediaDeviceInfo) => boolean): void {\n    const updatedDeviceIds: string[] = updatedDevices.map(d => d.deviceId);\n    const knownDeviceIds: string[] = Array.from(availableDevices.values()).map(d => d.deviceId);\n    const lostActiveDevices: MediaDeviceInfo[] = [];\n\n    // Remove lost devices\n    const lostDeviceIds: string[] = difference(knownDeviceIds, updatedDeviceIds);\n    lostDeviceIds.forEach((lostDeviceId: string) => {\n      const lostDevice: MediaDeviceInfo | undefined = availableDevices.get(lostDeviceId);\n      if (lostDevice) {\n        availableDevices.delete(lostDeviceId);\n        if (removeLostDevice(lostDevice)) { lostActiveDevices.push(lostDevice); }\n      }\n    });\n\n    // Add any new devices, or devices with updated labels\n    let deviceChanged: boolean = false;\n    updatedDevices.forEach(newDevice => {\n      const existingDevice: MediaDeviceInfo | undefined = availableDevices.get(newDevice.deviceId);\n      const newMediaDeviceInfo: MediaDeviceInfo = this._wrapMediaDeviceInfo(newDevice);\n\n      if (!existingDevice || existingDevice.label !== newMediaDeviceInfo.label) {\n        availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);\n        deviceChanged = true;\n      }\n    });\n\n    if (deviceChanged || lostDeviceIds.length) {\n      // Force a new gUM in case the underlying tracks of the active stream have changed. One\n      //   reason this might happen is when `default` is selected and set to a USB device,\n      //   then that device is unplugged or plugged back in. We can't check for the 'ended'\n      //   event or readyState because it is asynchronous and may take upwards of 5 seconds,\n      //   in my testing. (rrowland)\n      const defaultId = 'default';\n      // this.inputDevice is not null if audio.setInputDevice() was explicitly called\n      const isInputDeviceSet = this.inputDevice && this.inputDevice.deviceId === defaultId;\n      // If this.inputDevice is null, and default stream is not null, it means\n      // the user is using the default stream and did not explicitly call audio.setInputDevice()\n      const isDefaultDeviceSet = this._defaultInputDeviceStream && this.availableInputDevices.get(defaultId);\n\n      if (isInputDeviceSet || isDefaultDeviceSet) {\n        this._log.warn(`Calling getUserMedia after device change to ensure that the \\\n          tracks of the active device (default) have not gone stale.`);\n\n        // NOTE(csantos): Updating the stream in the same execution context as the devicechange event\n        // causes the new gUM call to fail silently. Meaning, the gUM call may succeed,\n        // but it won't actually update the stream. We need to update the stream in a different\n        // execution context (setTimeout) to properly update the stream.\n        setTimeout(() => {\n          this._setInputDevice(defaultId, true);\n        }, 0);\n      }\n      this._log.debug('#deviceChange', lostActiveDevices);\n      this.emit('deviceChange', lostActiveDevices);\n    }\n  }\n\n  /**\n   * Disconnect the old input volume source, and create and connect a new one with the current\n   * input stream.\n   */\n  private _updateVolumeSource(): void {\n    if (!this.inputStream || !this._audioContext || !this._inputVolumeAnalyser) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n    }\n\n    try {\n      this._inputVolumeSource = this._audioContext.createMediaStreamSource(this.inputStream);\n      this._inputVolumeSource.connect(this._inputVolumeAnalyser);\n    } catch (ex) {\n      this._log.warn('Unable to update volume source', ex);\n      delete this._inputVolumeSource;\n    }\n  }\n\n  /**\n   * Convert a MediaDeviceInfo to a IMediaDeviceInfoShim.\n   * @param mediaDeviceInfo - The info to convert\n   * @returns The converted shim\n   */\n  private _wrapMediaDeviceInfo(mediaDeviceInfo: MediaDeviceInfo): MediaDeviceInfo {\n    const options: Record<string, string> = {\n      deviceId: mediaDeviceInfo.deviceId,\n      groupId: mediaDeviceInfo.groupId,\n      kind: mediaDeviceInfo.kind,\n      label: mediaDeviceInfo.label,\n    };\n\n    if (!options.label) {\n      if (options.deviceId === 'default') {\n        options.label = 'Default';\n      } else {\n        const index: number = this._getUnknownDeviceIndex(mediaDeviceInfo);\n        options.label = `Unknown ${kindAliases[options.kind]} Device ${index}`;\n      }\n    }\n\n    return new MediaDeviceInfoShim(options) as MediaDeviceInfo;\n  }\n}\n\nnamespace AudioHelper {\n  /**\n   * Emitted when the available set of Devices changes.\n   * @param lostActiveDevices - An array containing any Devices that were previously active\n   * that were lost as a result of this deviceChange event.\n   * @example `device.audio.on('deviceChange', lostActiveDevices => { })`\n   * @event\n   */\n  declare function deviceChangeEvent(lostActiveDevices: MediaDeviceInfo[]): void;\n\n  /**\n   * Emitted on `requestAnimationFrame` (up to 60fps, depending on browser) with\n   *   the current input and output volumes, as a percentage of maximum\n   *   volume, between -100dB and -30dB. Represented by a floating point\n   *   number.\n   * @param inputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @example `device.audio.on('inputVolume', volume => { })`\n   * @event\n   */\n  declare function inputVolumeEvent(inputVolume: number): void;\n\n  /**\n   * An object like MediaDevices.\n   * @private\n   */\n  export interface MediaDevicesLike {\n    addEventListener?: (eventName: string, handler: (...args: any[]) => void) => void;\n    enumerateDevices: (...args: any[]) => any;\n    getUserMedia: (...args: any[]) => any;\n    removeEventListener?: (eventName: string, handler: (...args: any[]) => void) => void;\n  }\n\n  /**\n   * Options that can be passed to the AudioHelper constructor\n   * @private\n   */\n  export interface Options {\n    /**\n     * A custom replacement for the AudioContext constructor.\n     */\n    AudioContext?: typeof AudioContext;\n\n    /**\n     * An existing AudioContext instance to use.\n     */\n    audioContext?: AudioContext;\n\n    /**\n     * AudioProcessorEventObserver to use\n     */\n    audioProcessorEventObserver: AudioProcessorEventObserver;\n\n    /**\n     * Promise to wait for before setting the input device.\n     */\n    beforeSetInputDevice?: () => Promise<any>;\n\n    /**\n     * Whether each sound is enabled.\n     */\n    enabledSounds?: Record<Device.ToggleableSound, boolean>;\n\n    /**\n     * Overrides the native MediaDevices.enumerateDevices API.\n     */\n    enumerateDevices?: any;\n\n    /**\n     * The getUserMedia method to use\n     */\n    getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>;\n\n    /**\n     * A custom MediaDevices instance to use.\n     */\n    mediaDevices?: AudioHelper.MediaDevicesLike;\n\n    /**\n     * A custom setSinkId function to use.\n     */\n    setSinkId?: (sinkId: string) => Promise<void>;\n  }\n}\n\nexport default AudioHelper;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}