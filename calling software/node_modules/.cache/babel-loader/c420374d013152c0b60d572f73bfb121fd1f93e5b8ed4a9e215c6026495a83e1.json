{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nvar errors_1 = require(\"../errors\");\nvar log_1 = require(\"../log\");\nvar util = require(\"../util\");\nvar rtcpc_1 = require(\"./rtcpc\");\nvar sdp_1 = require(\"./sdp\");\nvar ICE_GATHERING_TIMEOUT = 15000;\nvar ICE_GATHERING_FAIL_NONE = 'none';\nvar ICE_GATHERING_FAIL_TIMEOUT = 'timeout';\nvar INITIAL_ICE_CONNECTION_STATE = 'new';\nvar VOLUME_INTERVAL_MS = 50;\n/**\n * @typedef {Object} PeerConnection\n * @param audioHelper\n * @param pstream\n * @param options\n * @return {PeerConnection}\n * @constructor\n */\nfunction PeerConnection(audioHelper, pstream, options) {\n  if (!audioHelper || !pstream) {\n    throw new errors_1.InvalidArgumentError('Audiohelper, and pstream are required arguments');\n  }\n  if (!(this instanceof PeerConnection)) {\n    return new PeerConnection(audioHelper, pstream, options);\n  }\n  this._log = new log_1.default('PeerConnection');\n  function noop() {\n    this._log.warn('Unexpected noop call in peerconnection');\n  }\n  this.onaudio = noop;\n  this.onopen = noop;\n  this.onerror = noop;\n  this.onclose = noop;\n  this.ondisconnected = noop;\n  this.onfailed = noop;\n  this.onconnected = noop;\n  this.onreconnected = noop;\n  this.onsignalingstatechange = noop;\n  this.ondtlstransportstatechange = noop;\n  this.onicegatheringfailure = noop;\n  this.onicegatheringstatechange = noop;\n  this.oniceconnectionstatechange = noop;\n  this.onpcconnectionstatechange = noop;\n  this.onicecandidate = noop;\n  this.onselectedcandidatepairchange = noop;\n  this.onvolume = noop;\n  this.version = null;\n  this.pstream = pstream;\n  this.stream = null;\n  this.sinkIds = new Set(['default']);\n  this.outputs = new Map();\n  this.status = 'connecting';\n  this.callSid = null;\n  this.isMuted = false;\n  var AudioContext = typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\n  this._isSinkSupported = !!AudioContext && typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId;\n  // NOTE(mmalavalli): Since each Connection creates its own AudioContext,\n  // after 6 instances an exception is thrown. Refer https://www.w3.org/2011/audio/track/issues/3.\n  // In order to get around it, we are re-using the Device's AudioContext.\n  this._audioContext = AudioContext && audioHelper._audioContext;\n  this._audioHelper = audioHelper;\n  this._hasIceCandidates = false;\n  this._hasIceGatheringFailures = false;\n  this._iceGatheringTimeoutId = null;\n  this._masterAudio = null;\n  this._masterAudioDeviceId = null;\n  this._mediaStreamSource = null;\n  this._dtmfSender = null;\n  this._dtmfSenderUnsupported = false;\n  this._callEvents = [];\n  this._nextTimeToPublish = Date.now();\n  this._onAnswerOrRinging = noop;\n  this._onHangup = noop;\n  this._remoteStream = null;\n  this._shouldManageStream = true;\n  this._iceState = INITIAL_ICE_CONNECTION_STATE;\n  this._isUnifiedPlan = options.isUnifiedPlan;\n  this.options = options = options || {};\n  this.navigator = options.navigator || (typeof navigator !== 'undefined' ? navigator : null);\n  this.util = options.util || util;\n  this.codecPreferences = options.codecPreferences;\n  return this;\n}\nPeerConnection.prototype.uri = function () {\n  return this._uri;\n};\n/**\n * Open the underlying RTCPeerConnection with a MediaStream obtained by\n *   passed constraints. The resulting MediaStream is created internally\n *   and will therefore be managed and destroyed internally.\n * @param {MediaStreamConstraints} constraints\n */\nPeerConnection.prototype.openDefaultDeviceWithConstraints = function (constraints) {\n  return this._audioHelper._openDefaultDeviceWithConstraints(constraints).then(this._setInputTracksFromStream.bind(this, false));\n};\n/**\n * Replace the existing input audio tracks with the audio tracks from the\n *   passed input audio stream. We re-use the existing stream because\n *   the AnalyzerNode is bound to the stream.\n * @param {MediaStream} stream\n */\nPeerConnection.prototype.setInputTracksFromStream = function (stream) {\n  var self = this;\n  return this._setInputTracksFromStream(true, stream).then(function () {\n    self._shouldManageStream = false;\n  });\n};\nPeerConnection.prototype._createAnalyser = function (audioContext, options) {\n  options = Object.assign({\n    fftSize: 32,\n    smoothingTimeConstant: 0.3\n  }, options);\n  var analyser = audioContext.createAnalyser();\n  // tslint:disable-next-line\n  for (var field in options) {\n    analyser[field] = options[field];\n  }\n  return analyser;\n};\nPeerConnection.prototype._setVolumeHandler = function (handler) {\n  this.onvolume = handler;\n};\nPeerConnection.prototype._startPollingVolume = function () {\n  if (!this._audioContext || !this.stream || !this._remoteStream) {\n    return;\n  }\n  var audioContext = this._audioContext;\n  var inputAnalyser = this._inputAnalyser = this._createAnalyser(audioContext);\n  var inputBufferLength = inputAnalyser.frequencyBinCount;\n  var inputDataArray = new Uint8Array(inputBufferLength);\n  this._inputAnalyser2 = this._createAnalyser(audioContext, {\n    maxDecibels: 0,\n    minDecibels: -127,\n    smoothingTimeConstant: 0\n  });\n  var outputAnalyser = this._outputAnalyser = this._createAnalyser(audioContext);\n  var outputBufferLength = outputAnalyser.frequencyBinCount;\n  var outputDataArray = new Uint8Array(outputBufferLength);\n  this._outputAnalyser2 = this._createAnalyser(audioContext, {\n    maxDecibels: 0,\n    minDecibels: -127,\n    smoothingTimeConstant: 0\n  });\n  this._updateInputStreamSource(this.stream);\n  this._updateOutputStreamSource(this._remoteStream);\n  var self = this;\n  setTimeout(function emitVolume() {\n    if (!self._audioContext) {\n      return;\n    } else if (self.status === 'closed') {\n      self._inputAnalyser.disconnect();\n      self._outputAnalyser.disconnect();\n      self._inputAnalyser2.disconnect();\n      self._outputAnalyser2.disconnect();\n      return;\n    }\n    self._inputAnalyser.getByteFrequencyData(inputDataArray);\n    var inputVolume = self.util.average(inputDataArray);\n    self._inputAnalyser2.getByteFrequencyData(inputDataArray);\n    var inputVolume2 = self.util.average(inputDataArray);\n    self._outputAnalyser.getByteFrequencyData(outputDataArray);\n    var outputVolume = self.util.average(outputDataArray);\n    self._outputAnalyser2.getByteFrequencyData(outputDataArray);\n    var outputVolume2 = self.util.average(outputDataArray);\n    self.onvolume(inputVolume / 255, outputVolume / 255, inputVolume2, outputVolume2);\n    setTimeout(emitVolume, VOLUME_INTERVAL_MS);\n  }, VOLUME_INTERVAL_MS);\n};\nPeerConnection.prototype._stopStream = function _stopStream() {\n  // We shouldn't stop the tracks if they were not created inside\n  //   this PeerConnection.\n  if (!this._shouldManageStream) {\n    return;\n  }\n  this._audioHelper._stopDefaultInputDeviceStream();\n};\n/**\n * Update the stream source with the new input audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateInputStreamSource = function (stream) {\n  if (this._inputStreamSource) {\n    this._inputStreamSource.disconnect();\n  }\n  try {\n    this._inputStreamSource = this._audioContext.createMediaStreamSource(stream);\n    this._inputStreamSource.connect(this._inputAnalyser);\n    this._inputStreamSource.connect(this._inputAnalyser2);\n  } catch (ex) {\n    this._log.warn('Unable to update input MediaStreamSource', ex);\n    this._inputStreamSource = null;\n  }\n};\n/**\n * Update the stream source with the new ouput audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateOutputStreamSource = function (stream) {\n  if (this._outputStreamSource) {\n    this._outputStreamSource.disconnect();\n  }\n  try {\n    this._outputStreamSource = this._audioContext.createMediaStreamSource(stream);\n    this._outputStreamSource.connect(this._outputAnalyser);\n    this._outputStreamSource.connect(this._outputAnalyser2);\n  } catch (ex) {\n    this._log.warn('Unable to update output MediaStreamSource', ex);\n    this._outputStreamSource = null;\n  }\n};\n/**\n * Replace the tracks of the current stream with new tracks. We do this rather than replacing the\n *   whole stream because AnalyzerNodes are bound to a stream.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksFromStream = function (shouldClone, newStream) {\n  return this._isUnifiedPlan ? this._setInputTracksForUnifiedPlan(shouldClone, newStream) : this._setInputTracksForPlanB(shouldClone, newStream);\n};\n/**\n * Replace the tracks of the current stream with new tracks using the 'plan-b' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForPlanB = function (shouldClone, newStream) {\n  var _this = this;\n  if (!newStream) {\n    return Promise.reject(new errors_1.InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new errors_1.InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n  var localStream = this.stream;\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    this._stopStream();\n    removeStream(this.version.pc, localStream);\n    localStream.getAudioTracks().forEach(localStream.removeTrack, localStream);\n    newStream.getAudioTracks().forEach(localStream.addTrack, localStream);\n    addStream(this.version.pc, newStream);\n    this._updateInputStreamSource(this.stream);\n  }\n  // Apply mute settings to new input track\n  this.mute(this.isMuted);\n  if (!this.version) {\n    return Promise.resolve(this.stream);\n  }\n  return new Promise(function (resolve, reject) {\n    _this.version.createOffer(_this.options.maxAverageBitrate, _this.codecPreferences, {\n      audio: true\n    }, function () {\n      _this.version.processAnswer(_this.codecPreferences, _this._answerSdp, function () {\n        resolve(_this.stream);\n      }, reject);\n    }, reject);\n  });\n};\n/**\n * Replace the tracks of the current stream with new tracks using the 'unified-plan' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForUnifiedPlan = function (shouldClone, newStream) {\n  var _this = this;\n  if (!newStream) {\n    return Promise.reject(new errors_1.InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new errors_1.InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n  var localStream = this.stream;\n  var getStreamPromise = function () {\n    // Apply mute settings to new input track\n    _this.mute(_this.isMuted);\n    return Promise.resolve(_this.stream);\n  };\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    // If the call was started with gUM, and we are now replacing that track with an\n    // external stream's tracks, we should stop the old managed track.\n    if (this._shouldManageStream) {\n      this._stopStream();\n    }\n    if (!this._sender) {\n      this._sender = this.version.pc.getSenders()[0];\n    }\n    return this._sender.replaceTrack(newStream.getAudioTracks()[0]).then(function () {\n      _this._updateInputStreamSource(newStream);\n      _this.stream = shouldClone ? cloneStream(newStream) : newStream;\n      return getStreamPromise();\n    });\n  }\n  return getStreamPromise();\n};\nPeerConnection.prototype._onInputDevicesChanged = function () {\n  if (!this.stream) {\n    return;\n  }\n  // If all of our active tracks are ended, then our active input was lost\n  var activeInputWasLost = this.stream.getAudioTracks().every(function (track) {\n    return track.readyState === 'ended';\n  });\n  // We only want to act if we manage the stream in PeerConnection (It was created\n  // here, rather than passed in.)\n  if (activeInputWasLost && this._shouldManageStream) {\n    this.openDefaultDeviceWithConstraints({\n      audio: true\n    });\n  }\n};\nPeerConnection.prototype._onIceGatheringFailure = function (type) {\n  this._hasIceGatheringFailures = true;\n  this.onicegatheringfailure(type);\n};\nPeerConnection.prototype._onMediaConnectionStateChange = function (newState) {\n  var previousState = this._iceState;\n  if (previousState === newState || newState !== 'connected' && newState !== 'disconnected' && newState !== 'failed') {\n    return;\n  }\n  this._iceState = newState;\n  var message;\n  switch (newState) {\n    case 'connected':\n      if (previousState === 'disconnected' || previousState === 'failed') {\n        message = 'ICE liveliness check succeeded. Connection with Twilio restored';\n        this._log.info(message);\n        this.onreconnected(message);\n      } else {\n        message = 'Media connection established.';\n        this._log.info(message);\n        this.onconnected(message);\n      }\n      this._stopIceGatheringTimeout();\n      this._hasIceGatheringFailures = false;\n      break;\n    case 'disconnected':\n      message = 'ICE liveliness check failed. May be having trouble connecting to Twilio';\n      this._log.warn(message);\n      this.ondisconnected(message);\n      break;\n    case 'failed':\n      message = 'Connection with Twilio was interrupted.';\n      this._log.warn(message);\n      this.onfailed(message);\n      break;\n  }\n};\nPeerConnection.prototype._setSinkIds = function (sinkIds) {\n  if (!this._isSinkSupported) {\n    return Promise.reject(new errors_1.NotSupportedError('Audio output selection is not supported by this browser'));\n  }\n  this.sinkIds = new Set(sinkIds.forEach ? sinkIds : [sinkIds]);\n  return this.version ? this._updateAudioOutputs() : Promise.resolve();\n};\n/**\n * Start timeout for ICE Gathering\n */\nPeerConnection.prototype._startIceGatheringTimeout = function startIceGatheringTimeout() {\n  var _this = this;\n  this._stopIceGatheringTimeout();\n  this._iceGatheringTimeoutId = setTimeout(function () {\n    _this._onIceGatheringFailure(ICE_GATHERING_FAIL_TIMEOUT);\n  }, ICE_GATHERING_TIMEOUT);\n};\n/**\n * Stop timeout for ICE Gathering\n */\nPeerConnection.prototype._stopIceGatheringTimeout = function stopIceGatheringTimeout() {\n  clearInterval(this._iceGatheringTimeoutId);\n};\nPeerConnection.prototype._updateAudioOutputs = function updateAudioOutputs() {\n  var addedOutputIds = Array.from(this.sinkIds).filter(function (id) {\n    return !this.outputs.has(id);\n  }, this);\n  var removedOutputIds = Array.from(this.outputs.keys()).filter(function (id) {\n    return !this.sinkIds.has(id);\n  }, this);\n  var self = this;\n  var createOutputPromises = addedOutputIds.map(this._createAudioOutput, this);\n  return Promise.all(createOutputPromises).then(function () {\n    return Promise.all(removedOutputIds.map(self._removeAudioOutput, self));\n  });\n};\nPeerConnection.prototype._createAudio = function createAudio(arr) {\n  var audio = new Audio(arr);\n  this.onaudio(audio);\n  return audio;\n};\nPeerConnection.prototype._createAudioOutput = function createAudioOutput(id) {\n  var dest = null;\n  if (this._mediaStreamSource) {\n    dest = this._audioContext.createMediaStreamDestination();\n    this._mediaStreamSource.connect(dest);\n  }\n  var audio = this._createAudio();\n  setAudioSource(audio, dest && dest.stream ? dest.stream : this.pcStream);\n  var self = this;\n  return audio.setSinkId(id).then(function () {\n    return audio.play();\n  }).then(function () {\n    self.outputs.set(id, {\n      audio: audio,\n      dest: dest\n    });\n  });\n};\nPeerConnection.prototype._removeAudioOutputs = function removeAudioOutputs() {\n  if (this._masterAudio && typeof this._masterAudioDeviceId !== 'undefined') {\n    this._disableOutput(this, this._masterAudioDeviceId);\n    this.outputs.delete(this._masterAudioDeviceId);\n    this._masterAudioDeviceId = null;\n    // Release the audio resources before deleting the audio\n    if (!this._masterAudio.paused) {\n      this._masterAudio.pause();\n    }\n    if (typeof this._masterAudio.srcObject !== 'undefined') {\n      this._masterAudio.srcObject = null;\n    } else {\n      this._masterAudio.src = '';\n    }\n    this._masterAudio = null;\n  }\n  return Array.from(this.outputs.keys()).map(this._removeAudioOutput, this);\n};\nPeerConnection.prototype._disableOutput = function disableOutput(pc, id) {\n  var output = pc.outputs.get(id);\n  if (!output) {\n    return;\n  }\n  if (output.audio) {\n    output.audio.pause();\n    output.audio.src = '';\n  }\n  if (output.dest) {\n    output.dest.disconnect();\n  }\n};\n/**\n * Disable a non-master output, and update the master output to assume its state. This\n *   is called when the device ID assigned to the master output has been removed from\n *   active devices. We can not simply remove the master audio output, so we must\n *   instead reassign it.\n * @private\n * @param {PeerConnection} pc\n * @param {string} masterId - The current device ID assigned to the master audio element.\n */\nPeerConnection.prototype._reassignMasterOutput = function reassignMasterOutput(pc, masterId) {\n  var masterOutput = pc.outputs.get(masterId);\n  pc.outputs.delete(masterId);\n  var self = this;\n  var activeDeviceId = Array.from(pc.outputs.keys())[0];\n  // The audio device key could also be '' on Chrome if no media device permissions are allowed\n  var idToReplace = typeof activeDeviceId === 'string' ? activeDeviceId : 'default';\n  return masterOutput.audio.setSinkId(idToReplace).then(function () {\n    self._disableOutput(pc, idToReplace);\n    pc.outputs.set(idToReplace, masterOutput);\n    pc._masterAudioDeviceId = idToReplace;\n  }).catch(function rollback() {\n    pc.outputs.set(masterId, masterOutput);\n    self._log.info('Could not reassign master output. Attempted to roll back.');\n  });\n};\nPeerConnection.prototype._removeAudioOutput = function removeAudioOutput(id) {\n  if (this._masterAudioDeviceId === id) {\n    return this._reassignMasterOutput(this, id);\n  }\n  this._disableOutput(this, id);\n  this.outputs.delete(id);\n  return Promise.resolve();\n};\n/**\n * Use an AudioContext to potentially split our audio output stream to multiple\n *   audio devices. This is only available to browsers with AudioContext and\n *   HTMLAudioElement.setSinkId() available. We save the source stream in\n *   _masterAudio, and use it for one of the active audio devices. We keep\n *   track of its ID because we must replace it if we lose its initial device.\n */\nPeerConnection.prototype._onAddTrack = function onAddTrack(pc, stream) {\n  var audio = pc._masterAudio = this._createAudio();\n  setAudioSource(audio, stream);\n  audio.play();\n  // Assign the initial master audio element to a random active output device\n  var activeDeviceId = Array.from(pc.outputs.keys())[0];\n  // The audio device key could also be '' on Chrome if no media device permissions are allowed\n  var deviceId = typeof activeDeviceId === 'string' ? activeDeviceId : 'default';\n  pc._masterAudioDeviceId = deviceId;\n  pc.outputs.set(deviceId, {\n    audio: audio\n  });\n  try {\n    pc._mediaStreamSource = pc._audioContext.createMediaStreamSource(stream);\n  } catch (ex) {\n    this._log.warn('Unable to create a MediaStreamSource from onAddTrack', ex);\n    this._mediaStreamSource = null;\n  }\n  pc.pcStream = stream;\n  pc._updateAudioOutputs();\n};\n/**\n * Use a single audio element to play the audio output stream. This does not\n *   support multiple output devices, and is a fallback for when AudioContext\n *   and/or HTMLAudioElement.setSinkId() is not available to the client.\n */\nPeerConnection.prototype._fallbackOnAddTrack = function fallbackOnAddTrack(pc, stream) {\n  var audio = document && document.createElement('audio');\n  audio.autoplay = true;\n  if (!setAudioSource(audio, stream)) {\n    pc._log.info('Error attaching stream to element.');\n  }\n  pc.outputs.set('default', {\n    audio: audio\n  });\n};\nPeerConnection.prototype._setEncodingParameters = function (enableDscp) {\n  if (!enableDscp || !this._sender || typeof this._sender.getParameters !== 'function' || typeof this._sender.setParameters !== 'function') {\n    return;\n  }\n  var params = this._sender.getParameters();\n  if (!params.priority && !(params.encodings && params.encodings.length)) {\n    return;\n  }\n  // This is how MDN's RTPSenderParameters defines priority\n  params.priority = 'high';\n  // And this is how it's currently implemented in Chrome M72+\n  if (params.encodings && params.encodings.length) {\n    params.encodings.forEach(function (encoding) {\n      encoding.priority = 'high';\n      encoding.networkPriority = 'high';\n    });\n  }\n  this._sender.setParameters(params);\n};\nPeerConnection.prototype._setupPeerConnection = function (rtcConfiguration) {\n  var _this = this;\n  var self = this;\n  var version = new (this.options.rtcpcFactory || rtcpc_1.default)({\n    RTCPeerConnection: this.options.RTCPeerConnection\n  });\n  version.create(rtcConfiguration);\n  addStream(version.pc, this.stream);\n  var eventName = 'ontrack' in version.pc ? 'ontrack' : 'onaddstream';\n  version.pc[eventName] = function (event) {\n    var stream = self._remoteStream = event.stream || event.streams[0];\n    if (typeof version.pc.getSenders === 'function') {\n      _this._sender = version.pc.getSenders()[0];\n    }\n    if (self._isSinkSupported) {\n      self._onAddTrack(self, stream);\n    } else {\n      self._fallbackOnAddTrack(self, stream);\n    }\n    self._startPollingVolume();\n  };\n  return version;\n};\nPeerConnection.prototype._maybeSetIceAggressiveNomination = function (sdp) {\n  return this.options.forceAggressiveIceNomination ? sdp_1.setIceAggressiveNomination(sdp) : sdp;\n};\nPeerConnection.prototype._setupChannel = function () {\n  var _this = this;\n  var pc = this.version.pc;\n  // Chrome 25 supports onopen\n  this.version.pc.onopen = function () {\n    _this.status = 'open';\n    _this.onopen();\n  };\n  // Chrome 26 doesn't support onopen so must detect state change\n  this.version.pc.onstatechange = function () {\n    if (_this.version.pc && _this.version.pc.readyState === 'stable') {\n      _this.status = 'open';\n      _this.onopen();\n    }\n  };\n  // Chrome 27 changed onstatechange to onsignalingstatechange\n  this.version.pc.onsignalingstatechange = function () {\n    var state = pc.signalingState;\n    _this._log.info(\"signalingState is \\\"\" + state + \"\\\"\");\n    if (_this.version.pc && _this.version.pc.signalingState === 'stable') {\n      _this.status = 'open';\n      _this.onopen();\n    }\n    _this.onsignalingstatechange(pc.signalingState);\n  };\n  // Chrome 72+\n  pc.onconnectionstatechange = function (event) {\n    var state = pc.connectionState;\n    if (!state && event && event.target) {\n      // VDI environment\n      var targetPc = event.target;\n      state = targetPc.connectionState || targetPc.connectionState_;\n      _this._log.info(\"pc.connectionState not detected. Using target PC. State=\" + state);\n    }\n    if (!state) {\n      _this._log.warn(\"onconnectionstatechange detected but state is \\\"\" + state + \"\\\"\");\n    } else {\n      _this._log.info(\"pc.connectionState is \\\"\" + state + \"\\\"\");\n    }\n    _this.onpcconnectionstatechange(state);\n    _this._onMediaConnectionStateChange(state);\n  };\n  pc.onicecandidate = function (event) {\n    var candidate = event.candidate;\n    if (candidate) {\n      _this._hasIceCandidates = true;\n      _this.onicecandidate(candidate);\n      _this._setupRTCIceTransportListener();\n    }\n    _this._log.info(\"ICE Candidate: \" + JSON.stringify(candidate));\n  };\n  pc.onicegatheringstatechange = function () {\n    var state = pc.iceGatheringState;\n    if (state === 'gathering') {\n      _this._startIceGatheringTimeout();\n    } else if (state === 'complete') {\n      _this._stopIceGatheringTimeout();\n      // Fail if no candidates found\n      if (!_this._hasIceCandidates) {\n        _this._onIceGatheringFailure(ICE_GATHERING_FAIL_NONE);\n      }\n      // There was a failure mid-gathering phase. We want to start our timer and issue\n      // an ice restart if we don't get connected after our timeout\n      if (_this._hasIceCandidates && _this._hasIceGatheringFailures) {\n        _this._startIceGatheringTimeout();\n      }\n    }\n    _this._log.info(\"pc.iceGatheringState is \\\"\" + pc.iceGatheringState + \"\\\"\");\n    _this.onicegatheringstatechange(state);\n  };\n  pc.oniceconnectionstatechange = function () {\n    _this._log.info(\"pc.iceConnectionState is \\\"\" + pc.iceConnectionState + \"\\\"\");\n    _this.oniceconnectionstatechange(pc.iceConnectionState);\n    _this._onMediaConnectionStateChange(pc.iceConnectionState);\n  };\n};\nPeerConnection.prototype._initializeMediaStream = function (rtcConfiguration) {\n  // if mediastream already open then do nothing\n  if (this.status === 'open') {\n    return false;\n  }\n  if (this.pstream.status === 'disconnected') {\n    this.onerror({\n      info: {\n        code: 31000,\n        message: 'Cannot establish connection. Client is disconnected',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      }\n    });\n    this.close();\n    return false;\n  }\n  this.version = this._setupPeerConnection(rtcConfiguration);\n  this._setupChannel();\n  return true;\n};\n/**\n * Remove reconnection-related listeners\n * @private\n */\nPeerConnection.prototype._removeReconnectionListeners = function () {\n  if (this.pstream) {\n    this.pstream.removeListener('answer', this._onAnswerOrRinging);\n    this.pstream.removeListener('hangup', this._onHangup);\n  }\n};\n/**\n * Setup a listener for RTCDtlsTransport to capture state changes events\n * @private\n */\nPeerConnection.prototype._setupRTCDtlsTransportListener = function () {\n  var _this = this;\n  var dtlsTransport = this.getRTCDtlsTransport();\n  if (!dtlsTransport || dtlsTransport.onstatechange) {\n    return;\n  }\n  var handler = function () {\n    _this._log.info(\"dtlsTransportState is \\\"\" + dtlsTransport.state + \"\\\"\");\n    _this.ondtlstransportstatechange(dtlsTransport.state);\n  };\n  // Publish initial state\n  handler();\n  dtlsTransport.onstatechange = handler;\n};\n/**\n * Setup a listener for RTCIceTransport to capture selected candidate pair changes\n * @private\n */\nPeerConnection.prototype._setupRTCIceTransportListener = function () {\n  var _this = this;\n  var iceTransport = this._getRTCIceTransport();\n  if (!iceTransport || iceTransport.onselectedcandidatepairchange) {\n    return;\n  }\n  iceTransport.onselectedcandidatepairchange = function () {\n    return _this.onselectedcandidatepairchange(iceTransport.getSelectedCandidatePair());\n  };\n};\n/**\n * Restarts ICE for the current connection\n * ICE Restart failures are ignored. Retries are managed in Connection\n * @private\n */\nPeerConnection.prototype.iceRestart = function () {\n  var _this = this;\n  this._log.info('Attempting to restart ICE...');\n  this._hasIceCandidates = false;\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, {\n    iceRestart: true\n  }).then(function () {\n    _this._removeReconnectionListeners();\n    _this._onAnswerOrRinging = function (payload) {\n      _this._removeReconnectionListeners();\n      if (!payload.sdp || _this.version.pc.signalingState !== 'have-local-offer') {\n        var message = 'Invalid state or param during ICE Restart:' + (\"hasSdp:\" + !!payload.sdp + \", signalingState:\" + _this.version.pc.signalingState);\n        _this._log.warn(message);\n        return;\n      }\n      var sdp = _this._maybeSetIceAggressiveNomination(payload.sdp);\n      _this._answerSdp = sdp;\n      if (_this.status !== 'closed') {\n        _this.version.processAnswer(_this.codecPreferences, sdp, null, function (err) {\n          var message = err && err.message ? err.message : err;\n          _this._log.error(\"Failed to process answer during ICE Restart. Error: \" + message);\n        });\n      }\n    };\n    _this._onHangup = function () {\n      _this._log.info('Received hangup during ICE Restart');\n      _this._removeReconnectionListeners();\n    };\n    _this.pstream.on('answer', _this._onAnswerOrRinging);\n    _this.pstream.on('hangup', _this._onHangup);\n    _this.pstream.reinvite(_this.version.getSDP(), _this.callSid);\n  }).catch(function (err) {\n    var message = err && err.message ? err.message : err;\n    _this._log.error(\"Failed to createOffer during ICE Restart. Error: \" + message);\n    // CreateOffer failures doesn't transition ice state to failed\n    // We need trigger it so it can be picked up by retries\n    _this.onfailed(message);\n  });\n};\nPeerConnection.prototype.makeOutgoingCall = function (params, signalingReconnectToken, callsid, rtcConfiguration, onMediaStarted) {\n  var _this = this;\n  if (!this._initializeMediaStream(rtcConfiguration)) {\n    return;\n  }\n  var self = this;\n  this.callSid = callsid;\n  function onAnswerSuccess() {\n    if (self.options) {\n      self._setEncodingParameters(self.options.dscp);\n    }\n    onMediaStarted(self.version.pc);\n  }\n  function onAnswerError(err) {\n    var errMsg = err.message || err;\n    self.onerror({\n      info: {\n        code: 31000,\n        message: \"Error processing answer: \" + errMsg,\n        twilioError: new errors_1.MediaErrors.ClientRemoteDescFailed()\n      }\n    });\n  }\n  this._onAnswerOrRinging = function (payload) {\n    if (!payload.sdp) {\n      return;\n    }\n    var sdp = _this._maybeSetIceAggressiveNomination(payload.sdp);\n    self._answerSdp = sdp;\n    if (self.status !== 'closed') {\n      self.version.processAnswer(_this.codecPreferences, sdp, onAnswerSuccess, onAnswerError);\n    }\n    self.pstream.removeListener('answer', self._onAnswerOrRinging);\n    self.pstream.removeListener('ringing', self._onAnswerOrRinging);\n  };\n  this.pstream.on('answer', this._onAnswerOrRinging);\n  this.pstream.on('ringing', this._onAnswerOrRinging);\n  function onOfferSuccess() {\n    if (self.status !== 'closed') {\n      if (signalingReconnectToken) {\n        self.pstream.reconnect(self.version.getSDP(), self.callSid, signalingReconnectToken);\n      } else {\n        self.pstream.invite(self.version.getSDP(), self.callSid, params);\n      }\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n  function onOfferError(err) {\n    var errMsg = err.message || err;\n    self.onerror({\n      info: {\n        code: 31000,\n        message: \"Error creating the offer: \" + errMsg,\n        twilioError: new errors_1.MediaErrors.ClientLocalDescFailed()\n      }\n    });\n  }\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, {\n    audio: true\n  }, onOfferSuccess, onOfferError);\n};\nPeerConnection.prototype.answerIncomingCall = function (callSid, sdp, rtcConfiguration, onMediaStarted) {\n  if (!this._initializeMediaStream(rtcConfiguration)) {\n    return;\n  }\n  sdp = this._maybeSetIceAggressiveNomination(sdp);\n  this._answerSdp = sdp.replace(/^a=setup:actpass$/gm, 'a=setup:passive');\n  this.callSid = callSid;\n  var self = this;\n  function onAnswerSuccess() {\n    if (self.status !== 'closed') {\n      self.pstream.answer(self.version.getSDP(), callSid);\n      if (self.options) {\n        self._setEncodingParameters(self.options.dscp);\n      }\n      onMediaStarted(self.version.pc);\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n  function onAnswerError(err) {\n    var errMsg = err.message || err;\n    self.onerror({\n      info: {\n        code: 31000,\n        message: \"Error creating the answer: \" + errMsg,\n        twilioError: new errors_1.MediaErrors.ClientRemoteDescFailed()\n      }\n    });\n  }\n  this.version.processSDP(this.options.maxAverageBitrate, this.codecPreferences, sdp, {\n    audio: true\n  }, onAnswerSuccess, onAnswerError);\n};\nPeerConnection.prototype.close = function () {\n  if (this.version && this.version.pc) {\n    if (this.version.pc.signalingState !== 'closed') {\n      this.version.pc.close();\n    }\n    this.version.pc = null;\n  }\n  if (this.stream) {\n    this.mute(false);\n    this._stopStream();\n  }\n  this.stream = null;\n  this._removeReconnectionListeners();\n  this._stopIceGatheringTimeout();\n  Promise.all(this._removeAudioOutputs()).catch(function () {\n    // We don't need to alert about failures here.\n  });\n  if (this._mediaStreamSource) {\n    this._mediaStreamSource.disconnect();\n  }\n  if (this._inputAnalyser) {\n    this._inputAnalyser.disconnect();\n  }\n  if (this._outputAnalyser) {\n    this._outputAnalyser.disconnect();\n  }\n  if (this._inputAnalyser2) {\n    this._inputAnalyser2.disconnect();\n  }\n  if (this._outputAnalyser2) {\n    this._outputAnalyser2.disconnect();\n  }\n  this.status = 'closed';\n  this.onclose();\n};\nPeerConnection.prototype.reject = function (callSid) {\n  this.callSid = callSid;\n};\nPeerConnection.prototype.ignore = function (callSid) {\n  this.callSid = callSid;\n};\n/**\n * Mute or unmute input audio. If the stream is not yet present, the setting\n *   is saved and applied to future streams/tracks.\n * @params {boolean} shouldMute - Whether the input audio should\n *   be muted or unmuted.\n */\nPeerConnection.prototype.mute = function (shouldMute) {\n  this.isMuted = shouldMute;\n  if (!this.stream) {\n    return;\n  }\n  if (this._sender && this._sender.track) {\n    this._sender.track.enabled = !shouldMute;\n  } else {\n    var audioTracks = typeof this.stream.getAudioTracks === 'function' ? this.stream.getAudioTracks() : this.stream.audioTracks;\n    audioTracks.forEach(function (track) {\n      track.enabled = !shouldMute;\n    });\n  }\n};\n/**\n * Get or create an RTCDTMFSender for the first local audio MediaStreamTrack\n * we can get from the RTCPeerConnection. Return null if unsupported.\n * @instance\n * @returns ?RTCDTMFSender\n */\nPeerConnection.prototype.getOrCreateDTMFSender = function getOrCreateDTMFSender() {\n  if (this._dtmfSender || this._dtmfSenderUnsupported) {\n    return this._dtmfSender || null;\n  }\n  var self = this;\n  var pc = this.version.pc;\n  if (!pc) {\n    this._log.warn('No RTCPeerConnection available to call createDTMFSender on');\n    return null;\n  }\n  if (typeof pc.getSenders === 'function' && (typeof RTCDTMFSender === 'function' || typeof RTCDtmfSender === 'function')) {\n    var chosenSender = pc.getSenders().find(function (sender) {\n      return sender.dtmf;\n    });\n    if (chosenSender) {\n      this._log.info('Using RTCRtpSender#dtmf');\n      this._dtmfSender = chosenSender.dtmf;\n      return this._dtmfSender;\n    }\n  }\n  if (typeof pc.createDTMFSender === 'function' && typeof pc.getLocalStreams === 'function') {\n    var track = pc.getLocalStreams().map(function (stream) {\n      var tracks = self._getAudioTracks(stream);\n      return tracks && tracks[0];\n    })[0];\n    if (!track) {\n      this._log.warn('No local audio MediaStreamTrack available on the RTCPeerConnection to pass to createDTMFSender');\n      return null;\n    }\n    this._log.info('Creating RTCDTMFSender');\n    this._dtmfSender = pc.createDTMFSender(track);\n    return this._dtmfSender;\n  }\n  this._log.info('RTCPeerConnection does not support RTCDTMFSender');\n  this._dtmfSenderUnsupported = true;\n  return null;\n};\n/**\n * Get the RTCDtlTransport object from the PeerConnection\n * @returns RTCDtlTransport\n */\nPeerConnection.prototype.getRTCDtlsTransport = function getRTCDtlsTransport() {\n  var sender = this.version && this.version.pc && typeof this.version.pc.getSenders === 'function' && this.version.pc.getSenders()[0];\n  return sender && sender.transport || null;\n};\nPeerConnection.prototype._canStopMediaStreamTrack = function () {\n  return typeof MediaStreamTrack.prototype.stop === 'function';\n};\nPeerConnection.prototype._getAudioTracks = function (stream) {\n  return typeof stream.getAudioTracks === 'function' ? stream.getAudioTracks() : stream.audioTracks;\n};\n/**\n * Get the RTCIceTransport object from the PeerConnection\n * @returns RTCIceTransport\n */\nPeerConnection.prototype._getRTCIceTransport = function _getRTCIceTransport() {\n  var dtlsTransport = this.getRTCDtlsTransport();\n  return dtlsTransport && dtlsTransport.iceTransport || null;\n};\n// Is PeerConnection.protocol used outside of our SDK? We should remove this if not.\nPeerConnection.protocol = function () {\n  return rtcpc_1.default.test() ? new rtcpc_1.default() : null;\n}();\nfunction addStream(pc, stream) {\n  if (typeof pc.addTrack === 'function') {\n    stream.getAudioTracks().forEach(function (track) {\n      // The second parameters, stream, should not be necessary per the latest editor's\n      //   draft, but FF requires it. https://bugzilla.mozilla.org/show_bug.cgi?id=1231414\n      pc.addTrack(track, stream);\n    });\n  } else {\n    pc.addStream(stream);\n  }\n}\nfunction cloneStream(oldStream) {\n  var newStream = typeof MediaStream !== 'undefined' ? new MediaStream() : new webkitMediaStream();\n  oldStream.getAudioTracks().forEach(newStream.addTrack, newStream);\n  return newStream;\n}\nfunction removeStream(pc, stream) {\n  if (typeof pc.removeTrack === 'function') {\n    pc.getSenders().forEach(function (sender) {\n      pc.removeTrack(sender);\n    });\n  } else {\n    pc.removeStream(stream);\n  }\n}\n/**\n * Set the source of an HTMLAudioElement to the specified MediaStream\n * @param {HTMLAudioElement} audio\n * @param {MediaStream} stream\n * @returns {boolean} Whether the audio source was set successfully\n */\nfunction setAudioSource(audio, stream) {\n  if (typeof audio.srcObject !== 'undefined') {\n    audio.srcObject = stream;\n  } else if (typeof audio.mozSrcObject !== 'undefined') {\n    audio.mozSrcObject = stream;\n  } else if (typeof audio.src !== 'undefined') {\n    var _window = audio.options.window || window;\n    audio.src = (_window.URL || _window.webkitURL).createObjectURL(stream);\n  } else {\n    return false;\n  }\n  return true;\n}\nPeerConnection.enabled = rtcpc_1.default.test();\nexports.default = PeerConnection;","map":{"version":3,"names":["errors_1","require","log_1","util","rtcpc_1","sdp_1","ICE_GATHERING_TIMEOUT","ICE_GATHERING_FAIL_NONE","ICE_GATHERING_FAIL_TIMEOUT","INITIAL_ICE_CONNECTION_STATE","VOLUME_INTERVAL_MS","PeerConnection","audioHelper","pstream","options","InvalidArgumentError","_log","default","noop","warn","onaudio","onopen","onerror","onclose","ondisconnected","onfailed","onconnected","onreconnected","onsignalingstatechange","ondtlstransportstatechange","onicegatheringfailure","onicegatheringstatechange","oniceconnectionstatechange","onpcconnectionstatechange","onicecandidate","onselectedcandidatepairchange","onvolume","version","stream","sinkIds","Set","outputs","Map","status","callSid","isMuted","AudioContext","window","webkitAudioContext","_isSinkSupported","HTMLAudioElement","prototype","setSinkId","_audioContext","_audioHelper","_hasIceCandidates","_hasIceGatheringFailures","_iceGatheringTimeoutId","_masterAudio","_masterAudioDeviceId","_mediaStreamSource","_dtmfSender","_dtmfSenderUnsupported","_callEvents","_nextTimeToPublish","Date","now","_onAnswerOrRinging","_onHangup","_remoteStream","_shouldManageStream","_iceState","_isUnifiedPlan","isUnifiedPlan","navigator","codecPreferences","uri","_uri","openDefaultDeviceWithConstraints","constraints","_openDefaultDeviceWithConstraints","then","_setInputTracksFromStream","bind","setInputTracksFromStream","self","_createAnalyser","audioContext","Object","assign","fftSize","smoothingTimeConstant","analyser","createAnalyser","field","_setVolumeHandler","handler","_startPollingVolume","inputAnalyser","_inputAnalyser","inputBufferLength","frequencyBinCount","inputDataArray","Uint8Array","_inputAnalyser2","maxDecibels","minDecibels","outputAnalyser","_outputAnalyser","outputBufferLength","outputDataArray","_outputAnalyser2","_updateInputStreamSource","_updateOutputStreamSource","setTimeout","emitVolume","disconnect","getByteFrequencyData","inputVolume","average","inputVolume2","outputVolume","outputVolume2","_stopStream","_stopDefaultInputDeviceStream","_inputStreamSource","createMediaStreamSource","connect","ex","_outputStreamSource","shouldClone","newStream","_setInputTracksForUnifiedPlan","_setInputTracksForPlanB","_this","Promise","reject","getAudioTracks","length","localStream","cloneStream","removeStream","pc","forEach","removeTrack","addTrack","addStream","mute","resolve","createOffer","maxAverageBitrate","audio","processAnswer","_answerSdp","getStreamPromise","_sender","getSenders","replaceTrack","_onInputDevicesChanged","activeInputWasLost","every","track","readyState","_onIceGatheringFailure","type","_onMediaConnectionStateChange","newState","previousState","message","info","_stopIceGatheringTimeout","_setSinkIds","NotSupportedError","_updateAudioOutputs","_startIceGatheringTimeout","startIceGatheringTimeout","stopIceGatheringTimeout","clearInterval","updateAudioOutputs","addedOutputIds","Array","from","filter","id","has","removedOutputIds","keys","createOutputPromises","map","_createAudioOutput","all","_removeAudioOutput","_createAudio","createAudio","arr","Audio","createAudioOutput","dest","createMediaStreamDestination","setAudioSource","pcStream","play","set","_removeAudioOutputs","removeAudioOutputs","_disableOutput","delete","paused","pause","srcObject","src","disableOutput","output","get","_reassignMasterOutput","reassignMasterOutput","masterId","masterOutput","activeDeviceId","idToReplace","catch","rollback","removeAudioOutput","_onAddTrack","onAddTrack","deviceId","_fallbackOnAddTrack","fallbackOnAddTrack","document","createElement","autoplay","_setEncodingParameters","enableDscp","getParameters","setParameters","params","priority","encodings","encoding","networkPriority","_setupPeerConnection","rtcConfiguration","rtcpcFactory","RTCPeerConnection","create","eventName","event","streams","_maybeSetIceAggressiveNomination","sdp","forceAggressiveIceNomination","setIceAggressiveNomination","_setupChannel","onstatechange","state","signalingState","onconnectionstatechange","connectionState","target","targetPc","connectionState_","candidate","_setupRTCIceTransportListener","JSON","stringify","iceGatheringState","iceConnectionState","_initializeMediaStream","code","twilioError","SignalingErrors","ConnectionDisconnected","close","_removeReconnectionListeners","removeListener","_setupRTCDtlsTransportListener","dtlsTransport","getRTCDtlsTransport","iceTransport","_getRTCIceTransport","getSelectedCandidatePair","iceRestart","payload","err","error","on","reinvite","getSDP","makeOutgoingCall","signalingReconnectToken","callsid","onMediaStarted","onAnswerSuccess","dscp","onAnswerError","errMsg","MediaErrors","ClientRemoteDescFailed","onOfferSuccess","reconnect","invite","onOfferError","ClientLocalDescFailed","answerIncomingCall","replace","answer","processSDP","ignore","shouldMute","enabled","audioTracks","getOrCreateDTMFSender","RTCDTMFSender","RTCDtmfSender","chosenSender","find","sender","dtmf","createDTMFSender","getLocalStreams","tracks","_getAudioTracks","transport","_canStopMediaStreamTrack","MediaStreamTrack","stop","protocol","test","oldStream","MediaStream","webkitMediaStream","mozSrcObject","_window","URL","webkitURL","createObjectURL","exports"],"sources":["C:\\Users\\91629\\Desktop\\Delote\\calling software\\node_modules\\@twilio\\voice-sdk\\lib\\twilio\\rtc\\peerconnection.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nimport {\n  InvalidArgumentError,\n  MediaErrors,\n  NotSupportedError,\n  SignalingErrors,\n} from '../errors';\nimport Log from '../log';\nimport * as util from '../util';\nimport RTCPC from './rtcpc';\nimport { setIceAggressiveNomination } from './sdp';\n\nconst ICE_GATHERING_TIMEOUT = 15000;\nconst ICE_GATHERING_FAIL_NONE = 'none';\nconst ICE_GATHERING_FAIL_TIMEOUT = 'timeout';\nconst INITIAL_ICE_CONNECTION_STATE = 'new';\nconst VOLUME_INTERVAL_MS = 50;\n\n/**\n * @typedef {Object} PeerConnection\n * @param audioHelper\n * @param pstream\n * @param options\n * @return {PeerConnection}\n * @constructor\n */\nfunction PeerConnection(audioHelper, pstream, options) {\n  if (!audioHelper || !pstream) {\n    throw new InvalidArgumentError('Audiohelper, and pstream are required arguments');\n  }\n\n  if (!(this instanceof PeerConnection)) {\n    return new PeerConnection(audioHelper, pstream, options);\n  }\n\n  this._log = new Log('PeerConnection');\n\n  function noop() {\n    this._log.warn('Unexpected noop call in peerconnection');\n  }\n  this.onaudio = noop;\n  this.onopen = noop;\n  this.onerror = noop;\n  this.onclose = noop;\n  this.ondisconnected = noop;\n  this.onfailed = noop;\n  this.onconnected = noop;\n  this.onreconnected = noop;\n  this.onsignalingstatechange = noop;\n  this.ondtlstransportstatechange = noop;\n  this.onicegatheringfailure = noop;\n  this.onicegatheringstatechange = noop;\n  this.oniceconnectionstatechange = noop;\n  this.onpcconnectionstatechange = noop;\n  this.onicecandidate = noop;\n  this.onselectedcandidatepairchange = noop;\n  this.onvolume = noop;\n  this.version = null;\n  this.pstream = pstream;\n  this.stream = null;\n  this.sinkIds = new Set(['default']);\n  this.outputs = new Map();\n  this.status = 'connecting';\n  this.callSid = null;\n  this.isMuted = false;\n\n  const AudioContext = typeof window !== 'undefined'\n    && (window.AudioContext || window.webkitAudioContext);\n  this._isSinkSupported = !!AudioContext &&\n    typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId;\n  // NOTE(mmalavalli): Since each Connection creates its own AudioContext,\n  // after 6 instances an exception is thrown. Refer https://www.w3.org/2011/audio/track/issues/3.\n  // In order to get around it, we are re-using the Device's AudioContext.\n  this._audioContext = AudioContext && audioHelper._audioContext;\n  this._audioHelper = audioHelper;\n  this._hasIceCandidates = false;\n  this._hasIceGatheringFailures = false;\n  this._iceGatheringTimeoutId = null;\n  this._masterAudio = null;\n  this._masterAudioDeviceId = null;\n  this._mediaStreamSource = null;\n  this._dtmfSender = null;\n  this._dtmfSenderUnsupported = false;\n  this._callEvents = [];\n  this._nextTimeToPublish = Date.now();\n  this._onAnswerOrRinging = noop;\n  this._onHangup = noop;\n  this._remoteStream = null;\n  this._shouldManageStream = true;\n  this._iceState = INITIAL_ICE_CONNECTION_STATE;\n  this._isUnifiedPlan = options.isUnifiedPlan;\n\n  this.options = options = options || {};\n  this.navigator = options.navigator\n    || (typeof navigator !== 'undefined' ? navigator : null);\n  this.util = options.util || util;\n  this.codecPreferences = options.codecPreferences;\n\n  return this;\n}\n\nPeerConnection.prototype.uri = function() {\n  return this._uri;\n};\n\n/**\n * Open the underlying RTCPeerConnection with a MediaStream obtained by\n *   passed constraints. The resulting MediaStream is created internally\n *   and will therefore be managed and destroyed internally.\n * @param {MediaStreamConstraints} constraints\n */\nPeerConnection.prototype.openDefaultDeviceWithConstraints = function(constraints) {\n  return this._audioHelper._openDefaultDeviceWithConstraints(constraints)\n    .then(this._setInputTracksFromStream.bind(this, false));\n};\n\n/**\n * Replace the existing input audio tracks with the audio tracks from the\n *   passed input audio stream. We re-use the existing stream because\n *   the AnalyzerNode is bound to the stream.\n * @param {MediaStream} stream\n */\nPeerConnection.prototype.setInputTracksFromStream = function(stream) {\n  const self = this;\n  return this._setInputTracksFromStream(true, stream).then(() => {\n    self._shouldManageStream = false;\n  });\n};\n\nPeerConnection.prototype._createAnalyser = (audioContext, options) => {\n  options = Object.assign({\n    fftSize: 32,\n    smoothingTimeConstant: 0.3,\n  }, options);\n\n  const analyser = audioContext.createAnalyser();\n  // tslint:disable-next-line\n  for (const field in options) {\n    analyser[field] = options[field];\n  }\n\n  return analyser;\n};\n\nPeerConnection.prototype._setVolumeHandler = function(handler) {\n  this.onvolume = handler;\n};\nPeerConnection.prototype._startPollingVolume = function() {\n  if (!this._audioContext || !this.stream || !this._remoteStream) {\n    return;\n  }\n\n  const audioContext = this._audioContext;\n\n  const inputAnalyser = this._inputAnalyser = this._createAnalyser(audioContext);\n  const inputBufferLength = inputAnalyser.frequencyBinCount;\n  const inputDataArray = new Uint8Array(inputBufferLength);\n  this._inputAnalyser2 = this._createAnalyser(audioContext, {\n    maxDecibels: 0,\n    minDecibels: -127,\n    smoothingTimeConstant: 0,\n  });\n\n  const outputAnalyser = this._outputAnalyser = this._createAnalyser(audioContext);\n  const outputBufferLength = outputAnalyser.frequencyBinCount;\n  const outputDataArray = new Uint8Array(outputBufferLength);\n  this._outputAnalyser2 = this._createAnalyser(audioContext, {\n    maxDecibels: 0,\n    minDecibels: -127,\n    smoothingTimeConstant: 0,\n  });\n\n  this._updateInputStreamSource(this.stream);\n  this._updateOutputStreamSource(this._remoteStream);\n\n  const self = this;\n  setTimeout(function emitVolume() {\n    if (!self._audioContext) {\n      return;\n    } else if (self.status === 'closed') {\n      self._inputAnalyser.disconnect();\n      self._outputAnalyser.disconnect();\n      self._inputAnalyser2.disconnect();\n      self._outputAnalyser2.disconnect();\n      return;\n    }\n\n    self._inputAnalyser.getByteFrequencyData(inputDataArray);\n    const inputVolume = self.util.average(inputDataArray);\n\n    self._inputAnalyser2.getByteFrequencyData(inputDataArray);\n    const inputVolume2 = self.util.average(inputDataArray);\n\n    self._outputAnalyser.getByteFrequencyData(outputDataArray);\n    const outputVolume = self.util.average(outputDataArray);\n\n    self._outputAnalyser2.getByteFrequencyData(outputDataArray);\n    const outputVolume2 = self.util.average(outputDataArray);\n    self.onvolume(inputVolume / 255, outputVolume / 255, inputVolume2, outputVolume2);\n\n    setTimeout(emitVolume, VOLUME_INTERVAL_MS);\n  }, VOLUME_INTERVAL_MS);\n};\n\nPeerConnection.prototype._stopStream = function _stopStream() {\n  // We shouldn't stop the tracks if they were not created inside\n  //   this PeerConnection.\n  if (!this._shouldManageStream) {\n    return;\n  }\n\n  this._audioHelper._stopDefaultInputDeviceStream();\n};\n\n/**\n * Update the stream source with the new input audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateInputStreamSource = function(stream) {\n  if (this._inputStreamSource) {\n    this._inputStreamSource.disconnect();\n  }\n\n  try {\n    this._inputStreamSource = this._audioContext.createMediaStreamSource(stream);\n    this._inputStreamSource.connect(this._inputAnalyser);\n    this._inputStreamSource.connect(this._inputAnalyser2);\n  } catch (ex) {\n    this._log.warn('Unable to update input MediaStreamSource', ex);\n    this._inputStreamSource = null;\n  }\n};\n\n/**\n * Update the stream source with the new ouput audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateOutputStreamSource = function(stream) {\n  if (this._outputStreamSource) {\n    this._outputStreamSource.disconnect();\n  }\n\n  try {\n    this._outputStreamSource = this._audioContext.createMediaStreamSource(stream);\n    this._outputStreamSource.connect(this._outputAnalyser);\n    this._outputStreamSource.connect(this._outputAnalyser2);\n  } catch (ex) {\n    this._log.warn('Unable to update output MediaStreamSource', ex);\n    this._outputStreamSource = null;\n  }\n};\n\n/**\n * Replace the tracks of the current stream with new tracks. We do this rather than replacing the\n *   whole stream because AnalyzerNodes are bound to a stream.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksFromStream = function(shouldClone, newStream) {\n  return this._isUnifiedPlan\n    ? this._setInputTracksForUnifiedPlan(shouldClone, newStream)\n    : this._setInputTracksForPlanB(shouldClone, newStream);\n};\n\n/**\n * Replace the tracks of the current stream with new tracks using the 'plan-b' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForPlanB = function(shouldClone, newStream) {\n  if (!newStream) {\n    return Promise.reject(new InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n\n  const localStream = this.stream;\n\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    this._stopStream();\n\n    removeStream(this.version.pc, localStream);\n    localStream.getAudioTracks().forEach(localStream.removeTrack, localStream);\n    newStream.getAudioTracks().forEach(localStream.addTrack, localStream);\n    addStream(this.version.pc, newStream);\n\n    this._updateInputStreamSource(this.stream);\n  }\n\n  // Apply mute settings to new input track\n  this.mute(this.isMuted);\n\n  if (!this.version) {\n    return Promise.resolve(this.stream);\n  }\n\n  return new Promise((resolve, reject) => {\n    this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, { audio: true }, () => {\n      this.version.processAnswer(this.codecPreferences, this._answerSdp, () => {\n        resolve(this.stream);\n      }, reject);\n    }, reject);\n  });\n};\n\n/**\n * Replace the tracks of the current stream with new tracks using the 'unified-plan' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForUnifiedPlan = function(shouldClone, newStream) {\n  if (!newStream) {\n    return Promise.reject(new InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n\n  const localStream = this.stream;\n  const getStreamPromise = () => {\n    // Apply mute settings to new input track\n    this.mute(this.isMuted);\n    return Promise.resolve(this.stream);\n  };\n\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    // If the call was started with gUM, and we are now replacing that track with an\n    // external stream's tracks, we should stop the old managed track.\n    if (this._shouldManageStream) {\n      this._stopStream();\n    }\n\n    if (!this._sender) {\n      this._sender = this.version.pc.getSenders()[0];\n    }\n\n    return this._sender.replaceTrack(newStream.getAudioTracks()[0]).then(() => {\n      this._updateInputStreamSource(newStream);\n      this.stream = shouldClone ? cloneStream(newStream) : newStream;\n      return getStreamPromise();\n    });\n  }\n\n  return getStreamPromise();\n};\n\nPeerConnection.prototype._onInputDevicesChanged = function() {\n  if (!this.stream) { return; }\n\n  // If all of our active tracks are ended, then our active input was lost\n  const activeInputWasLost = this.stream.getAudioTracks().every(track => track.readyState === 'ended');\n\n  // We only want to act if we manage the stream in PeerConnection (It was created\n  // here, rather than passed in.)\n  if (activeInputWasLost && this._shouldManageStream) {\n    this.openDefaultDeviceWithConstraints({ audio: true });\n  }\n};\n\nPeerConnection.prototype._onIceGatheringFailure = function(type) {\n  this._hasIceGatheringFailures = true;\n  this.onicegatheringfailure(type);\n};\n\nPeerConnection.prototype._onMediaConnectionStateChange = function(newState) {\n  const previousState = this._iceState;\n\n  if (previousState === newState\n    || (newState !== 'connected'\n    && newState !== 'disconnected'\n    && newState !== 'failed')) {\n    return;\n  }\n  this._iceState = newState;\n\n  let message;\n  switch (newState) {\n    case 'connected':\n      if (previousState === 'disconnected' || previousState === 'failed') {\n        message = 'ICE liveliness check succeeded. Connection with Twilio restored';\n        this._log.info(message);\n        this.onreconnected(message);\n      } else {\n        message = 'Media connection established.';\n        this._log.info(message);\n        this.onconnected(message);\n      }\n      this._stopIceGatheringTimeout();\n      this._hasIceGatheringFailures = false;\n      break;\n    case 'disconnected':\n      message = 'ICE liveliness check failed. May be having trouble connecting to Twilio';\n      this._log.warn(message);\n      this.ondisconnected(message);\n      break;\n    case 'failed':\n      message = 'Connection with Twilio was interrupted.';\n      this._log.warn(message);\n      this.onfailed(message);\n      break;\n  }\n};\n\nPeerConnection.prototype._setSinkIds = function(sinkIds) {\n  if (!this._isSinkSupported) {\n    return Promise.reject(new NotSupportedError('Audio output selection is not supported by this browser'));\n  }\n\n  this.sinkIds = new Set(sinkIds.forEach ? sinkIds : [sinkIds]);\n  return this.version\n    ? this._updateAudioOutputs()\n    : Promise.resolve();\n};\n\n/**\n * Start timeout for ICE Gathering\n */\nPeerConnection.prototype._startIceGatheringTimeout = function startIceGatheringTimeout() {\n  this._stopIceGatheringTimeout();\n  this._iceGatheringTimeoutId = setTimeout(() => {\n    this._onIceGatheringFailure(ICE_GATHERING_FAIL_TIMEOUT);\n  }, ICE_GATHERING_TIMEOUT);\n};\n\n/**\n * Stop timeout for ICE Gathering\n */\nPeerConnection.prototype._stopIceGatheringTimeout = function stopIceGatheringTimeout() {\n  clearInterval(this._iceGatheringTimeoutId);\n};\n\nPeerConnection.prototype._updateAudioOutputs = function updateAudioOutputs() {\n  const addedOutputIds = Array.from(this.sinkIds).filter(function(id) {\n    return !this.outputs.has(id);\n  }, this);\n\n  const removedOutputIds = Array.from(this.outputs.keys()).filter(function(id) {\n    return !this.sinkIds.has(id);\n  }, this);\n\n  const self = this;\n  const createOutputPromises = addedOutputIds.map(this._createAudioOutput, this);\n  return Promise.all(createOutputPromises).then(() => Promise.all(removedOutputIds.map(self._removeAudioOutput, self)));\n};\n\nPeerConnection.prototype._createAudio = function createAudio(arr) {\n  const audio = new Audio(arr);\n  this.onaudio(audio);\n  return audio;\n};\n\nPeerConnection.prototype._createAudioOutput = function createAudioOutput(id) {\n  let dest = null;\n  if (this._mediaStreamSource) {\n    dest = this._audioContext.createMediaStreamDestination();\n    this._mediaStreamSource.connect(dest);\n  }\n\n  const audio = this._createAudio();\n  setAudioSource(audio, dest && dest.stream ? dest.stream : this.pcStream);\n\n  const self = this;\n  return audio.setSinkId(id).then(() => audio.play()).then(() => {\n    self.outputs.set(id, {\n      audio,\n      dest,\n    });\n  });\n};\n\nPeerConnection.prototype._removeAudioOutputs = function removeAudioOutputs() {\n  if (this._masterAudio && typeof this._masterAudioDeviceId !== 'undefined') {\n    this._disableOutput(this, this._masterAudioDeviceId);\n    this.outputs.delete(this._masterAudioDeviceId);\n    this._masterAudioDeviceId = null;\n\n    // Release the audio resources before deleting the audio\n    if (!this._masterAudio.paused) {\n      this._masterAudio.pause();\n    }\n    if (typeof this._masterAudio.srcObject !== 'undefined') {\n      this._masterAudio.srcObject = null;\n    } else {\n      this._masterAudio.src = '';\n    }\n    this._masterAudio = null;\n  }\n\n  return Array.from(this.outputs.keys()).map(this._removeAudioOutput, this);\n};\n\nPeerConnection.prototype._disableOutput = function disableOutput(pc, id) {\n  const output = pc.outputs.get(id);\n  if (!output) { return; }\n\n  if (output.audio) {\n    output.audio.pause();\n    output.audio.src = '';\n  }\n\n  if (output.dest) {\n    output.dest.disconnect();\n  }\n};\n\n/**\n * Disable a non-master output, and update the master output to assume its state. This\n *   is called when the device ID assigned to the master output has been removed from\n *   active devices. We can not simply remove the master audio output, so we must\n *   instead reassign it.\n * @private\n * @param {PeerConnection} pc\n * @param {string} masterId - The current device ID assigned to the master audio element.\n */\nPeerConnection.prototype._reassignMasterOutput = function reassignMasterOutput(pc, masterId) {\n  const masterOutput = pc.outputs.get(masterId);\n  pc.outputs.delete(masterId);\n\n  const self = this;\n  const activeDeviceId = Array.from(pc.outputs.keys())[0];\n  // The audio device key could also be '' on Chrome if no media device permissions are allowed\n  const idToReplace = typeof activeDeviceId === 'string' ? activeDeviceId : 'default';\n\n  return masterOutput.audio.setSinkId(idToReplace).then(() => {\n    self._disableOutput(pc, idToReplace);\n\n    pc.outputs.set(idToReplace, masterOutput);\n    pc._masterAudioDeviceId = idToReplace;\n  }).catch(function rollback() {\n    pc.outputs.set(masterId, masterOutput);\n    self._log.info('Could not reassign master output. Attempted to roll back.');\n  });\n};\n\nPeerConnection.prototype._removeAudioOutput = function removeAudioOutput(id) {\n  if (this._masterAudioDeviceId === id) {\n    return this._reassignMasterOutput(this, id);\n  }\n\n  this._disableOutput(this, id);\n  this.outputs.delete(id);\n\n  return Promise.resolve();\n};\n\n/**\n * Use an AudioContext to potentially split our audio output stream to multiple\n *   audio devices. This is only available to browsers with AudioContext and\n *   HTMLAudioElement.setSinkId() available. We save the source stream in\n *   _masterAudio, and use it for one of the active audio devices. We keep\n *   track of its ID because we must replace it if we lose its initial device.\n */\nPeerConnection.prototype._onAddTrack = function onAddTrack(pc, stream) {\n  const audio = pc._masterAudio = this._createAudio();\n  setAudioSource(audio, stream);\n  audio.play();\n\n  // Assign the initial master audio element to a random active output device\n  const activeDeviceId = Array.from(pc.outputs.keys())[0];\n  // The audio device key could also be '' on Chrome if no media device permissions are allowed\n  const deviceId = typeof activeDeviceId === 'string' ? activeDeviceId : 'default';\n  pc._masterAudioDeviceId = deviceId;\n  pc.outputs.set(deviceId, { audio });\n\n  try {\n    pc._mediaStreamSource = pc._audioContext.createMediaStreamSource(stream);\n  } catch (ex) {\n    this._log.warn('Unable to create a MediaStreamSource from onAddTrack', ex);\n    this._mediaStreamSource = null;\n  }\n\n  pc.pcStream = stream;\n  pc._updateAudioOutputs();\n};\n\n/**\n * Use a single audio element to play the audio output stream. This does not\n *   support multiple output devices, and is a fallback for when AudioContext\n *   and/or HTMLAudioElement.setSinkId() is not available to the client.\n */\nPeerConnection.prototype._fallbackOnAddTrack = function fallbackOnAddTrack(pc, stream) {\n  const audio = document && document.createElement('audio');\n  audio.autoplay = true;\n\n  if (!setAudioSource(audio, stream)) {\n    pc._log.info('Error attaching stream to element.');\n  }\n\n  pc.outputs.set('default', { audio });\n};\n\nPeerConnection.prototype._setEncodingParameters = function(enableDscp) {\n  if (!enableDscp\n      || !this._sender\n      || typeof this._sender.getParameters !== 'function'\n      || typeof this._sender.setParameters !== 'function') {\n    return;\n  }\n\n  const params = this._sender.getParameters();\n  if (!params.priority && !(params.encodings && params.encodings.length)) {\n    return;\n  }\n\n  // This is how MDN's RTPSenderParameters defines priority\n  params.priority = 'high';\n\n  // And this is how it's currently implemented in Chrome M72+\n  if (params.encodings && params.encodings.length) {\n    params.encodings.forEach(encoding => {\n      encoding.priority = 'high';\n      encoding.networkPriority = 'high';\n    });\n  }\n\n  this._sender.setParameters(params);\n};\n\nPeerConnection.prototype._setupPeerConnection = function(rtcConfiguration) {\n  const self = this;\n  const version = new (this.options.rtcpcFactory || RTCPC)({ RTCPeerConnection: this.options.RTCPeerConnection });\n  version.create(rtcConfiguration);\n  addStream(version.pc, this.stream);\n\n  const eventName = 'ontrack' in version.pc\n    ? 'ontrack' : 'onaddstream';\n\n  version.pc[eventName] = event => {\n    const stream = self._remoteStream = event.stream || event.streams[0];\n\n    if (typeof version.pc.getSenders === 'function') {\n      this._sender = version.pc.getSenders()[0];\n    }\n\n    if (self._isSinkSupported) {\n      self._onAddTrack(self, stream);\n    } else {\n      self._fallbackOnAddTrack(self, stream);\n    }\n\n    self._startPollingVolume();\n  };\n  return version;\n};\n\nPeerConnection.prototype._maybeSetIceAggressiveNomination = function(sdp) {\n  return this.options.forceAggressiveIceNomination ? setIceAggressiveNomination(sdp) : sdp;\n};\n\nPeerConnection.prototype._setupChannel = function() {\n  const pc = this.version.pc;\n\n  // Chrome 25 supports onopen\n  this.version.pc.onopen = () => {\n    this.status = 'open';\n    this.onopen();\n  };\n\n  // Chrome 26 doesn't support onopen so must detect state change\n  this.version.pc.onstatechange = () => {\n    if (this.version.pc && this.version.pc.readyState === 'stable') {\n      this.status = 'open';\n      this.onopen();\n    }\n  };\n\n  // Chrome 27 changed onstatechange to onsignalingstatechange\n  this.version.pc.onsignalingstatechange = () => {\n    const state = pc.signalingState;\n    this._log.info(`signalingState is \"${state}\"`);\n\n    if (this.version.pc && this.version.pc.signalingState === 'stable') {\n      this.status = 'open';\n      this.onopen();\n    }\n\n    this.onsignalingstatechange(pc.signalingState);\n  };\n\n  // Chrome 72+\n  pc.onconnectionstatechange = event => {\n    let state = pc.connectionState;\n    if (!state && event && event.target) {\n      // VDI environment\n      const targetPc = event.target;\n      state = targetPc.connectionState || targetPc.connectionState_;\n      this._log.info(`pc.connectionState not detected. Using target PC. State=${state}`);\n    }\n    if (!state) {\n      this._log.warn(`onconnectionstatechange detected but state is \"${state}\"`);\n    } else {\n      this._log.info(`pc.connectionState is \"${state}\"`);\n    }\n    this.onpcconnectionstatechange(state);\n    this._onMediaConnectionStateChange(state);\n  };\n\n  pc.onicecandidate =  event => {\n    const { candidate } = event;\n    if (candidate) {\n      this._hasIceCandidates = true;\n      this.onicecandidate(candidate);\n      this._setupRTCIceTransportListener();\n    }\n\n    this._log.info(`ICE Candidate: ${JSON.stringify(candidate)}`);\n  };\n\n  pc.onicegatheringstatechange = () => {\n    const state = pc.iceGatheringState;\n    if (state === 'gathering') {\n      this._startIceGatheringTimeout();\n\n    } else if (state === 'complete') {\n      this._stopIceGatheringTimeout();\n\n      // Fail if no candidates found\n      if (!this._hasIceCandidates) {\n        this._onIceGatheringFailure(ICE_GATHERING_FAIL_NONE);\n      }\n\n      // There was a failure mid-gathering phase. We want to start our timer and issue\n      // an ice restart if we don't get connected after our timeout\n      if (this._hasIceCandidates && this._hasIceGatheringFailures) {\n        this._startIceGatheringTimeout();\n      }\n    }\n\n    this._log.info(`pc.iceGatheringState is \"${pc.iceGatheringState}\"`);\n    this.onicegatheringstatechange(state);\n  };\n\n  pc.oniceconnectionstatechange = () => {\n    this._log.info(`pc.iceConnectionState is \"${pc.iceConnectionState}\"`);\n    this.oniceconnectionstatechange(pc.iceConnectionState);\n    this._onMediaConnectionStateChange(pc.iceConnectionState);\n  };\n};\nPeerConnection.prototype._initializeMediaStream = function(rtcConfiguration) {\n  // if mediastream already open then do nothing\n  if (this.status === 'open') {\n    return false;\n  }\n  if (this.pstream.status === 'disconnected') {\n    this.onerror({ info: {\n      code: 31000,\n      message: 'Cannot establish connection. Client is disconnected',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    } });\n    this.close();\n    return false;\n  }\n  this.version = this._setupPeerConnection(rtcConfiguration);\n  this._setupChannel();\n  return true;\n};\n\n/**\n * Remove reconnection-related listeners\n * @private\n */\nPeerConnection.prototype._removeReconnectionListeners = function() {\n  if (this.pstream) {\n    this.pstream.removeListener('answer', this._onAnswerOrRinging);\n    this.pstream.removeListener('hangup', this._onHangup);\n  }\n};\n\n/**\n * Setup a listener for RTCDtlsTransport to capture state changes events\n * @private\n */\nPeerConnection.prototype._setupRTCDtlsTransportListener = function() {\n  const dtlsTransport = this.getRTCDtlsTransport();\n\n  if (!dtlsTransport || dtlsTransport.onstatechange) {\n    return;\n  }\n\n  const handler = () => {\n    this._log.info(`dtlsTransportState is \"${dtlsTransport.state}\"`);\n    this.ondtlstransportstatechange(dtlsTransport.state);\n  };\n\n  // Publish initial state\n  handler();\n  dtlsTransport.onstatechange = handler;\n};\n\n/**\n * Setup a listener for RTCIceTransport to capture selected candidate pair changes\n * @private\n */\nPeerConnection.prototype._setupRTCIceTransportListener = function() {\n  const iceTransport = this._getRTCIceTransport();\n\n  if (!iceTransport || iceTransport.onselectedcandidatepairchange) {\n    return;\n  }\n\n  iceTransport.onselectedcandidatepairchange = () =>\n    this.onselectedcandidatepairchange(iceTransport.getSelectedCandidatePair());\n};\n\n/**\n * Restarts ICE for the current connection\n * ICE Restart failures are ignored. Retries are managed in Connection\n * @private\n */\nPeerConnection.prototype.iceRestart = function() {\n  this._log.info('Attempting to restart ICE...');\n  this._hasIceCandidates = false;\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, { iceRestart: true }).then(() => {\n    this._removeReconnectionListeners();\n\n    this._onAnswerOrRinging = payload => {\n      this._removeReconnectionListeners();\n\n      if (!payload.sdp || this.version.pc.signalingState !== 'have-local-offer') {\n        const message = 'Invalid state or param during ICE Restart:'\n          + `hasSdp:${!!payload.sdp}, signalingState:${this.version.pc.signalingState}`;\n        this._log.warn(message);\n        return;\n      }\n\n      const sdp = this._maybeSetIceAggressiveNomination(payload.sdp);\n      this._answerSdp = sdp;\n      if (this.status !== 'closed') {\n        this.version.processAnswer(this.codecPreferences, sdp, null, err => {\n          const message = err && err.message ? err.message : err;\n          this._log.error(`Failed to process answer during ICE Restart. Error: ${message}`);\n        });\n      }\n    };\n\n    this._onHangup = () => {\n      this._log.info('Received hangup during ICE Restart');\n      this._removeReconnectionListeners();\n    };\n\n    this.pstream.on('answer', this._onAnswerOrRinging);\n    this.pstream.on('hangup', this._onHangup);\n    this.pstream.reinvite(this.version.getSDP(), this.callSid);\n\n  }).catch((err) => {\n    const message = err && err.message ? err.message : err;\n    this._log.error(`Failed to createOffer during ICE Restart. Error: ${message}`);\n    // CreateOffer failures doesn't transition ice state to failed\n    // We need trigger it so it can be picked up by retries\n    this.onfailed(message);\n  });\n};\n\nPeerConnection.prototype.makeOutgoingCall = function(params, signalingReconnectToken, callsid, rtcConfiguration, onMediaStarted) {\n  if (!this._initializeMediaStream(rtcConfiguration)) {\n    return;\n  }\n\n  const self = this;\n  this.callSid = callsid;\n  function onAnswerSuccess() {\n    if (self.options) {\n      self._setEncodingParameters(self.options.dscp);\n    }\n    onMediaStarted(self.version.pc);\n  }\n  function onAnswerError(err) {\n    const errMsg = err.message || err;\n    self.onerror({ info: {\n      code: 31000,\n      message: `Error processing answer: ${errMsg}`,\n      twilioError: new MediaErrors.ClientRemoteDescFailed(),\n    } });\n  }\n  this._onAnswerOrRinging = payload => {\n    if (!payload.sdp) { return; }\n\n    const sdp = this._maybeSetIceAggressiveNomination(payload.sdp);\n    self._answerSdp = sdp;\n    if (self.status !== 'closed') {\n      self.version.processAnswer(this.codecPreferences, sdp, onAnswerSuccess, onAnswerError);\n    }\n    self.pstream.removeListener('answer', self._onAnswerOrRinging);\n    self.pstream.removeListener('ringing', self._onAnswerOrRinging);\n  };\n  this.pstream.on('answer', this._onAnswerOrRinging);\n  this.pstream.on('ringing', this._onAnswerOrRinging);\n\n  function onOfferSuccess() {\n    if (self.status !== 'closed') {\n      if (signalingReconnectToken) {\n        self.pstream.reconnect(self.version.getSDP(), self.callSid, signalingReconnectToken);\n      } else {\n        self.pstream.invite(self.version.getSDP(), self.callSid, params);\n      }\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n\n  function onOfferError(err) {\n    const errMsg = err.message || err;\n    self.onerror({ info: {\n      code: 31000,\n      message: `Error creating the offer: ${errMsg}`,\n      twilioError: new MediaErrors.ClientLocalDescFailed(),\n    } });\n  }\n\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, { audio: true }, onOfferSuccess, onOfferError);\n};\nPeerConnection.prototype.answerIncomingCall = function(callSid, sdp, rtcConfiguration, onMediaStarted) {\n  if (!this._initializeMediaStream(rtcConfiguration)) {\n    return;\n  }\n  sdp = this._maybeSetIceAggressiveNomination(sdp);\n  this._answerSdp = sdp.replace(/^a=setup:actpass$/gm, 'a=setup:passive');\n  this.callSid = callSid;\n  const self = this;\n  function onAnswerSuccess() {\n    if (self.status !== 'closed') {\n      self.pstream.answer(self.version.getSDP(), callSid);\n      if (self.options) {\n        self._setEncodingParameters(self.options.dscp);\n      }\n      onMediaStarted(self.version.pc);\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n  function onAnswerError(err) {\n    const errMsg = err.message || err;\n    self.onerror({ info: {\n      code: 31000,\n      message: `Error creating the answer: ${errMsg}`,\n      twilioError: new MediaErrors.ClientRemoteDescFailed(),\n    } });\n  }\n  this.version.processSDP(this.options.maxAverageBitrate, this.codecPreferences, sdp, { audio: true }, onAnswerSuccess, onAnswerError);\n};\nPeerConnection.prototype.close = function() {\n  if (this.version && this.version.pc) {\n    if (this.version.pc.signalingState !== 'closed') {\n      this.version.pc.close();\n    }\n\n    this.version.pc = null;\n  }\n  if (this.stream) {\n    this.mute(false);\n    this._stopStream();\n  }\n  this.stream = null;\n  this._removeReconnectionListeners();\n  this._stopIceGatheringTimeout();\n\n  Promise.all(this._removeAudioOutputs()).catch(() => {\n    // We don't need to alert about failures here.\n  });\n  if (this._mediaStreamSource) {\n    this._mediaStreamSource.disconnect();\n  }\n  if (this._inputAnalyser) {\n    this._inputAnalyser.disconnect();\n  }\n  if (this._outputAnalyser) {\n    this._outputAnalyser.disconnect();\n  }\n  if (this._inputAnalyser2) {\n    this._inputAnalyser2.disconnect();\n  }\n  if (this._outputAnalyser2) {\n    this._outputAnalyser2.disconnect();\n  }\n  this.status = 'closed';\n  this.onclose();\n};\nPeerConnection.prototype.reject = function(callSid) {\n  this.callSid = callSid;\n};\nPeerConnection.prototype.ignore = function(callSid) {\n  this.callSid = callSid;\n};\n/**\n * Mute or unmute input audio. If the stream is not yet present, the setting\n *   is saved and applied to future streams/tracks.\n * @params {boolean} shouldMute - Whether the input audio should\n *   be muted or unmuted.\n */\nPeerConnection.prototype.mute = function(shouldMute) {\n  this.isMuted = shouldMute;\n  if (!this.stream) { return; }\n\n  if (this._sender && this._sender.track) {\n    this._sender.track.enabled = !shouldMute;\n  } else {\n    const audioTracks = typeof this.stream.getAudioTracks === 'function'\n      ? this.stream.getAudioTracks()\n      : this.stream.audioTracks;\n\n    audioTracks.forEach(track => {\n      track.enabled = !shouldMute;\n    });\n  }\n};\n/**\n * Get or create an RTCDTMFSender for the first local audio MediaStreamTrack\n * we can get from the RTCPeerConnection. Return null if unsupported.\n * @instance\n * @returns ?RTCDTMFSender\n */\nPeerConnection.prototype.getOrCreateDTMFSender = function getOrCreateDTMFSender() {\n  if (this._dtmfSender || this._dtmfSenderUnsupported) {\n    return this._dtmfSender || null;\n  }\n\n  const self = this;\n  const pc = this.version.pc;\n  if (!pc) {\n    this._log.warn('No RTCPeerConnection available to call createDTMFSender on');\n    return null;\n  }\n\n  if (typeof pc.getSenders === 'function' && (typeof RTCDTMFSender === 'function' || typeof RTCDtmfSender === 'function')) {\n    const chosenSender = pc.getSenders().find(sender => sender.dtmf);\n    if (chosenSender) {\n      this._log.info('Using RTCRtpSender#dtmf');\n      this._dtmfSender = chosenSender.dtmf;\n      return this._dtmfSender;\n    }\n  }\n\n  if (typeof pc.createDTMFSender === 'function' && typeof pc.getLocalStreams === 'function') {\n    const track = pc.getLocalStreams().map(stream => {\n      const tracks = self._getAudioTracks(stream);\n      return tracks && tracks[0];\n    })[0];\n\n    if (!track) {\n      this._log.warn('No local audio MediaStreamTrack available on the RTCPeerConnection to pass to createDTMFSender');\n      return null;\n    }\n\n    this._log.info('Creating RTCDTMFSender');\n    this._dtmfSender = pc.createDTMFSender(track);\n    return this._dtmfSender;\n  }\n\n  this._log.info('RTCPeerConnection does not support RTCDTMFSender');\n  this._dtmfSenderUnsupported = true;\n  return null;\n};\n\n/**\n * Get the RTCDtlTransport object from the PeerConnection\n * @returns RTCDtlTransport\n */\nPeerConnection.prototype.getRTCDtlsTransport = function getRTCDtlsTransport() {\n  const sender = this.version && this.version.pc\n    && typeof this.version.pc.getSenders === 'function'\n    && this.version.pc.getSenders()[0];\n  return sender && sender.transport || null;\n};\n\nPeerConnection.prototype._canStopMediaStreamTrack = () => typeof MediaStreamTrack.prototype.stop === 'function';\n\nPeerConnection.prototype._getAudioTracks = stream => typeof stream.getAudioTracks === 'function' ?\n  stream.getAudioTracks() : stream.audioTracks;\n\n/**\n * Get the RTCIceTransport object from the PeerConnection\n * @returns RTCIceTransport\n */\nPeerConnection.prototype._getRTCIceTransport = function _getRTCIceTransport() {\n  const dtlsTransport = this.getRTCDtlsTransport();\n  return dtlsTransport && dtlsTransport.iceTransport || null;\n};\n\n// Is PeerConnection.protocol used outside of our SDK? We should remove this if not.\nPeerConnection.protocol = ((() => RTCPC.test() ? new RTCPC() : null))();\n\nfunction addStream(pc, stream) {\n  if (typeof pc.addTrack === 'function') {\n    stream.getAudioTracks().forEach(track => {\n      // The second parameters, stream, should not be necessary per the latest editor's\n      //   draft, but FF requires it. https://bugzilla.mozilla.org/show_bug.cgi?id=1231414\n      pc.addTrack(track, stream);\n    });\n  } else {\n    pc.addStream(stream);\n  }\n}\n\nfunction cloneStream(oldStream) {\n  const newStream = typeof MediaStream !== 'undefined'\n    ? new MediaStream()\n    : new webkitMediaStream();\n\n  oldStream.getAudioTracks().forEach(newStream.addTrack, newStream);\n  return newStream;\n}\n\nfunction removeStream(pc, stream) {\n  if (typeof pc.removeTrack === 'function') {\n    pc.getSenders().forEach(sender => { pc.removeTrack(sender); });\n  } else {\n    pc.removeStream(stream);\n  }\n}\n\n/**\n * Set the source of an HTMLAudioElement to the specified MediaStream\n * @param {HTMLAudioElement} audio\n * @param {MediaStream} stream\n * @returns {boolean} Whether the audio source was set successfully\n */\nfunction setAudioSource(audio, stream) {\n  if (typeof audio.srcObject !== 'undefined') {\n    audio.srcObject = stream;\n  } else if (typeof audio.mozSrcObject !== 'undefined') {\n    audio.mozSrcObject = stream;\n  } else if (typeof audio.src !== 'undefined') {\n    const _window = audio.options.window || window;\n    audio.src = (_window.URL || _window.webkitURL).createObjectURL(stream);\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\nPeerConnection.enabled = RTCPC.test();\n\nexport default PeerConnection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}