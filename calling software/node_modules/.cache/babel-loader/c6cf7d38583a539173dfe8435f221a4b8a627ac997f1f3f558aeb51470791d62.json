{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nvar events_1 = require(\"events\");\nvar loglevel_1 = require(\"loglevel\");\nvar audiohelper_1 = require(\"./audiohelper\");\nvar audioprocessoreventobserver_1 = require(\"./audioprocessoreventobserver\");\nvar call_1 = require(\"./call\");\nvar C = require(\"./constants\");\nvar dialtonePlayer_1 = require(\"./dialtonePlayer\");\nvar errors_1 = require(\"./errors\");\nvar eventpublisher_1 = require(\"./eventpublisher\");\nvar log_1 = require(\"./log\");\nvar preflight_1 = require(\"./preflight/preflight\");\nvar pstream_1 = require(\"./pstream\");\nvar regions_1 = require(\"./regions\");\nvar rtc = require(\"./rtc\");\nvar getusermedia_1 = require(\"./rtc/getusermedia\");\nvar sound_1 = require(\"./sound\");\nvar util_1 = require(\"./util\");\nvar uuid_1 = require(\"./uuid\");\nvar REGISTRATION_INTERVAL = 30000;\nvar RINGTONE_PLAY_TIMEOUT = 2000;\nvar PUBLISHER_PRODUCT_NAME = 'twilio-js-sdk';\nvar INVALID_TOKEN_MESSAGE = 'Parameter \"token\" must be of type \"string\".';\n/**\n * Twilio Device. Allows registration for incoming calls, and placing outgoing calls.\n * @publicapi\n */\nvar Device = /** @class */function (_super) {\n  __extends(Device, _super);\n  /**\n   * Construct a {@link Device} instance. The {@link Device} can be registered\n   * to make and listen for calls using {@link Device.register}.\n   * @constructor\n   * @param options\n   */\n  function Device(token, options) {\n    var _a;\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * The currently active {@link Call}, if there is one.\n     */\n    _this._activeCall = null;\n    /**\n     * The AudioHelper instance associated with this {@link Device}.\n     */\n    _this._audio = null;\n    /**\n     * The AudioProcessorEventObserver instance to use\n     */\n    _this._audioProcessorEventObserver = null;\n    /**\n     * An audio input MediaStream to pass to new {@link Call} instances.\n     */\n    _this._callInputStream = null;\n    /**\n     * An array of {@link Call}s. Though only one can be active, multiple may exist when there\n     * are multiple incoming, unanswered {@link Call}s.\n     */\n    _this._calls = [];\n    /**\n     * An array of {@link Device} IDs to be used to play sounds through, to be passed to\n     * new {@link Call} instances.\n     */\n    _this._callSinkIds = ['default'];\n    /**\n     * The list of chunder URIs that will be passed to PStream\n     */\n    _this._chunderURIs = [];\n    /**\n     * Default options used by {@link Device}.\n     */\n    _this._defaultOptions = {\n      allowIncomingWhileBusy: false,\n      closeProtection: false,\n      codecPreferences: [call_1.default.Codec.PCMU, call_1.default.Codec.Opus],\n      dscp: true,\n      enableImprovedSignalingErrorPrecision: false,\n      forceAggressiveIceNomination: false,\n      logLevel: loglevel_1.levels.ERROR,\n      maxCallSignalingTimeoutMs: 0,\n      preflight: false,\n      sounds: {},\n      tokenRefreshMs: 10000,\n      voiceEventSidGenerator: uuid_1.generateVoiceEventSid\n    };\n    /**\n     * The name of the edge the {@link Device} is connected to.\n     */\n    _this._edge = null;\n    /**\n     * The name of the home region the {@link Device} is connected to.\n     */\n    _this._home = null;\n    /**\n     * The identity associated with this Device.\n     */\n    _this._identity = null;\n    /**\n     * An instance of Logger to use.\n     */\n    _this._log = new log_1.default('Device');\n    /**\n     * The internal promise created when calling {@link Device.makeCall}.\n     */\n    _this._makeCallPromise = null;\n    /**\n     * The options passed to {@link Device} constructor or {@link Device.updateOptions}.\n     */\n    _this._options = {};\n    /**\n     * The preferred URI to (re)-connect signaling to.\n     */\n    _this._preferredURI = null;\n    /**\n     * An Insights Event Publisher.\n     */\n    _this._publisher = null;\n    /**\n     * The region the {@link Device} is connected to.\n     */\n    _this._region = null;\n    /**\n     * A timeout ID for a setTimeout schedule to re-register the {@link Device}.\n     */\n    _this._regTimer = null;\n    /**\n     * Boolean representing whether or not the {@link Device} was registered when\n     * receiving a signaling `offline`. Determines if the {@link Device} attempts\n     * a `re-register` once signaling is re-established when receiving a\n     * `connected` event from the stream.\n     */\n    _this._shouldReRegister = false;\n    /**\n     * A Map of Sounds to play.\n     */\n    _this._soundcache = new Map();\n    /**\n     * The current status of the {@link Device}.\n     */\n    _this._state = Device.State.Unregistered;\n    /**\n     * A map from {@link Device.State} to {@link Device.EventName}.\n     */\n    _this._stateEventMapping = (_a = {}, _a[Device.State.Destroyed] = Device.EventName.Destroyed, _a[Device.State.Unregistered] = Device.EventName.Unregistered, _a[Device.State.Registering] = Device.EventName.Registering, _a[Device.State.Registered] = Device.EventName.Registered, _a);\n    /**\n     * The Signaling stream.\n     */\n    _this._stream = null;\n    /**\n     * A promise that will resolve when the Signaling stream is ready.\n     */\n    _this._streamConnectedPromise = null;\n    /**\n     * A timeout to track when the current AccessToken will expire.\n     */\n    _this._tokenWillExpireTimeout = null;\n    /**\n     * Create the default Insights payload\n     * @param call\n     */\n    _this._createDefaultPayload = function (call) {\n      var payload = {\n        aggressive_nomination: _this._options.forceAggressiveIceNomination,\n        browser_extension: _this._isBrowserExtension,\n        dscp: !!_this._options.dscp,\n        ice_restart_enabled: true,\n        platform: rtc.getMediaEngine(),\n        sdk_version: C.RELEASE_VERSION\n      };\n      function setIfDefined(propertyName, value) {\n        if (value) {\n          payload[propertyName] = value;\n        }\n      }\n      if (call) {\n        var callSid = call.parameters.CallSid;\n        setIfDefined('call_sid', /^TJ/.test(callSid) ? undefined : callSid);\n        setIfDefined('temp_call_sid', call.outboundConnectionId);\n        setIfDefined('audio_codec', call.codec);\n        payload.direction = call.direction;\n      }\n      setIfDefined('gateway', _this._stream && _this._stream.gateway);\n      setIfDefined('region', _this._stream && _this._stream.region);\n      return payload;\n    };\n    /**\n     * Called when a 'close' event is received from the signaling stream.\n     */\n    _this._onSignalingClose = function () {\n      _this._stream = null;\n      _this._streamConnectedPromise = null;\n    };\n    /**\n     * Called when a 'connected' event is received from the signaling stream.\n     */\n    _this._onSignalingConnected = function (payload) {\n      var _a;\n      var region = regions_1.getRegionShortcode(payload.region);\n      _this._edge = payload.edge || regions_1.regionToEdge[region] || payload.region;\n      _this._region = region || payload.region;\n      _this._home = payload.home;\n      (_a = _this._publisher) === null || _a === void 0 ? void 0 : _a.setHost(regions_1.createEventGatewayURI(payload.home));\n      if (payload.token) {\n        _this._identity = payload.token.identity;\n        if (typeof payload.token.ttl === 'number' && typeof _this._options.tokenRefreshMs === 'number') {\n          var ttlMs = payload.token.ttl * 1000;\n          var timeoutMs = Math.max(0, ttlMs - _this._options.tokenRefreshMs);\n          _this._tokenWillExpireTimeout = setTimeout(function () {\n            _this._log.debug('#tokenWillExpire');\n            _this.emit('tokenWillExpire', _this);\n            if (_this._tokenWillExpireTimeout) {\n              clearTimeout(_this._tokenWillExpireTimeout);\n              _this._tokenWillExpireTimeout = null;\n            }\n          }, timeoutMs);\n        }\n      }\n      var preferredURIs = regions_1.getChunderURIs(_this._edge);\n      if (preferredURIs.length > 0) {\n        var preferredURI = preferredURIs[0];\n        _this._preferredURI = regions_1.createSignalingEndpointURL(preferredURI);\n      } else {\n        _this._log.warn('Could not parse a preferred URI from the stream#connected event.');\n      }\n      // The signaling stream emits a `connected` event after reconnection, if the\n      // device was registered before this, then register again.\n      if (_this._shouldReRegister) {\n        _this.register();\n      }\n    };\n    /**\n     * Called when an 'error' event is received from the signaling stream.\n     */\n    _this._onSignalingError = function (payload) {\n      if (typeof payload !== 'object') {\n        _this._log.warn('Invalid signaling error payload', payload);\n        return;\n      }\n      var originalError = payload.error,\n        callsid = payload.callsid,\n        voiceeventsid = payload.voiceeventsid;\n      // voiceeventsid is for call message events which are handled in the call object\n      // missing originalError shouldn't be possible but check here to fail properly\n      if (typeof originalError !== 'object' || !!voiceeventsid) {\n        _this._log.warn('Ignoring signaling error payload', {\n          originalError: originalError,\n          voiceeventsid: voiceeventsid\n        });\n        return;\n      }\n      var call = typeof callsid === 'string' && _this._findCall(callsid) || undefined;\n      var code = originalError.code,\n        customMessage = originalError.message;\n      var twilioError = originalError.twilioError;\n      if (typeof code === 'number') {\n        if (code === 31201) {\n          twilioError = new errors_1.AuthorizationErrors.AuthenticationFailed(originalError);\n        } else if (code === 31204) {\n          twilioError = new errors_1.AuthorizationErrors.AccessTokenInvalid(originalError);\n        } else if (code === 31205) {\n          // Stop trying to register presence after token expires\n          _this._stopRegistrationTimer();\n          twilioError = new errors_1.AuthorizationErrors.AccessTokenExpired(originalError);\n        } else {\n          var errorConstructor = errors_1.getPreciseSignalingErrorByCode(!!_this._options.enableImprovedSignalingErrorPrecision, code);\n          if (typeof errorConstructor !== 'undefined') {\n            twilioError = new errorConstructor(originalError);\n          }\n        }\n      }\n      if (!twilioError) {\n        _this._log.error('Unknown signaling error: ', originalError);\n        twilioError = new errors_1.GeneralErrors.UnknownError(customMessage, originalError);\n      }\n      _this._log.error('Received error: ', twilioError);\n      _this._log.debug('#error', originalError);\n      _this.emit(Device.EventName.Error, twilioError, call);\n    };\n    /**\n     * Called when an 'invite' event is received from the signaling stream.\n     */\n    _this._onSignalingInvite = function (payload) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var wasBusy, callParameters, customParameters, call, play;\n        var _this = this;\n        var _a;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              wasBusy = !!this._activeCall;\n              if (wasBusy && !this._options.allowIncomingWhileBusy) {\n                this._log.info('Device busy; ignoring incoming invite');\n                return [2 /*return*/];\n              }\n              if (!payload.callsid || !payload.sdp) {\n                this._log.debug('#error', payload);\n                this.emit(Device.EventName.Error, new errors_1.ClientErrors.BadRequest('Malformed invite from gateway'));\n                return [2 /*return*/];\n              }\n              callParameters = payload.parameters || {};\n              callParameters.CallSid = callParameters.CallSid || payload.callsid;\n              customParameters = Object.assign({}, util_1.queryToJson(callParameters.Params));\n              this._makeCallPromise = this._makeCall(customParameters, {\n                callParameters: callParameters,\n                enableImprovedSignalingErrorPrecision: !!this._options.enableImprovedSignalingErrorPrecision,\n                offerSdp: payload.sdp,\n                reconnectToken: payload.reconnect,\n                voiceEventSidGenerator: this._options.voiceEventSidGenerator\n              });\n              _b.label = 1;\n            case 1:\n              _b.trys.push([1,, 3, 4]);\n              return [4 /*yield*/, this._makeCallPromise];\n            case 2:\n              call = _b.sent();\n              return [3 /*break*/, 4];\n            case 3:\n              this._makeCallPromise = null;\n              return [7 /*endfinally*/];\n            case 4:\n              this._calls.push(call);\n              call.once('accept', function () {\n                _this._soundcache.get(Device.SoundName.Incoming).stop();\n                _this._publishNetworkChange();\n              });\n              play = ((_a = this._audio) === null || _a === void 0 ? void 0 : _a.incoming()) && !wasBusy ? function () {\n                return _this._soundcache.get(Device.SoundName.Incoming).play();\n              } : function () {\n                return Promise.resolve();\n              };\n              this._showIncomingCall(call, play);\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n    /**\n     * Called when an 'offline' event is received from the signaling stream.\n     */\n    _this._onSignalingOffline = function () {\n      _this._log.info('Stream is offline');\n      _this._edge = null;\n      _this._region = null;\n      _this._shouldReRegister = _this.state !== Device.State.Unregistered;\n      _this._setState(Device.State.Unregistered);\n    };\n    /**\n     * Called when a 'ready' event is received from the signaling stream.\n     */\n    _this._onSignalingReady = function () {\n      _this._log.info('Stream is ready');\n      _this._setState(Device.State.Registered);\n    };\n    /**\n     * Publish a NetworkInformation#change event to Insights if there's an active {@link Call}.\n     */\n    _this._publishNetworkChange = function () {\n      if (!_this._activeCall) {\n        return;\n      }\n      if (_this._networkInformation) {\n        _this._publisher.info('network-information', 'network-change', {\n          connection_type: _this._networkInformation.type,\n          downlink: _this._networkInformation.downlink,\n          downlinkMax: _this._networkInformation.downlinkMax,\n          effective_type: _this._networkInformation.effectiveType,\n          rtt: _this._networkInformation.rtt\n        }, _this._activeCall);\n      }\n    };\n    /**\n     * Update the input stream being used for calls so that any current call and all future calls\n     * will use the new input stream.\n     * @param inputStream\n     */\n    _this._updateInputStream = function (inputStream) {\n      var call = _this._activeCall;\n      if (call && !inputStream) {\n        return Promise.reject(new errors_1.InvalidStateError('Cannot unset input device while a call is in progress.'));\n      }\n      _this._callInputStream = inputStream;\n      return call ? call._setInputTracksFromStream(inputStream) : Promise.resolve();\n    };\n    /**\n     * Update the device IDs of output devices being used to play sounds through.\n     * @param type - Whether to update ringtone or speaker sounds\n     * @param sinkIds - An array of device IDs\n     */\n    _this._updateSinkIds = function (type, sinkIds) {\n      var promise = type === 'ringtone' ? _this._updateRingtoneSinkIds(sinkIds) : _this._updateSpeakerSinkIds(sinkIds);\n      return promise.then(function () {\n        _this._publisher.info('audio', type + \"-devices-set\", {\n          audio_device_ids: sinkIds\n        }, _this._activeCall);\n      }, function (error) {\n        _this._publisher.error('audio', type + \"-devices-set-failed\", {\n          audio_device_ids: sinkIds,\n          message: error.message\n        }, _this._activeCall);\n        throw error;\n      });\n    };\n    // Setup loglevel asap to avoid missed logs\n    _this._setupLoglevel(options.logLevel);\n    _this._logOptions('constructor', options);\n    _this.updateToken(token);\n    if (util_1.isLegacyEdge()) {\n      throw new errors_1.NotSupportedError('Microsoft Edge Legacy (https://support.microsoft.com/en-us/help/4533505/what-is-microsoft-edge-legacy) ' + 'is deprecated and will not be able to connect to Twilio to make or receive calls after September 1st, 2020. ' + 'Please see this documentation for a list of supported browsers ' + 'https://www.twilio.com/docs/voice/client/javascript#supported-browsers');\n    }\n    if (!Device.isSupported && options.ignoreBrowserSupport) {\n      if (window && window.location && window.location.protocol === 'http:') {\n        throw new errors_1.NotSupportedError(\"twilio.js wasn't able to find WebRTC browser support.           This is most likely because this page is served over http rather than https,           which does not support WebRTC in many browsers. Please load this page over https and           try again.\");\n      }\n      throw new errors_1.NotSupportedError(\"twilio.js 1.3+ SDKs require WebRTC browser support.         For more information, see <https://www.twilio.com/docs/api/client/twilio-js>.         If you have any questions about this announcement, please contact         Twilio Support at <help@twilio.com>.\");\n    }\n    var root = globalThis;\n    var browser = root.msBrowser || root.browser || root.chrome;\n    _this._isBrowserExtension = !!browser && !!browser.runtime && !!browser.runtime.id || !!root.safari && !!root.safari.extension;\n    if (_this._isBrowserExtension) {\n      _this._log.info('Running as browser extension.');\n    }\n    if (navigator) {\n      var n = navigator;\n      _this._networkInformation = n.connection || n.mozConnection || n.webkitConnection;\n    }\n    if (_this._networkInformation && typeof _this._networkInformation.addEventListener === 'function') {\n      _this._networkInformation.addEventListener('change', _this._publishNetworkChange);\n    }\n    Device._getOrCreateAudioContext();\n    if (Device._audioContext) {\n      if (!Device._dialtonePlayer) {\n        Device._dialtonePlayer = new dialtonePlayer_1.default(Device._audioContext);\n      }\n    }\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      Device._isUnifiedPlanDefault = typeof window !== 'undefined' && typeof RTCPeerConnection !== 'undefined' && typeof RTCRtpTransceiver !== 'undefined' ? util_1.isUnifiedPlanDefault(window, window.navigator, RTCPeerConnection, RTCRtpTransceiver) : false;\n    }\n    _this._boundDestroy = _this.destroy.bind(_this);\n    _this._boundConfirmClose = _this._confirmClose.bind(_this);\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', _this._boundDestroy);\n      window.addEventListener('pagehide', _this._boundDestroy);\n    }\n    _this.updateOptions(options);\n    return _this;\n  }\n  Object.defineProperty(Device, \"audioContext\", {\n    /**\n     * The AudioContext to be used by {@link Device} instances.\n     * @private\n     */\n    get: function () {\n      return Device._audioContext;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"extension\", {\n    /**\n     * Which sound file extension is supported.\n     * @private\n     */\n    get: function () {\n      // NOTE(mroberts): Node workaround.\n      var a = typeof document !== 'undefined' ? document.createElement('audio') : {\n        canPlayType: false\n      };\n      var canPlayMp3;\n      try {\n        canPlayMp3 = a.canPlayType && !!a.canPlayType('audio/mpeg').replace(/no/, '');\n      } catch (e) {\n        canPlayMp3 = false;\n      }\n      var canPlayVorbis;\n      try {\n        canPlayVorbis = a.canPlayType && !!a.canPlayType('audio/ogg;codecs=\\'vorbis\\'').replace(/no/, '');\n      } catch (e) {\n        canPlayVorbis = false;\n      }\n      return canPlayVorbis && !canPlayMp3 ? 'ogg' : 'mp3';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"isSupported\", {\n    /**\n     * Whether or not this SDK is supported by the current browser.\n     */\n    get: function () {\n      return rtc.enabled();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"packageName\", {\n    /**\n     * Package name of the SDK.\n     */\n    get: function () {\n      return C.PACKAGE_NAME;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Run some tests to identify issues, if any, prohibiting successful calling.\n   * @param token - A Twilio JWT token string\n   * @param options\n   */\n  Device.runPreflight = function (token, options) {\n    return new preflight_1.PreflightTest(token, __assign({\n      audioContext: Device._getOrCreateAudioContext()\n    }, options));\n  };\n  /**\n   * String representation of {@link Device} class.\n   * @private\n   */\n  Device.toString = function () {\n    return '[Twilio.Device class]';\n  };\n  Object.defineProperty(Device, \"version\", {\n    /**\n     * Current SDK version.\n     */\n    get: function () {\n      return C.RELEASE_VERSION;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Initializes the AudioContext instance shared across the Voice SDK,\n   * or returns the existing instance if one has already been initialized.\n   */\n  Device._getOrCreateAudioContext = function () {\n    if (!Device._audioContext) {\n      if (typeof AudioContext !== 'undefined') {\n        Device._audioContext = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Device._audioContext = new webkitAudioContext();\n      }\n    }\n    return Device._audioContext;\n  };\n  Object.defineProperty(Device.prototype, \"audio\", {\n    /**\n     * Return the {@link AudioHelper} used by this {@link Device}.\n     */\n    get: function () {\n      return this._audio;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Make an outgoing Call.\n   * @param options\n   */\n  Device.prototype.connect = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var customParameters, parameters, signalingReconnectToken, connectTokenParts, isReconnect, twimlParams, callOptions, activeCall, _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this._log.debug('.connect', JSON.stringify(options));\n            this._throwIfDestroyed();\n            if (this._activeCall) {\n              throw new errors_1.InvalidStateError('A Call is already active');\n            }\n            if (options.connectToken) {\n              try {\n                connectTokenParts = JSON.parse(decodeURIComponent(atob(options.connectToken)));\n                customParameters = connectTokenParts.customParameters;\n                parameters = connectTokenParts.parameters;\n                signalingReconnectToken = connectTokenParts.signalingReconnectToken;\n              } catch (_c) {\n                throw new errors_1.InvalidArgumentError('Cannot parse connectToken');\n              }\n              if (!parameters || !parameters.CallSid || !signalingReconnectToken) {\n                throw new errors_1.InvalidArgumentError('Invalid connectToken');\n              }\n            }\n            isReconnect = false;\n            twimlParams = {};\n            callOptions = {\n              enableImprovedSignalingErrorPrecision: !!this._options.enableImprovedSignalingErrorPrecision,\n              rtcConfiguration: options.rtcConfiguration,\n              voiceEventSidGenerator: this._options.voiceEventSidGenerator\n            };\n            if (signalingReconnectToken && parameters) {\n              isReconnect = true;\n              callOptions.callParameters = parameters;\n              callOptions.reconnectCallSid = parameters.CallSid;\n              callOptions.reconnectToken = signalingReconnectToken;\n              twimlParams = customParameters || twimlParams;\n            } else {\n              twimlParams = options.params || twimlParams;\n            }\n            this._makeCallPromise = this._makeCall(twimlParams, callOptions, isReconnect);\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1,, 3, 4]);\n            _a = this;\n            return [4 /*yield*/, this._makeCallPromise];\n          case 2:\n            activeCall = _a._activeCall = _b.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            this._makeCallPromise = null;\n            return [7 /*endfinally*/];\n          case 4:\n            // Make sure any incoming calls are ignored\n            this._calls.splice(0).forEach(function (call) {\n              return call.ignore();\n            });\n            // Stop the incoming sound if it's playing\n            this._soundcache.get(Device.SoundName.Incoming).stop();\n            activeCall.accept({\n              rtcConstraints: options.rtcConstraints\n            });\n            this._publishNetworkChange();\n            return [2 /*return*/, activeCall];\n        }\n      });\n    });\n  };\n  Object.defineProperty(Device.prototype, \"calls\", {\n    /**\n     * Return the calls that this {@link Device} is maintaining.\n     */\n    get: function () {\n      return this._calls;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Destroy the {@link Device}, freeing references to be garbage collected.\n   */\n  Device.prototype.destroy = function () {\n    var _a;\n    this._log.debug('.destroy');\n    this._log.debug('Rejecting any incoming calls');\n    var calls = this._calls.slice(0);\n    calls.forEach(function (call) {\n      return call.reject();\n    });\n    this.disconnectAll();\n    this._stopRegistrationTimer();\n    this._destroyStream();\n    this._destroyPublisher();\n    this._destroyAudioHelper();\n    (_a = this._audioProcessorEventObserver) === null || _a === void 0 ? void 0 : _a.destroy();\n    if (this._networkInformation && typeof this._networkInformation.removeEventListener === 'function') {\n      this._networkInformation.removeEventListener('change', this._publishNetworkChange);\n    }\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('beforeunload', this._boundConfirmClose);\n      window.removeEventListener('unload', this._boundDestroy);\n      window.removeEventListener('pagehide', this._boundDestroy);\n    }\n    this._setState(Device.State.Destroyed);\n    events_1.EventEmitter.prototype.removeAllListeners.call(this);\n  };\n  /**\n   * Disconnect all {@link Call}s.\n   */\n  Device.prototype.disconnectAll = function () {\n    this._log.debug('.disconnectAll');\n    var calls = this._calls.splice(0);\n    calls.forEach(function (call) {\n      return call.disconnect();\n    });\n    if (this._activeCall) {\n      this._activeCall.disconnect();\n    }\n  };\n  Object.defineProperty(Device.prototype, \"edge\", {\n    /**\n     * Returns the {@link Edge} value the {@link Device} is currently connected\n     * to. The value will be `null` when the {@link Device} is offline.\n     */\n    get: function () {\n      return this._edge;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Device.prototype, \"home\", {\n    /**\n     * Returns the home value the {@link Device} is currently connected\n     * to. The value will be `null` when the {@link Device} is offline.\n     */\n    get: function () {\n      return this._home;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Device.prototype, \"identity\", {\n    /**\n     * Returns the identity associated with the {@link Device} for incoming calls. Only\n     * populated when registered.\n     */\n    get: function () {\n      return this._identity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Device.prototype, \"isBusy\", {\n    /**\n     * Whether the Device is currently on an active Call.\n     */\n    get: function () {\n      return !!this._activeCall;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Register the `Device` to the Twilio backend, allowing it to receive calls.\n   */\n  Device.prototype.register = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this._log.debug('.register');\n            if (this.state !== Device.State.Unregistered) {\n              throw new errors_1.InvalidStateError(\"Attempt to register when device is in state \\\"\" + this.state + \"\\\". \" + (\"Must be \\\"\" + Device.State.Unregistered + \"\\\".\"));\n            }\n            this._shouldReRegister = false;\n            this._setState(Device.State.Registering);\n            return [4 /*yield*/, this._streamConnectedPromise || this._setupStream()];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this._sendPresence(true)];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, util_1.promisifyEvents(this, Device.State.Registered, Device.State.Unregistered)];\n          case 3:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  Object.defineProperty(Device.prototype, \"state\", {\n    /**\n     * Get the state of this {@link Device} instance\n     */\n    get: function () {\n      return this._state;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Device.prototype, \"token\", {\n    /**\n     * Get the token used by this {@link Device}.\n     */\n    get: function () {\n      return this._token;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * String representation of {@link Device} instance.\n   * @private\n   */\n  Device.prototype.toString = function () {\n    return '[Twilio.Device instance]';\n  };\n  /**\n   * Unregister the `Device` to the Twilio backend, disallowing it to receive\n   * calls.\n   */\n  Device.prototype.unregister = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var stream, streamOfflinePromise;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this._log.debug('.unregister');\n            if (this.state !== Device.State.Registered) {\n              throw new errors_1.InvalidStateError(\"Attempt to unregister when device is in state \\\"\" + this.state + \"\\\". \" + (\"Must be \\\"\" + Device.State.Registered + \"\\\".\"));\n            }\n            this._shouldReRegister = false;\n            return [4 /*yield*/, this._streamConnectedPromise];\n          case 1:\n            stream = _a.sent();\n            streamOfflinePromise = new Promise(function (resolve) {\n              stream.on('offline', resolve);\n            });\n            return [4 /*yield*/, this._sendPresence(false)];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, streamOfflinePromise];\n          case 3:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Set the options used within the {@link Device}.\n   * @param options\n   */\n  Device.prototype.updateOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this._logOptions('updateOptions', options);\n    if (this.state === Device.State.Destroyed) {\n      throw new errors_1.InvalidStateError(\"Attempt to \\\"updateOptions\\\" when device is in state \\\"\" + this.state + \"\\\".\");\n    }\n    this._options = __assign(__assign(__assign({}, this._defaultOptions), this._options), options);\n    var originalChunderURIs = new Set(this._chunderURIs);\n    var chunderw = typeof this._options.chunderw === 'string' ? [this._options.chunderw] : Array.isArray(this._options.chunderw) && this._options.chunderw;\n    var newChunderURIs = this._chunderURIs = (chunderw || regions_1.getChunderURIs(this._options.edge)).map(regions_1.createSignalingEndpointURL);\n    var hasChunderURIsChanged = originalChunderURIs.size !== newChunderURIs.length;\n    if (!hasChunderURIsChanged) {\n      for (var _i = 0, newChunderURIs_1 = newChunderURIs; _i < newChunderURIs_1.length; _i++) {\n        var uri = newChunderURIs_1[_i];\n        if (!originalChunderURIs.has(uri)) {\n          hasChunderURIsChanged = true;\n          break;\n        }\n      }\n    }\n    if (this.isBusy && hasChunderURIsChanged) {\n      throw new errors_1.InvalidStateError('Cannot change Edge while on an active Call');\n    }\n    this._setupLoglevel(this._options.logLevel);\n    for (var _a = 0, _b = Object.keys(Device._defaultSounds); _a < _b.length; _a++) {\n      var name_1 = _b[_a];\n      var soundDef = Device._defaultSounds[name_1];\n      var defaultUrl = C.SOUNDS_BASE_URL + \"/\" + soundDef.filename + \".\" + Device.extension + (\"?cache=\" + C.RELEASE_VERSION);\n      var soundUrl = this._options.sounds && this._options.sounds[name_1] || defaultUrl;\n      var sound = new (this._options.Sound || sound_1.default)(name_1, soundUrl, {\n        audioContext: this._options.disableAudioContextSounds ? null : Device.audioContext,\n        maxDuration: soundDef.maxDuration,\n        shouldLoop: soundDef.shouldLoop\n      });\n      this._soundcache.set(name_1, sound);\n    }\n    this._setupAudioHelper();\n    this._setupPublisher();\n    if (hasChunderURIsChanged && this._streamConnectedPromise) {\n      this._setupStream();\n    }\n    // Setup close protection and make sure we clean up ongoing calls on unload.\n    if (typeof window !== 'undefined' && typeof window.addEventListener === 'function' && this._options.closeProtection) {\n      window.removeEventListener('beforeunload', this._boundConfirmClose);\n      window.addEventListener('beforeunload', this._boundConfirmClose);\n    }\n  };\n  /**\n   * Update the token used by this {@link Device} to connect to Twilio.\n   * It is recommended to call this API after [[Device.tokenWillExpireEvent]] is emitted,\n   * and before or after a call to prevent a potential ~1s audio loss during the update process.\n   * @param token\n   */\n  Device.prototype.updateToken = function (token) {\n    this._log.debug('.updateToken');\n    if (this.state === Device.State.Destroyed) {\n      throw new errors_1.InvalidStateError(\"Attempt to \\\"updateToken\\\" when device is in state \\\"\" + this.state + \"\\\".\");\n    }\n    if (typeof token !== 'string') {\n      throw new errors_1.InvalidArgumentError(INVALID_TOKEN_MESSAGE);\n    }\n    this._token = token;\n    if (this._stream) {\n      this._stream.setToken(this._token);\n    }\n    if (this._publisher) {\n      this._publisher.setToken(this._token);\n    }\n  };\n  /**\n   * Called on window's beforeunload event if closeProtection is enabled,\n   * preventing users from accidentally navigating away from an active call.\n   * @param event\n   */\n  Device.prototype._confirmClose = function (event) {\n    if (!this._activeCall) {\n      return '';\n    }\n    var closeProtection = this._options.closeProtection || false;\n    var confirmationMsg = typeof closeProtection !== 'string' ? 'A call is currently in-progress. Leaving or reloading this page will end the call.' : closeProtection;\n    (event || window.event).returnValue = confirmationMsg;\n    return confirmationMsg;\n  };\n  /**\n   * Destroy the AudioHelper.\n   */\n  Device.prototype._destroyAudioHelper = function () {\n    if (!this._audio) {\n      return;\n    }\n    this._audio._destroy();\n    this._audio = null;\n  };\n  /**\n   * Destroy the publisher.\n   */\n  Device.prototype._destroyPublisher = function () {\n    // Attempt to destroy non-existent publisher.\n    if (!this._publisher) {\n      return;\n    }\n    this._publisher = null;\n  };\n  /**\n   * Destroy the connection to the signaling server.\n   */\n  Device.prototype._destroyStream = function () {\n    if (this._stream) {\n      this._stream.removeListener('close', this._onSignalingClose);\n      this._stream.removeListener('connected', this._onSignalingConnected);\n      this._stream.removeListener('error', this._onSignalingError);\n      this._stream.removeListener('invite', this._onSignalingInvite);\n      this._stream.removeListener('offline', this._onSignalingOffline);\n      this._stream.removeListener('ready', this._onSignalingReady);\n      this._stream.destroy();\n      this._stream = null;\n    }\n    this._onSignalingOffline();\n    this._streamConnectedPromise = null;\n  };\n  /**\n   * Find a {@link Call} by its CallSid.\n   * @param callSid\n   */\n  Device.prototype._findCall = function (callSid) {\n    return this._calls.find(function (call) {\n      return call.parameters.CallSid === callSid || call.outboundConnectionId === callSid;\n    }) || null;\n  };\n  /**\n   * Utility function to log device options\n   */\n  Device.prototype._logOptions = function (caller, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    // Selectively log options that users can modify.\n    // Also, convert user overrides.\n    // This prevents potential app crash when calling JSON.stringify\n    // and when sending log strings remotely\n    var userOptions = ['allowIncomingWhileBusy', 'appName', 'appVersion', 'closeProtection', 'codecPreferences', 'disableAudioContextSounds', 'dscp', 'edge', 'enableImprovedSignalingErrorPrecision', 'forceAggressiveIceNomination', 'logLevel', 'maxAverageBitrate', 'maxCallSignalingTimeoutMs', 'sounds', 'tokenRefreshMs'];\n    var userOptionOverrides = ['RTCPeerConnection', 'enumerateDevices', 'getUserMedia'];\n    if (typeof options === 'object') {\n      var toLog_1 = __assign({}, options);\n      Object.keys(toLog_1).forEach(function (key) {\n        if (!userOptions.includes(key) && !userOptionOverrides.includes(key)) {\n          delete toLog_1[key];\n        }\n        if (userOptionOverrides.includes(key)) {\n          toLog_1[key] = true;\n        }\n      });\n      this._log.debug(\".\" + caller, JSON.stringify(toLog_1));\n    }\n  };\n  /**\n   * Create a new {@link Call}.\n   * @param twimlParams - A flat object containing key:value pairs to be sent to the TwiML app.\n   * @param options - Options to be used to instantiate the {@link Call}.\n   */\n  Device.prototype._makeCall = function (twimlParams, options, isReconnect) {\n    var _a;\n    if (isReconnect === void 0) {\n      isReconnect = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var inputDevicePromise, config, maybeUnsetPreferredUri, call;\n      var _b;\n      var _this = this;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n              throw new errors_1.InvalidStateError('Device has not been initialized.');\n            }\n            inputDevicePromise = (_a = this._audio) === null || _a === void 0 ? void 0 : _a._getInputDevicePromise();\n            if (!inputDevicePromise) return [3 /*break*/, 2];\n            this._log.debug('inputDevicePromise detected, waiting...');\n            return [4 /*yield*/, inputDevicePromise];\n          case 1:\n            _c.sent();\n            this._log.debug('inputDevicePromise resolved');\n            _c.label = 2;\n          case 2:\n            _b = {\n              audioHelper: this._audio,\n              isUnifiedPlanDefault: Device._isUnifiedPlanDefault,\n              onIgnore: function () {\n                _this._soundcache.get(Device.SoundName.Incoming).stop();\n              }\n            };\n            return [4 /*yield*/, this._streamConnectedPromise || this._setupStream()];\n          case 3:\n            config = (_b.pstream = _c.sent(), _b.publisher = this._publisher, _b.soundcache = this._soundcache, _b);\n            options = Object.assign({\n              MediaStream: this._options.MediaStream || rtc.PeerConnection,\n              RTCPeerConnection: this._options.RTCPeerConnection,\n              beforeAccept: function (currentCall) {\n                if (!_this._activeCall || _this._activeCall === currentCall) {\n                  return;\n                }\n                _this._activeCall.disconnect();\n                _this._removeCall(_this._activeCall);\n              },\n              codecPreferences: this._options.codecPreferences,\n              customSounds: this._options.sounds,\n              dialtonePlayer: Device._dialtonePlayer,\n              dscp: this._options.dscp,\n              // TODO(csantos): Remove forceAggressiveIceNomination option in 3.x\n              forceAggressiveIceNomination: this._options.forceAggressiveIceNomination,\n              getInputStream: function () {\n                return _this._options.fileInputStream || _this._callInputStream;\n              },\n              getSinkIds: function () {\n                return _this._callSinkIds;\n              },\n              maxAverageBitrate: this._options.maxAverageBitrate,\n              preflight: this._options.preflight,\n              rtcConstraints: this._options.rtcConstraints,\n              shouldPlayDisconnect: function () {\n                var _a;\n                return (_a = _this._audio) === null || _a === void 0 ? void 0 : _a.disconnect();\n              },\n              twimlParams: twimlParams,\n              voiceEventSidGenerator: this._options.voiceEventSidGenerator\n            }, options);\n            maybeUnsetPreferredUri = function () {\n              if (!_this._stream) {\n                _this._log.warn('UnsetPreferredUri called without a stream');\n                return;\n              }\n              if (_this._activeCall === null && _this._calls.length === 0) {\n                _this._stream.updatePreferredURI(null);\n              }\n            };\n            call = new (this._options.Call || call_1.default)(config, options);\n            this._publisher.info('settings', 'init', {\n              RTCPeerConnection: !!this._options.RTCPeerConnection,\n              enumerateDevices: !!this._options.enumerateDevices,\n              getUserMedia: !!this._options.getUserMedia\n            }, call);\n            call.once('accept', function () {\n              var _a, _b, _c;\n              _this._stream.updatePreferredURI(_this._preferredURI);\n              _this._removeCall(call);\n              _this._activeCall = call;\n              if (_this._audio) {\n                _this._audio._maybeStartPollingVolume();\n              }\n              if (call.direction === call_1.default.CallDirection.Outgoing && ((_a = _this._audio) === null || _a === void 0 ? void 0 : _a.outgoing()) && !isReconnect) {\n                _this._soundcache.get(Device.SoundName.Outgoing).play();\n              }\n              var data = {\n                edge: _this._edge || _this._region\n              };\n              if (_this._options.edge) {\n                data['selected_edge'] = Array.isArray(_this._options.edge) ? _this._options.edge : [_this._options.edge];\n              }\n              _this._publisher.info('settings', 'edge', data, call);\n              if ((_b = _this._audio) === null || _b === void 0 ? void 0 : _b.processedStream) {\n                (_c = _this._audioProcessorEventObserver) === null || _c === void 0 ? void 0 : _c.emit('enabled');\n              }\n            });\n            call.addListener('error', function (error) {\n              if (call.status() === 'closed') {\n                _this._removeCall(call);\n                maybeUnsetPreferredUri();\n              }\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n              _this._maybeStopIncomingSound();\n            });\n            call.once('cancel', function () {\n              _this._log.info(\"Canceled: \" + call.parameters.CallSid);\n              _this._removeCall(call);\n              maybeUnsetPreferredUri();\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n              _this._maybeStopIncomingSound();\n            });\n            call.once('disconnect', function () {\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n              _this._removeCall(call);\n              maybeUnsetPreferredUri();\n              /**\n               * NOTE(kamalbennani): We need to stop the incoming sound when the call is\n               * disconnected right after the user has accepted the call (activeCall.accept()), and before\n               * the call has been fully connected (i.e. before the `pstream.answer` event)\n               */\n              _this._maybeStopIncomingSound();\n            });\n            call.once('reject', function () {\n              _this._log.info(\"Rejected: \" + call.parameters.CallSid);\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n              _this._removeCall(call);\n              maybeUnsetPreferredUri();\n              _this._maybeStopIncomingSound();\n            });\n            call.on('transportClose', function () {\n              if (call.status() !== call_1.default.State.Pending) {\n                return;\n              }\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n              _this._removeCall(call);\n              /**\n               * NOTE(mhuynh): We don't want to call `maybeUnsetPreferredUri` because\n               * a `transportClose` will happen during signaling reconnection.\n               */\n              _this._maybeStopIncomingSound();\n            });\n            return [2 /*return*/, call];\n        }\n      });\n    });\n  };\n  /**\n   * Stop the incoming sound if no {@link Call}s remain.\n   */\n  Device.prototype._maybeStopIncomingSound = function () {\n    if (!this._calls.length) {\n      this._soundcache.get(Device.SoundName.Incoming).stop();\n    }\n  };\n  /**\n   * Remove a {@link Call} from device.calls by reference\n   * @param call\n   */\n  Device.prototype._removeCall = function (call) {\n    if (this._activeCall === call) {\n      this._activeCall = null;\n      this._makeCallPromise = null;\n    }\n    for (var i = this._calls.length - 1; i >= 0; i--) {\n      if (call === this._calls[i]) {\n        this._calls.splice(i, 1);\n      }\n    }\n  };\n  /**\n   * Register with the signaling server.\n   */\n  Device.prototype._sendPresence = function (presence) {\n    return __awaiter(this, void 0, void 0, function () {\n      var stream;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this._streamConnectedPromise];\n          case 1:\n            stream = _a.sent();\n            if (!stream) {\n              return [2 /*return*/];\n            }\n            stream.register({\n              audio: presence\n            });\n            if (presence) {\n              this._startRegistrationTimer();\n            } else {\n              this._stopRegistrationTimer();\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Helper function that sets and emits the state of the device.\n   * @param state The new state of the device.\n   */\n  Device.prototype._setState = function (state) {\n    if (state === this.state) {\n      return;\n    }\n    this._state = state;\n    var name = this._stateEventMapping[state];\n    this._log.debug(\"#\" + name);\n    this.emit(name);\n  };\n  /**\n   * Set up an audio helper for usage by this {@link Device}.\n   */\n  Device.prototype._setupAudioHelper = function () {\n    var _this = this;\n    if (!this._audioProcessorEventObserver) {\n      this._audioProcessorEventObserver = new audioprocessoreventobserver_1.AudioProcessorEventObserver();\n      this._audioProcessorEventObserver.on('event', function (_a) {\n        var name = _a.name,\n          group = _a.group;\n        _this._publisher.info(group, name, {}, _this._activeCall);\n      });\n    }\n    var audioOptions = {\n      audioContext: Device.audioContext,\n      audioProcessorEventObserver: this._audioProcessorEventObserver,\n      beforeSetInputDevice: function () {\n        if (_this._makeCallPromise) {\n          _this._log.debug('beforeSetInputDevice pause detected');\n          return _this._makeCallPromise;\n        } else {\n          _this._log.debug('beforeSetInputDevice pause not detected, setting default');\n          return Promise.resolve();\n        }\n      },\n      enumerateDevices: this._options.enumerateDevices,\n      getUserMedia: this._options.getUserMedia || getusermedia_1.default\n    };\n    if (this._audio) {\n      this._log.info('Found existing audio helper; updating options...');\n      this._audio._updateUserOptions(audioOptions);\n      return;\n    }\n    this._audio = new (this._options.AudioHelper || audiohelper_1.default)(this._updateSinkIds, this._updateInputStream, audioOptions);\n    this._audio.on('deviceChange', function (lostActiveDevices) {\n      var activeCall = _this._activeCall;\n      var deviceIds = lostActiveDevices.map(function (device) {\n        return device.deviceId;\n      });\n      _this._publisher.info('audio', 'device-change', {\n        lost_active_device_ids: deviceIds\n      }, activeCall);\n      if (activeCall) {\n        activeCall['_mediaHandler']._onInputDevicesChanged();\n      }\n    });\n  };\n  /**\n   * Setup logger's loglevel\n   */\n  Device.prototype._setupLoglevel = function (logLevel) {\n    var level = typeof logLevel === 'number' || typeof logLevel === 'string' ? logLevel : loglevel_1.levels.ERROR;\n    this._log.setDefaultLevel(level);\n    this._log.info('Set logger default level to', level);\n  };\n  /**\n   * Create and set a publisher for the {@link Device} to use.\n   */\n  Device.prototype._setupPublisher = function () {\n    var _this = this;\n    if (this._publisher) {\n      this._log.info('Found existing publisher; destroying...');\n      this._destroyPublisher();\n    }\n    var publisherOptions = {\n      defaultPayload: this._createDefaultPayload,\n      metadata: {\n        app_name: this._options.appName,\n        app_version: this._options.appVersion\n      }\n    };\n    if (this._options.eventgw) {\n      publisherOptions.host = this._options.eventgw;\n    }\n    if (this._home) {\n      publisherOptions.host = regions_1.createEventGatewayURI(this._home);\n    }\n    this._publisher = new (this._options.Publisher || eventpublisher_1.default)(PUBLISHER_PRODUCT_NAME, this.token, publisherOptions);\n    if (this._options.publishEvents === false) {\n      this._publisher.disable();\n    } else {\n      this._publisher.on('error', function (error) {\n        _this._log.warn('Cannot connect to insights.', error);\n      });\n    }\n    return this._publisher;\n  };\n  /**\n   * Set up the connection to the signaling server. Tears down an existing\n   * stream if called while a stream exists.\n   */\n  Device.prototype._setupStream = function () {\n    var _this = this;\n    if (this._stream) {\n      this._log.info('Found existing stream; destroying...');\n      this._destroyStream();\n    }\n    this._log.info('Setting up VSP');\n    this._stream = new (this._options.PStream || pstream_1.default)(this.token, this._chunderURIs, {\n      backoffMaxMs: this._options.backoffMaxMs,\n      maxPreferredDurationMs: this._options.maxCallSignalingTimeoutMs\n    });\n    this._stream.addListener('close', this._onSignalingClose);\n    this._stream.addListener('connected', this._onSignalingConnected);\n    this._stream.addListener('error', this._onSignalingError);\n    this._stream.addListener('invite', this._onSignalingInvite);\n    this._stream.addListener('offline', this._onSignalingOffline);\n    this._stream.addListener('ready', this._onSignalingReady);\n    return this._streamConnectedPromise = util_1.promisifyEvents(this._stream, 'connected', 'close').then(function () {\n      return _this._stream;\n    });\n  };\n  /**\n   * Start playing the incoming ringtone, and subsequently emit the incoming event.\n   * @param call\n   * @param play - The function to be used to play the sound. Must return a Promise.\n   */\n  Device.prototype._showIncomingCall = function (call, play) {\n    var _this = this;\n    var timeout;\n    return Promise.race([play(), new Promise(function (resolve, reject) {\n      timeout = setTimeout(function () {\n        var msg = 'Playing incoming ringtone took too long; it might not play. Continuing execution...';\n        reject(new Error(msg));\n      }, RINGTONE_PLAY_TIMEOUT);\n    })]).catch(function (reason) {\n      _this._log.warn(reason.message);\n    }).then(function () {\n      clearTimeout(timeout);\n      _this._log.debug('#incoming', JSON.stringify({\n        customParameters: call.customParameters,\n        parameters: call.parameters\n      }));\n      _this.emit(Device.EventName.Incoming, call);\n    });\n  };\n  /**\n   * Set a timeout to send another register message to the signaling server.\n   */\n  Device.prototype._startRegistrationTimer = function () {\n    var _this = this;\n    this._stopRegistrationTimer();\n    this._regTimer = setTimeout(function () {\n      _this._sendPresence(true);\n    }, REGISTRATION_INTERVAL);\n  };\n  /**\n   * Stop sending registration messages to the signaling server.\n   */\n  Device.prototype._stopRegistrationTimer = function () {\n    if (this._regTimer) {\n      clearTimeout(this._regTimer);\n    }\n  };\n  /**\n   * Throw an error if the {@link Device} is destroyed.\n   */\n  Device.prototype._throwIfDestroyed = function () {\n    if (this.state === Device.State.Destroyed) {\n      throw new errors_1.InvalidStateError('Device has been destroyed.');\n    }\n  };\n  /**\n   * Update the device IDs of output devices being used to play the incoming ringtone through.\n   * @param sinkIds - An array of device IDs\n   */\n  Device.prototype._updateRingtoneSinkIds = function (sinkIds) {\n    return Promise.resolve(this._soundcache.get(Device.SoundName.Incoming).setSinkIds(sinkIds));\n  };\n  /**\n   * Update the device IDs of output devices being used to play the non-ringtone sounds\n   * and Call audio through.\n   * @param sinkIds - An array of device IDs\n   */\n  Device.prototype._updateSpeakerSinkIds = function (sinkIds) {\n    Array.from(this._soundcache.entries()).filter(function (entry) {\n      return entry[0] !== Device.SoundName.Incoming;\n    }).forEach(function (entry) {\n      return entry[1].setSinkIds(sinkIds);\n    });\n    this._callSinkIds = sinkIds;\n    var call = this._activeCall;\n    return call ? call._setSinkIds(sinkIds) : Promise.resolve();\n  };\n  Device._defaultSounds = {\n    disconnect: {\n      filename: 'disconnect',\n      maxDuration: 3000\n    },\n    dtmf0: {\n      filename: 'dtmf-0',\n      maxDuration: 1000\n    },\n    dtmf1: {\n      filename: 'dtmf-1',\n      maxDuration: 1000\n    },\n    dtmf2: {\n      filename: 'dtmf-2',\n      maxDuration: 1000\n    },\n    dtmf3: {\n      filename: 'dtmf-3',\n      maxDuration: 1000\n    },\n    dtmf4: {\n      filename: 'dtmf-4',\n      maxDuration: 1000\n    },\n    dtmf5: {\n      filename: 'dtmf-5',\n      maxDuration: 1000\n    },\n    dtmf6: {\n      filename: 'dtmf-6',\n      maxDuration: 1000\n    },\n    dtmf7: {\n      filename: 'dtmf-7',\n      maxDuration: 1000\n    },\n    dtmf8: {\n      filename: 'dtmf-8',\n      maxDuration: 1000\n    },\n    dtmf9: {\n      filename: 'dtmf-9',\n      maxDuration: 1000\n    },\n    dtmfh: {\n      filename: 'dtmf-hash',\n      maxDuration: 1000\n    },\n    dtmfs: {\n      filename: 'dtmf-star',\n      maxDuration: 1000\n    },\n    incoming: {\n      filename: 'incoming',\n      shouldLoop: true\n    },\n    outgoing: {\n      filename: 'outgoing',\n      maxDuration: 3000\n    }\n  };\n  return Device;\n}(events_1.EventEmitter);\n(function (Device) {\n  /**\n   * All valid {@link Device} event names.\n   */\n  var EventName;\n  (function (EventName) {\n    EventName[\"Error\"] = \"error\";\n    EventName[\"Incoming\"] = \"incoming\";\n    EventName[\"Destroyed\"] = \"destroyed\";\n    EventName[\"Unregistered\"] = \"unregistered\";\n    EventName[\"Registering\"] = \"registering\";\n    EventName[\"Registered\"] = \"registered\";\n    EventName[\"TokenWillExpire\"] = \"tokenWillExpire\";\n  })(EventName = Device.EventName || (Device.EventName = {}));\n  /**\n   * All possible {@link Device} states.\n   */\n  var State;\n  (function (State) {\n    State[\"Destroyed\"] = \"destroyed\";\n    State[\"Unregistered\"] = \"unregistered\";\n    State[\"Registering\"] = \"registering\";\n    State[\"Registered\"] = \"registered\";\n  })(State = Device.State || (Device.State = {}));\n  /**\n   * Names of all sounds handled by the {@link Device}.\n   */\n  var SoundName;\n  (function (SoundName) {\n    SoundName[\"Incoming\"] = \"incoming\";\n    SoundName[\"Outgoing\"] = \"outgoing\";\n    SoundName[\"Disconnect\"] = \"disconnect\";\n    SoundName[\"Dtmf0\"] = \"dtmf0\";\n    SoundName[\"Dtmf1\"] = \"dtmf1\";\n    SoundName[\"Dtmf2\"] = \"dtmf2\";\n    SoundName[\"Dtmf3\"] = \"dtmf3\";\n    SoundName[\"Dtmf4\"] = \"dtmf4\";\n    SoundName[\"Dtmf5\"] = \"dtmf5\";\n    SoundName[\"Dtmf6\"] = \"dtmf6\";\n    SoundName[\"Dtmf7\"] = \"dtmf7\";\n    SoundName[\"Dtmf8\"] = \"dtmf8\";\n    SoundName[\"Dtmf9\"] = \"dtmf9\";\n    SoundName[\"DtmfS\"] = \"dtmfs\";\n    SoundName[\"DtmfH\"] = \"dtmfh\";\n  })(SoundName = Device.SoundName || (Device.SoundName = {}));\n})(Device || (Device = {}));\nexports.default = Device;","map":{"version":3,"names":["events_1","require","loglevel_1","audiohelper_1","audioprocessoreventobserver_1","call_1","C","dialtonePlayer_1","errors_1","eventpublisher_1","log_1","preflight_1","pstream_1","regions_1","rtc","getusermedia_1","sound_1","util_1","uuid_1","REGISTRATION_INTERVAL","RINGTONE_PLAY_TIMEOUT","PUBLISHER_PRODUCT_NAME","INVALID_TOKEN_MESSAGE","Device","_super","__extends","token","options","_this","call","_activeCall","_audio","_audioProcessorEventObserver","_callInputStream","_calls","_callSinkIds","_chunderURIs","_defaultOptions","allowIncomingWhileBusy","closeProtection","codecPreferences","default","Codec","PCMU","Opus","dscp","enableImprovedSignalingErrorPrecision","forceAggressiveIceNomination","logLevel","levels","ERROR","maxCallSignalingTimeoutMs","preflight","sounds","tokenRefreshMs","voiceEventSidGenerator","generateVoiceEventSid","_edge","_home","_identity","_log","_makeCallPromise","_options","_preferredURI","_publisher","_region","_regTimer","_shouldReRegister","_soundcache","Map","_state","State","Unregistered","_stateEventMapping","_a","Destroyed","EventName","Registering","Registered","_stream","_streamConnectedPromise","_tokenWillExpireTimeout","_createDefaultPayload","payload","aggressive_nomination","browser_extension","_isBrowserExtension","ice_restart_enabled","platform","getMediaEngine","sdk_version","RELEASE_VERSION","setIfDefined","propertyName","value","callSid","parameters","CallSid","test","undefined","outboundConnectionId","codec","direction","gateway","region","_onSignalingClose","_onSignalingConnected","getRegionShortcode","edge","regionToEdge","home","setHost","createEventGatewayURI","identity","ttl","ttlMs","timeoutMs","Math","max","setTimeout","debug","emit","clearTimeout","preferredURIs","getChunderURIs","length","preferredURI","createSignalingEndpointURL","warn","register","_onSignalingError","originalError","error","callsid","voiceeventsid","_findCall","code","customMessage","message","twilioError","AuthorizationErrors","AuthenticationFailed","AccessTokenInvalid","_stopRegistrationTimer","AccessTokenExpired","errorConstructor","getPreciseSignalingErrorByCode","GeneralErrors","UnknownError","Error","_onSignalingInvite","__awaiter","wasBusy","info","sdp","ClientErrors","BadRequest","callParameters","customParameters","Object","assign","queryToJson","Params","_makeCall","offerSdp","reconnectToken","reconnect","_b","sent","push","once","get","SoundName","Incoming","stop","_publishNetworkChange","play","incoming","Promise","resolve","_showIncomingCall","_onSignalingOffline","state","_setState","_onSignalingReady","_networkInformation","connection_type","type","downlink","downlinkMax","effective_type","effectiveType","rtt","_updateInputStream","inputStream","reject","InvalidStateError","_setInputTracksFromStream","_updateSinkIds","sinkIds","promise","_updateRingtoneSinkIds","_updateSpeakerSinkIds","then","audio_device_ids","_setupLoglevel","_logOptions","updateToken","isLegacyEdge","NotSupportedError","isSupported","ignoreBrowserSupport","window","location","protocol","root","globalThis","browser","msBrowser","chrome","runtime","id","safari","extension","navigator","n","connection","mozConnection","webkitConnection","addEventListener","_getOrCreateAudioContext","_audioContext","_dialtonePlayer","_isUnifiedPlanDefault","RTCPeerConnection","RTCRtpTransceiver","isUnifiedPlanDefault","_boundDestroy","destroy","bind","_boundConfirmClose","_confirmClose","updateOptions","defineProperty","a","document","createElement","canPlayType","canPlayMp3","replace","e","canPlayVorbis","enabled","PACKAGE_NAME","runPreflight","PreflightTest","__assign","audioContext","toString","AudioContext","webkitAudioContext","prototype","connect","JSON","stringify","_throwIfDestroyed","connectToken","connectTokenParts","parse","decodeURIComponent","atob","signalingReconnectToken","_c","InvalidArgumentError","isReconnect","twimlParams","callOptions","rtcConfiguration","reconnectCallSid","params","activeCall","splice","forEach","ignore","accept","rtcConstraints","calls","slice","disconnectAll","_destroyStream","_destroyPublisher","_destroyAudioHelper","removeEventListener","EventEmitter","removeAllListeners","disconnect","_setupStream","_sendPresence","promisifyEvents","_token","unregister","stream","streamOfflinePromise","on","originalChunderURIs","Set","chunderw","Array","isArray","newChunderURIs","map","hasChunderURIsChanged","size","_i","newChunderURIs_1","uri","has","isBusy","keys","_defaultSounds","name_1","soundDef","defaultUrl","SOUNDS_BASE_URL","filename","soundUrl","sound","Sound","disableAudioContextSounds","maxDuration","shouldLoop","set","_setupAudioHelper","_setupPublisher","setToken","event","confirmationMsg","returnValue","_destroy","removeListener","find","caller","userOptions","userOptionOverrides","toLog_1","key","includes","inputDevicePromise","_getInputDevicePromise","audioHelper","onIgnore","config","pstream","publisher","soundcache","MediaStream","PeerConnection","beforeAccept","currentCall","_removeCall","customSounds","dialtonePlayer","getInputStream","fileInputStream","getSinkIds","maxAverageBitrate","shouldPlayDisconnect","maybeUnsetPreferredUri","updatePreferredURI","Call","enumerateDevices","getUserMedia","_maybeStartPollingVolume","CallDirection","Outgoing","outgoing","data","processedStream","addListener","status","_maybeStopPollingVolume","_maybeStopIncomingSound","Pending","i","presence","audio","_startRegistrationTimer","name","AudioProcessorEventObserver","group","audioOptions","audioProcessorEventObserver","beforeSetInputDevice","_updateUserOptions","AudioHelper","lostActiveDevices","deviceIds","device","deviceId","lost_active_device_ids","_onInputDevicesChanged","level","setDefaultLevel","publisherOptions","defaultPayload","metadata","app_name","appName","app_version","appVersion","eventgw","host","Publisher","publishEvents","disable","PStream","backoffMaxMs","maxPreferredDurationMs","timeout","race","msg","catch","reason","setSinkIds","from","entries","filter","entry","_setSinkIds","dtmf0","dtmf1","dtmf2","dtmf3","dtmf4","dtmf5","dtmf6","dtmf7","dtmf8","dtmf9","dtmfh","dtmfs","exports"],"sources":["C:\\Users\\91629\\Desktop\\Delote\\calling software\\node_modules\\@twilio\\voice-sdk\\lib\\twilio\\device.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nimport { EventEmitter } from 'events';\nimport { levels as LogLevels, LogLevelDesc } from 'loglevel';\nimport AudioHelper from './audiohelper';\nimport { AudioProcessorEventObserver } from './audioprocessoreventobserver';\nimport Call from './call';\nimport * as C from './constants';\nimport DialtonePlayer from './dialtonePlayer';\nimport {\n  AuthorizationErrors,\n  ClientErrors,\n  GeneralErrors,\n  getPreciseSignalingErrorByCode,\n  InvalidArgumentError,\n  InvalidStateError,\n  NotSupportedError,\n  TwilioError,\n} from './errors';\nimport Publisher from './eventpublisher';\nimport Log from './log';\nimport { PreflightTest } from './preflight/preflight';\nimport PStream from './pstream';\nimport {\n  createEventGatewayURI,\n  createSignalingEndpointURL,\n  Edge,\n  getChunderURIs,\n  getRegionShortcode,\n  Region,\n  regionToEdge,\n} from './regions';\nimport * as rtc from './rtc';\nimport getUserMedia from './rtc/getusermedia';\nimport Sound from './sound';\nimport {\n  isLegacyEdge,\n  isUnifiedPlanDefault,\n  promisifyEvents,\n  queryToJson,\n} from './util';\nimport { generateVoiceEventSid } from './uuid';\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IPStream = any;\n/**\n * @private\n */\nexport type IPublisher = any;\n/**\n * @private\n */\nexport type ISound = any;\n\nconst REGISTRATION_INTERVAL = 30000;\nconst RINGTONE_PLAY_TIMEOUT = 2000;\nconst PUBLISHER_PRODUCT_NAME = 'twilio-js-sdk';\nconst INVALID_TOKEN_MESSAGE = 'Parameter \"token\" must be of type \"string\".';\n\ndeclare const RTCRtpTransceiver: any;\ndeclare const webkitAudioContext: typeof AudioContext;\n\n/**\n * Options that may be passed to the {@link Device} constructor for internal testing.\n * @private\n */\nexport interface IExtendedDeviceOptions extends Device.Options {\n  /**\n   * Custom {@link AudioHelper} constructor\n   */\n  AudioHelper?: typeof AudioHelper;\n\n  /**\n   * The max amount of time in milliseconds to allow stream (re)-connect\n   * backoffs.\n   */\n  backoffMaxMs?: number;\n\n  /**\n   * Custom {@link Call} constructor\n   */\n  Call?: typeof Call;\n\n  /**\n   * Hostname of the signaling gateway to connect to.\n   */\n  chunderw?: string | string[];\n\n  /**\n   * Hostname of the event gateway to connect to.\n   */\n  eventgw?: string;\n\n  /**\n   * File input stream to use instead of reading from mic\n   */\n  fileInputStream?: MediaStream;\n\n  /**\n   * Ignore browser support, disabling the exception that is thrown when neither WebRTC nor\n   * ORTC are supported.\n   */\n  ignoreBrowserSupport?: boolean;\n\n  /**\n   * MediaStream constructor.\n   */\n  MediaStream?: typeof MediaStream;\n\n  /**\n   * Whether this is a preflight call or not\n   */\n  preflight?: boolean;\n\n  /**\n   * Custom PStream constructor\n   */\n  PStream?: IPStream;\n\n  /**\n   * Custom Publisher constructor\n   */\n  Publisher?: IPublisher;\n\n  /**\n   * Whether or not to publish events to insights using {@link Device._publisher}.\n   */\n  publishEvents?: boolean;\n\n  /**\n   * MediaStreamConstraints to pass to getUserMedia when making or accepting a Call.\n   */\n  rtcConstraints?: Call.AcceptOptions['rtcConstraints'];\n\n  /**\n   * Custom Sound constructor\n   */\n  Sound?: ISound;\n\n  /**\n   * Voice event SID generator.\n   */\n  voiceEventSidGenerator?: () => string;\n}\n\n/**\n * A sound definition used to initialize a Sound file.\n * @private\n */\nexport interface ISoundDefinition {\n  /**\n   * Name of the sound file.\n   */\n  filename: string;\n\n  /**\n   * The amount of time this sound file should play before being stopped automatically.\n   */\n  maxDuration?: number;\n\n  /**\n   * Whether or not this sound should loop after playthrough finishes.\n   */\n  shouldLoop?: boolean;\n}\n\n/**\n * Twilio Device. Allows registration for incoming calls, and placing outgoing calls.\n * @publicapi\n */\nclass Device extends EventEmitter {\n  /**\n   * The AudioContext to be used by {@link Device} instances.\n   * @private\n   */\n  static get audioContext(): AudioContext | undefined {\n    return Device._audioContext;\n  }\n\n  /**\n   * Which sound file extension is supported.\n   * @private\n   */\n  static get extension(): 'mp3' | 'ogg' {\n    // NOTE(mroberts): Node workaround.\n    const a: any = typeof document !== 'undefined'\n      ? document.createElement('audio') : { canPlayType: false };\n\n    let canPlayMp3;\n    try {\n      canPlayMp3 = a.canPlayType && !!a.canPlayType('audio/mpeg').replace(/no/, '');\n    } catch (e) {\n      canPlayMp3 = false;\n    }\n\n    let canPlayVorbis;\n    try {\n      canPlayVorbis = a.canPlayType && !!a.canPlayType('audio/ogg;codecs=\\'vorbis\\'').replace(/no/, '');\n    } catch (e) {\n      canPlayVorbis = false;\n    }\n\n    return (canPlayVorbis && !canPlayMp3) ? 'ogg' : 'mp3';\n  }\n\n  /**\n   * Whether or not this SDK is supported by the current browser.\n   */\n  static get isSupported(): boolean { return rtc.enabled(); }\n\n  /**\n   * Package name of the SDK.\n   */\n  static get packageName(): string { return C.PACKAGE_NAME; }\n\n  /**\n   * Run some tests to identify issues, if any, prohibiting successful calling.\n   * @param token - A Twilio JWT token string\n   * @param options\n   */\n  static runPreflight(token: string, options?: PreflightTest.Options): PreflightTest {\n    return new PreflightTest(token, { audioContext: Device._getOrCreateAudioContext(), ...options });\n  }\n\n  /**\n   * String representation of {@link Device} class.\n   * @private\n   */\n  static toString(): string {\n    return '[Twilio.Device class]';\n  }\n\n  /**\n   * Current SDK version.\n   */\n  static get version(): string { return C.RELEASE_VERSION; }\n\n  /**\n   * An AudioContext to share between {@link Device}s.\n   */\n  private static _audioContext?: AudioContext;\n\n  private static _defaultSounds: Record<string, ISoundDefinition> = {\n    disconnect: { filename: 'disconnect', maxDuration: 3000 },\n    dtmf0: { filename: 'dtmf-0', maxDuration: 1000 },\n    dtmf1: { filename: 'dtmf-1', maxDuration: 1000 },\n    dtmf2: { filename: 'dtmf-2', maxDuration: 1000 },\n    dtmf3: { filename: 'dtmf-3', maxDuration: 1000 },\n    dtmf4: { filename: 'dtmf-4', maxDuration: 1000 },\n    dtmf5: { filename: 'dtmf-5', maxDuration: 1000 },\n    dtmf6: { filename: 'dtmf-6', maxDuration: 1000 },\n    dtmf7: { filename: 'dtmf-7', maxDuration: 1000 },\n    dtmf8: { filename: 'dtmf-8', maxDuration: 1000 },\n    dtmf9: { filename: 'dtmf-9', maxDuration: 1000 },\n    dtmfh: { filename: 'dtmf-hash', maxDuration: 1000 },\n    dtmfs: { filename: 'dtmf-star', maxDuration: 1000 },\n    incoming: { filename: 'incoming', shouldLoop: true },\n    outgoing: { filename: 'outgoing', maxDuration: 3000 },\n  };\n\n  /**\n   * A DialtonePlayer to play mock DTMF sounds through.\n   */\n  private static _dialtonePlayer?: DialtonePlayer;\n\n  /**\n   * Whether or not the browser uses unified-plan SDP by default.\n   */\n  private static _isUnifiedPlanDefault: boolean | undefined;\n\n  /**\n   * Initializes the AudioContext instance shared across the Voice SDK,\n   * or returns the existing instance if one has already been initialized.\n   */\n  private static _getOrCreateAudioContext(): AudioContext | undefined {\n    if (!Device._audioContext) {\n      if (typeof AudioContext !== 'undefined') {\n        Device._audioContext = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Device._audioContext = new webkitAudioContext();\n      }\n    }\n    return Device._audioContext;\n  }\n\n  /**\n   * The currently active {@link Call}, if there is one.\n   */\n  private _activeCall: Call | null = null;\n\n  /**\n   * The AudioHelper instance associated with this {@link Device}.\n   */\n  private _audio: AudioHelper | null = null;\n\n  /**\n   * The AudioProcessorEventObserver instance to use\n   */\n  private _audioProcessorEventObserver: AudioProcessorEventObserver | null = null;\n\n  /**\n   * {@link Device._confirmClose} bound to the specific {@link Device} instance.\n   */\n  private _boundConfirmClose: typeof Device.prototype._confirmClose;\n\n  /**\n   * {@link Device.destroy} bound to the specific {@link Device} instance.\n   */\n  private _boundDestroy: typeof Device.prototype.destroy;\n\n  /**\n   * An audio input MediaStream to pass to new {@link Call} instances.\n   */\n  private _callInputStream: MediaStream | null = null;\n\n  /**\n   * An array of {@link Call}s. Though only one can be active, multiple may exist when there\n   * are multiple incoming, unanswered {@link Call}s.\n   */\n  private _calls: Call[] = [];\n\n  /**\n   * An array of {@link Device} IDs to be used to play sounds through, to be passed to\n   * new {@link Call} instances.\n   */\n  private _callSinkIds: string[] = ['default'];\n\n  /**\n   * The list of chunder URIs that will be passed to PStream\n   */\n  private _chunderURIs: string[] = [];\n\n  /**\n   * Default options used by {@link Device}.\n   */\n  private readonly _defaultOptions: IExtendedDeviceOptions = {\n    allowIncomingWhileBusy: false,\n    closeProtection: false,\n    codecPreferences: [Call.Codec.PCMU, Call.Codec.Opus],\n    dscp: true,\n    enableImprovedSignalingErrorPrecision: false,\n    forceAggressiveIceNomination: false,\n    logLevel: LogLevels.ERROR,\n    maxCallSignalingTimeoutMs: 0,\n    preflight: false,\n    sounds: { },\n    tokenRefreshMs: 10000,\n    voiceEventSidGenerator: generateVoiceEventSid,\n  };\n\n  /**\n   * The name of the edge the {@link Device} is connected to.\n   */\n  private _edge: string | null = null;\n\n  /**\n   * The name of the home region the {@link Device} is connected to.\n   */\n  private _home: string | null = null;\n\n  /**\n   * The identity associated with this Device.\n   */\n  private _identity: string | null = null;\n\n  /**\n   * Whether SDK is run as a browser extension\n   */\n  private _isBrowserExtension: boolean;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = new Log('Device');\n\n  /**\n   * The internal promise created when calling {@link Device.makeCall}.\n   */\n  private _makeCallPromise: Promise<any> | null = null;\n\n  /**\n   * Network related information\n   * See https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API\n   */\n  private _networkInformation: any;\n\n  /**\n   * The options passed to {@link Device} constructor or {@link Device.updateOptions}.\n   */\n  private _options: IExtendedDeviceOptions = { };\n\n  /**\n   * The preferred URI to (re)-connect signaling to.\n   */\n  private _preferredURI: string | null = null;\n\n  /**\n   * An Insights Event Publisher.\n   */\n  private _publisher: IPublisher | null = null;\n\n  /**\n   * The region the {@link Device} is connected to.\n   */\n  private _region: string | null = null;\n\n  /**\n   * A timeout ID for a setTimeout schedule to re-register the {@link Device}.\n   */\n  private _regTimer: NodeJS.Timer | null = null;\n\n  /**\n   * Boolean representing whether or not the {@link Device} was registered when\n   * receiving a signaling `offline`. Determines if the {@link Device} attempts\n   * a `re-register` once signaling is re-established when receiving a\n   * `connected` event from the stream.\n   */\n  private _shouldReRegister: boolean = false;\n\n  /**\n   * A Map of Sounds to play.\n   */\n  private _soundcache: Map<Device.SoundName, ISound> = new Map();\n\n  /**\n   * The current status of the {@link Device}.\n   */\n  private _state: Device.State = Device.State.Unregistered;\n\n  /**\n   * A map from {@link Device.State} to {@link Device.EventName}.\n   */\n  private readonly _stateEventMapping: Record<Device.State, Device.EventName> = {\n    [Device.State.Destroyed]: Device.EventName.Destroyed,\n    [Device.State.Unregistered]: Device.EventName.Unregistered,\n    [Device.State.Registering]: Device.EventName.Registering,\n    [Device.State.Registered]: Device.EventName.Registered,\n  };\n\n  /**\n   * The Signaling stream.\n   */\n  private _stream: IPStream | null = null;\n\n  /**\n   * A promise that will resolve when the Signaling stream is ready.\n   */\n  private _streamConnectedPromise: Promise<IPStream> | null = null;\n\n  /**\n   * The JWT string currently being used to authenticate this {@link Device}.\n   */\n  private _token: string;\n\n  /**\n   * A timeout to track when the current AccessToken will expire.\n   */\n  private _tokenWillExpireTimeout: NodeJS.Timer | null = null;\n\n  /**\n   * Construct a {@link Device} instance. The {@link Device} can be registered\n   * to make and listen for calls using {@link Device.register}.\n   * @constructor\n   * @param options\n   */\n  constructor(token: string, options: Device.Options = { }) {\n    super();\n\n    // Setup loglevel asap to avoid missed logs\n    this._setupLoglevel(options.logLevel);\n    this._logOptions('constructor', options);\n\n    this.updateToken(token);\n\n    if (isLegacyEdge()) {\n      throw new NotSupportedError(\n        'Microsoft Edge Legacy (https://support.microsoft.com/en-us/help/4533505/what-is-microsoft-edge-legacy) ' +\n        'is deprecated and will not be able to connect to Twilio to make or receive calls after September 1st, 2020. ' +\n        'Please see this documentation for a list of supported browsers ' +\n        'https://www.twilio.com/docs/voice/client/javascript#supported-browsers',\n      );\n    }\n\n    if (!Device.isSupported && (options as IExtendedDeviceOptions).ignoreBrowserSupport) {\n      if (window && window.location && window.location.protocol === 'http:') {\n        throw new NotSupportedError(`twilio.js wasn't able to find WebRTC browser support. \\\n          This is most likely because this page is served over http rather than https, \\\n          which does not support WebRTC in many browsers. Please load this page over https and \\\n          try again.`);\n      }\n\n      throw new NotSupportedError(`twilio.js 1.3+ SDKs require WebRTC browser support. \\\n        For more information, see <https://www.twilio.com/docs/api/client/twilio-js>. \\\n        If you have any questions about this announcement, please contact \\\n        Twilio Support at <help@twilio.com>.`);\n    }\n\n    const root: any = globalThis as any;\n    const browser: any = root.msBrowser || root.browser || root.chrome;\n\n    this._isBrowserExtension = (!!browser && !!browser.runtime && !!browser.runtime.id)\n      || (!!root.safari && !!root.safari.extension);\n\n    if (this._isBrowserExtension) {\n      this._log.info('Running as browser extension.');\n    }\n\n    if (navigator) {\n      const n = navigator as any;\n      this._networkInformation = n.connection\n        || n.mozConnection\n        || n.webkitConnection;\n    }\n\n    if (this._networkInformation && typeof this._networkInformation.addEventListener === 'function') {\n      this._networkInformation.addEventListener('change', this._publishNetworkChange);\n    }\n\n    Device._getOrCreateAudioContext();\n\n    if (Device._audioContext) {\n      if (!Device._dialtonePlayer) {\n        Device._dialtonePlayer = new DialtonePlayer(Device._audioContext);\n      }\n    }\n\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      Device._isUnifiedPlanDefault = typeof window !== 'undefined'\n        && typeof RTCPeerConnection !== 'undefined'\n        && typeof RTCRtpTransceiver !== 'undefined'\n      ? isUnifiedPlanDefault(window, window.navigator, RTCPeerConnection, RTCRtpTransceiver)\n      : false;\n    }\n\n    this._boundDestroy = this.destroy.bind(this);\n    this._boundConfirmClose = this._confirmClose.bind(this);\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', this._boundDestroy);\n      window.addEventListener('pagehide', this._boundDestroy);\n    }\n\n    this.updateOptions(options);\n  }\n\n  /**\n   * Return the {@link AudioHelper} used by this {@link Device}.\n   */\n  get audio(): AudioHelper | null {\n    return this._audio;\n  }\n\n  /**\n   * Make an outgoing Call.\n   * @param options\n   */\n  async connect(options: Device.ConnectOptions = { }): Promise<Call> {\n    this._log.debug('.connect', JSON.stringify(options));\n    this._throwIfDestroyed();\n    if (this._activeCall) {\n      throw new InvalidStateError('A Call is already active');\n    }\n\n    let customParameters;\n    let parameters;\n    let signalingReconnectToken;\n\n    if (options.connectToken) {\n      try {\n        const connectTokenParts = JSON.parse(decodeURIComponent(atob(options.connectToken)));\n        customParameters = connectTokenParts.customParameters;\n        parameters = connectTokenParts.parameters;\n        signalingReconnectToken = connectTokenParts.signalingReconnectToken;\n      } catch {\n        throw new InvalidArgumentError('Cannot parse connectToken');\n      }\n\n      if (!parameters || !parameters.CallSid || !signalingReconnectToken) {\n        throw new InvalidArgumentError('Invalid connectToken');\n      }\n    }\n\n    let isReconnect = false;\n    let twimlParams: Record<string, string> = {};\n    const callOptions: Call.Options = {\n      enableImprovedSignalingErrorPrecision:\n      !!this._options.enableImprovedSignalingErrorPrecision,\n      rtcConfiguration: options.rtcConfiguration,\n      voiceEventSidGenerator: this._options.voiceEventSidGenerator,\n    };\n\n    if (signalingReconnectToken && parameters) {\n      isReconnect = true;\n      callOptions.callParameters = parameters;\n      callOptions.reconnectCallSid = parameters.CallSid;\n      callOptions.reconnectToken = signalingReconnectToken;\n      twimlParams = customParameters || twimlParams;\n    } else {\n      twimlParams = options.params || twimlParams;\n    }\n\n    let activeCall;\n    this._makeCallPromise = this._makeCall(twimlParams, callOptions, isReconnect);\n    try {\n      activeCall = this._activeCall = await this._makeCallPromise;\n    } finally {\n      this._makeCallPromise = null;\n    }\n\n    // Make sure any incoming calls are ignored\n    this._calls.splice(0).forEach(call => call.ignore());\n\n    // Stop the incoming sound if it's playing\n    this._soundcache.get(Device.SoundName.Incoming).stop();\n\n    activeCall.accept({ rtcConstraints: options.rtcConstraints });\n    this._publishNetworkChange();\n    return activeCall;\n  }\n\n  /**\n   * Return the calls that this {@link Device} is maintaining.\n   */\n  get calls(): Call[] {\n    return this._calls;\n  }\n\n  /**\n   * Destroy the {@link Device}, freeing references to be garbage collected.\n   */\n  destroy(): void {\n    this._log.debug('.destroy');\n\n    this._log.debug('Rejecting any incoming calls');\n    const calls = this._calls.slice(0);\n    calls.forEach((call: Call) => call.reject());\n\n    this.disconnectAll();\n    this._stopRegistrationTimer();\n\n    this._destroyStream();\n    this._destroyPublisher();\n    this._destroyAudioHelper();\n    this._audioProcessorEventObserver?.destroy();\n\n    if (this._networkInformation && typeof this._networkInformation.removeEventListener === 'function') {\n      this._networkInformation.removeEventListener('change', this._publishNetworkChange);\n    }\n\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('beforeunload', this._boundConfirmClose);\n      window.removeEventListener('unload', this._boundDestroy);\n      window.removeEventListener('pagehide', this._boundDestroy);\n    }\n\n    this._setState(Device.State.Destroyed);\n    EventEmitter.prototype.removeAllListeners.call(this);\n  }\n\n  /**\n   * Disconnect all {@link Call}s.\n   */\n  disconnectAll(): void {\n    this._log.debug('.disconnectAll');\n    const calls = this._calls.splice(0);\n    calls.forEach((call: Call) => call.disconnect());\n\n    if (this._activeCall) {\n      this._activeCall.disconnect();\n    }\n  }\n\n  /**\n   * Returns the {@link Edge} value the {@link Device} is currently connected\n   * to. The value will be `null` when the {@link Device} is offline.\n   */\n  get edge(): string | null {\n    return this._edge;\n  }\n\n  /**\n   * Returns the home value the {@link Device} is currently connected\n   * to. The value will be `null` when the {@link Device} is offline.\n   */\n  get home(): string | null {\n    return this._home;\n  }\n\n  /**\n   * Returns the identity associated with the {@link Device} for incoming calls. Only\n   * populated when registered.\n   */\n  get identity(): string | null {\n    return this._identity;\n  }\n\n  /**\n   * Whether the Device is currently on an active Call.\n   */\n  get isBusy(): boolean {\n    return !!this._activeCall;\n  }\n\n  /**\n   * Register the `Device` to the Twilio backend, allowing it to receive calls.\n   */\n  async register(): Promise<void> {\n    this._log.debug('.register');\n    if (this.state !== Device.State.Unregistered) {\n      throw new InvalidStateError(\n        `Attempt to register when device is in state \"${this.state}\". ` +\n        `Must be \"${Device.State.Unregistered}\".`,\n      );\n    }\n\n    this._shouldReRegister = false;\n    this._setState(Device.State.Registering);\n\n    await (this._streamConnectedPromise || this._setupStream());\n    await this._sendPresence(true);\n    await promisifyEvents(this, Device.State.Registered, Device.State.Unregistered);\n  }\n\n  /**\n   * Get the state of this {@link Device} instance\n   */\n  get state(): Device.State {\n    return this._state;\n  }\n\n  /**\n   * Get the token used by this {@link Device}.\n   */\n  get token(): string | null {\n    return this._token;\n  }\n\n  /**\n   * String representation of {@link Device} instance.\n   * @private\n   */\n  toString() {\n    return '[Twilio.Device instance]';\n  }\n\n  /**\n   * Unregister the `Device` to the Twilio backend, disallowing it to receive\n   * calls.\n   */\n  async unregister(): Promise<void> {\n    this._log.debug('.unregister');\n    if (this.state !== Device.State.Registered) {\n      throw new InvalidStateError(\n        `Attempt to unregister when device is in state \"${this.state}\". ` +\n        `Must be \"${Device.State.Registered}\".`,\n      );\n    }\n\n    this._shouldReRegister = false;\n\n    const stream = await this._streamConnectedPromise;\n    const streamOfflinePromise = new Promise(resolve => {\n      stream.on('offline', resolve);\n    });\n    await this._sendPresence(false);\n    await streamOfflinePromise;\n  }\n\n  /**\n   * Set the options used within the {@link Device}.\n   * @param options\n   */\n  updateOptions(options: Device.Options = { }): void {\n    this._logOptions('updateOptions', options);\n    if (this.state === Device.State.Destroyed) {\n      throw new InvalidStateError(\n        `Attempt to \"updateOptions\" when device is in state \"${this.state}\".`,\n      );\n    }\n\n    this._options = { ...this._defaultOptions, ...this._options, ...options };\n\n    const originalChunderURIs: Set<string> = new Set(this._chunderURIs);\n\n    const chunderw = typeof this._options.chunderw === 'string'\n      ? [this._options.chunderw]\n      : Array.isArray(this._options.chunderw) && this._options.chunderw;\n\n    const newChunderURIs = this._chunderURIs = (\n      chunderw || getChunderURIs(this._options.edge)\n    ).map(createSignalingEndpointURL);\n\n    let hasChunderURIsChanged =\n      originalChunderURIs.size !== newChunderURIs.length;\n\n    if (!hasChunderURIsChanged) {\n      for (const uri of newChunderURIs) {\n        if (!originalChunderURIs.has(uri)) {\n          hasChunderURIsChanged = true;\n          break;\n        }\n      }\n    }\n\n    if (this.isBusy && hasChunderURIsChanged) {\n      throw new InvalidStateError('Cannot change Edge while on an active Call');\n    }\n\n    this._setupLoglevel(this._options.logLevel);\n\n    for (const name of Object.keys(Device._defaultSounds)) {\n      const soundDef: ISoundDefinition = Device._defaultSounds[name];\n\n      const defaultUrl: string = `${C.SOUNDS_BASE_URL}/${soundDef.filename}.${Device.extension}`\n        + `?cache=${C.RELEASE_VERSION}`;\n\n      const soundUrl: string = this._options.sounds && this._options.sounds[name as Device.SoundName] || defaultUrl;\n      const sound: any = new (this._options.Sound || Sound)(name, soundUrl, {\n        audioContext: this._options.disableAudioContextSounds ? null : Device.audioContext,\n        maxDuration: soundDef.maxDuration,\n        shouldLoop: soundDef.shouldLoop,\n      });\n\n      this._soundcache.set(name as Device.SoundName, sound);\n    }\n\n    this._setupAudioHelper();\n    this._setupPublisher();\n\n    if (hasChunderURIsChanged && this._streamConnectedPromise) {\n      this._setupStream();\n    }\n\n    // Setup close protection and make sure we clean up ongoing calls on unload.\n    if (\n      typeof window !== 'undefined' &&\n      typeof window.addEventListener === 'function' &&\n      this._options.closeProtection\n    ) {\n      window.removeEventListener('beforeunload', this._boundConfirmClose);\n      window.addEventListener('beforeunload', this._boundConfirmClose);\n    }\n  }\n\n  /**\n   * Update the token used by this {@link Device} to connect to Twilio.\n   * It is recommended to call this API after [[Device.tokenWillExpireEvent]] is emitted,\n   * and before or after a call to prevent a potential ~1s audio loss during the update process.\n   * @param token\n   */\n  updateToken(token: string) {\n    this._log.debug('.updateToken');\n    if (this.state === Device.State.Destroyed) {\n      throw new InvalidStateError(\n        `Attempt to \"updateToken\" when device is in state \"${this.state}\".`,\n      );\n    }\n\n    if (typeof token !== 'string') {\n      throw new InvalidArgumentError(INVALID_TOKEN_MESSAGE);\n    }\n\n    this._token = token;\n\n    if (this._stream) {\n      this._stream.setToken(this._token);\n    }\n\n    if (this._publisher) {\n      this._publisher.setToken(this._token);\n    }\n  }\n\n  /**\n   * Called on window's beforeunload event if closeProtection is enabled,\n   * preventing users from accidentally navigating away from an active call.\n   * @param event\n   */\n  private _confirmClose(event: any): string {\n    if (!this._activeCall) { return ''; }\n\n    const closeProtection: boolean | string = this._options.closeProtection || false;\n    const confirmationMsg: string = typeof closeProtection !== 'string'\n      ? 'A call is currently in-progress. Leaving or reloading this page will end the call.'\n      : closeProtection;\n\n    (event || window.event).returnValue = confirmationMsg;\n    return confirmationMsg;\n  }\n\n  /**\n   * Create the default Insights payload\n   * @param call\n   */\n  private _createDefaultPayload = (call?: Call): Record<string, any> => {\n    const payload: Record<string, any> = {\n      aggressive_nomination: this._options.forceAggressiveIceNomination,\n      browser_extension: this._isBrowserExtension,\n      dscp: !!this._options.dscp,\n      ice_restart_enabled: true,\n      platform: rtc.getMediaEngine(),\n      sdk_version: C.RELEASE_VERSION,\n    };\n\n    function setIfDefined(propertyName: string, value: string | undefined | null) {\n      if (value) { payload[propertyName] = value; }\n    }\n\n    if (call) {\n      const callSid = call.parameters.CallSid;\n      setIfDefined('call_sid', /^TJ/.test(callSid) ? undefined : callSid);\n      setIfDefined('temp_call_sid', call.outboundConnectionId);\n      setIfDefined('audio_codec', call.codec);\n      payload.direction = call.direction;\n    }\n\n    setIfDefined('gateway', this._stream && this._stream.gateway);\n    setIfDefined('region', this._stream && this._stream.region);\n\n    return payload;\n  }\n\n  /**\n   * Destroy the AudioHelper.\n   */\n  private _destroyAudioHelper() {\n    if (!this._audio) { return; }\n    this._audio._destroy();\n    this._audio = null;\n  }\n\n  /**\n   * Destroy the publisher.\n   */\n  private _destroyPublisher() {\n    // Attempt to destroy non-existent publisher.\n    if (!this._publisher) { return; }\n\n    this._publisher = null;\n  }\n\n  /**\n   * Destroy the connection to the signaling server.\n   */\n  private _destroyStream() {\n    if (this._stream) {\n      this._stream.removeListener('close', this._onSignalingClose);\n      this._stream.removeListener('connected', this._onSignalingConnected);\n      this._stream.removeListener('error', this._onSignalingError);\n      this._stream.removeListener('invite', this._onSignalingInvite);\n      this._stream.removeListener('offline', this._onSignalingOffline);\n      this._stream.removeListener('ready', this._onSignalingReady);\n\n      this._stream.destroy();\n      this._stream = null;\n    }\n\n    this._onSignalingOffline();\n\n    this._streamConnectedPromise = null;\n  }\n\n  /**\n   * Find a {@link Call} by its CallSid.\n   * @param callSid\n   */\n  private _findCall(callSid: string): Call | null {\n    return this._calls.find(call => call.parameters.CallSid === callSid\n      || call.outboundConnectionId === callSid) || null;\n  }\n\n  /**\n   * Utility function to log device options\n   */\n  private _logOptions(caller: string, options: Device.Options = { }): void {\n    // Selectively log options that users can modify.\n    // Also, convert user overrides.\n    // This prevents potential app crash when calling JSON.stringify\n    // and when sending log strings remotely\n    const userOptions = [\n      'allowIncomingWhileBusy',\n      'appName',\n      'appVersion',\n      'closeProtection',\n      'codecPreferences',\n      'disableAudioContextSounds',\n      'dscp',\n      'edge',\n      'enableImprovedSignalingErrorPrecision',\n      'forceAggressiveIceNomination',\n      'logLevel',\n      'maxAverageBitrate',\n      'maxCallSignalingTimeoutMs',\n      'sounds',\n      'tokenRefreshMs',\n    ];\n    const userOptionOverrides = [\n      'RTCPeerConnection',\n      'enumerateDevices',\n      'getUserMedia',\n    ];\n    if (typeof options === 'object') {\n      const toLog: any = { ...options };\n      Object.keys(toLog).forEach((key: string) => {\n        if (!userOptions.includes(key) && !userOptionOverrides.includes(key)) {\n          delete toLog[key];\n        }\n        if (userOptionOverrides.includes(key)) {\n          toLog[key] = true;\n        }\n      });\n      this._log.debug(`.${caller}`, JSON.stringify(toLog));\n    }\n  }\n\n  /**\n   * Create a new {@link Call}.\n   * @param twimlParams - A flat object containing key:value pairs to be sent to the TwiML app.\n   * @param options - Options to be used to instantiate the {@link Call}.\n   */\n  private async _makeCall(twimlParams: Record<string, string>, options?: Call.Options, isReconnect: boolean = false): Promise<Call> {\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      throw new InvalidStateError('Device has not been initialized.');\n    }\n\n    // Wait for the input device if it's set by the user\n    const inputDevicePromise = this._audio?._getInputDevicePromise();\n    if (inputDevicePromise) {\n      this._log.debug('inputDevicePromise detected, waiting...');\n      await inputDevicePromise;\n      this._log.debug('inputDevicePromise resolved');\n    }\n\n    const config: Call.Config = {\n      audioHelper: this._audio,\n      isUnifiedPlanDefault: Device._isUnifiedPlanDefault,\n      onIgnore: (): void => {\n        this._soundcache.get(Device.SoundName.Incoming).stop();\n      },\n      pstream: await (this._streamConnectedPromise || this._setupStream()),\n      publisher: this._publisher,\n      soundcache: this._soundcache,\n    };\n\n    options = Object.assign({\n      MediaStream: this._options.MediaStream || rtc.PeerConnection,\n      RTCPeerConnection: this._options.RTCPeerConnection,\n      beforeAccept: (currentCall: Call) => {\n        if (!this._activeCall || this._activeCall === currentCall) {\n          return;\n        }\n\n        this._activeCall.disconnect();\n        this._removeCall(this._activeCall);\n      },\n      codecPreferences: this._options.codecPreferences,\n      customSounds: this._options.sounds,\n      dialtonePlayer: Device._dialtonePlayer,\n      dscp: this._options.dscp,\n      // TODO(csantos): Remove forceAggressiveIceNomination option in 3.x\n      forceAggressiveIceNomination: this._options.forceAggressiveIceNomination,\n      getInputStream: (): MediaStream | null => this._options.fileInputStream || this._callInputStream,\n      getSinkIds: (): string[] => this._callSinkIds,\n      maxAverageBitrate: this._options.maxAverageBitrate,\n      preflight: this._options.preflight,\n      rtcConstraints: this._options.rtcConstraints,\n      shouldPlayDisconnect: () => this._audio?.disconnect(),\n      twimlParams,\n      voiceEventSidGenerator: this._options.voiceEventSidGenerator,\n    }, options);\n\n    const maybeUnsetPreferredUri = () => {\n      if (!this._stream) {\n        this._log.warn('UnsetPreferredUri called without a stream');\n        return;\n      }\n      if (this._activeCall === null && this._calls.length === 0) {\n        this._stream.updatePreferredURI(null);\n      }\n    };\n\n    const call = new (this._options.Call || Call)(config, options);\n\n    this._publisher.info('settings', 'init', {\n      RTCPeerConnection: !!this._options.RTCPeerConnection,\n      enumerateDevices: !!this._options.enumerateDevices,\n      getUserMedia: !!this._options.getUserMedia,\n    }, call);\n\n    call.once('accept', () => {\n      this._stream.updatePreferredURI(this._preferredURI);\n      this._removeCall(call);\n      this._activeCall = call;\n      if (this._audio) {\n        this._audio._maybeStartPollingVolume();\n      }\n\n      if (call.direction === Call.CallDirection.Outgoing && this._audio?.outgoing() && !isReconnect) {\n        this._soundcache.get(Device.SoundName.Outgoing).play();\n      }\n\n      const data: any = { edge: this._edge || this._region };\n      if (this._options.edge) {\n        data['selected_edge'] = Array.isArray(this._options.edge)\n          ? this._options.edge\n          : [this._options.edge];\n      }\n\n      this._publisher.info('settings', 'edge', data, call);\n\n      if (this._audio?.processedStream) {\n        this._audioProcessorEventObserver?.emit('enabled');\n      }\n    });\n\n    call.addListener('error', (error: TwilioError) => {\n      if (call.status() === 'closed') {\n        this._removeCall(call);\n        maybeUnsetPreferredUri();\n      }\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._maybeStopIncomingSound();\n    });\n\n    call.once('cancel', () => {\n      this._log.info(`Canceled: ${call.parameters.CallSid}`);\n      this._removeCall(call);\n      maybeUnsetPreferredUri();\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._maybeStopIncomingSound();\n    });\n\n    call.once('disconnect', () => {\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._removeCall(call);\n      maybeUnsetPreferredUri();\n      /**\n       * NOTE(kamalbennani): We need to stop the incoming sound when the call is\n       * disconnected right after the user has accepted the call (activeCall.accept()), and before\n       * the call has been fully connected (i.e. before the `pstream.answer` event)\n       */\n      this._maybeStopIncomingSound();\n    });\n\n    call.once('reject', () => {\n      this._log.info(`Rejected: ${call.parameters.CallSid}`);\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._removeCall(call);\n      maybeUnsetPreferredUri();\n      this._maybeStopIncomingSound();\n    });\n\n    call.on('transportClose', () => {\n      if (call.status() !== Call.State.Pending) {\n        return;\n      }\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._removeCall(call);\n      /**\n       * NOTE(mhuynh): We don't want to call `maybeUnsetPreferredUri` because\n       * a `transportClose` will happen during signaling reconnection.\n       */\n      this._maybeStopIncomingSound();\n    });\n\n    return call;\n  }\n\n  /**\n   * Stop the incoming sound if no {@link Call}s remain.\n   */\n  private _maybeStopIncomingSound(): void {\n    if (!this._calls.length) {\n      this._soundcache.get(Device.SoundName.Incoming).stop();\n    }\n  }\n\n  /**\n   * Called when a 'close' event is received from the signaling stream.\n   */\n  private _onSignalingClose = () => {\n    this._stream = null;\n    this._streamConnectedPromise = null;\n  }\n\n  /**\n   * Called when a 'connected' event is received from the signaling stream.\n   */\n  private _onSignalingConnected = (payload: Record<string, any>) => {\n    const region = getRegionShortcode(payload.region);\n    this._edge = payload.edge || regionToEdge[region as Region] || payload.region;\n    this._region = region || payload.region;\n    this._home = payload.home;\n    this._publisher?.setHost(createEventGatewayURI(payload.home));\n\n    if (payload.token) {\n      this._identity = payload.token.identity;\n      if (\n        typeof payload.token.ttl === 'number' &&\n        typeof this._options.tokenRefreshMs === 'number'\n      ) {\n        const ttlMs: number = payload.token.ttl * 1000;\n        const timeoutMs: number = Math.max(0, ttlMs - this._options.tokenRefreshMs);\n        this._tokenWillExpireTimeout = setTimeout(() => {\n          this._log.debug('#tokenWillExpire');\n          this.emit('tokenWillExpire', this);\n          if (this._tokenWillExpireTimeout) {\n            clearTimeout(this._tokenWillExpireTimeout);\n            this._tokenWillExpireTimeout = null;\n          }\n        }, timeoutMs);\n      }\n    }\n\n    const preferredURIs = getChunderURIs(this._edge as Edge);\n    if (preferredURIs.length > 0) {\n      const [preferredURI] = preferredURIs;\n      this._preferredURI = createSignalingEndpointURL(preferredURI);\n    } else {\n      this._log.warn('Could not parse a preferred URI from the stream#connected event.');\n    }\n\n    // The signaling stream emits a `connected` event after reconnection, if the\n    // device was registered before this, then register again.\n    if (this._shouldReRegister) {\n      this.register();\n    }\n  }\n\n  /**\n   * Called when an 'error' event is received from the signaling stream.\n   */\n  private _onSignalingError = (payload: Record<string, any>) => {\n    if (typeof payload !== 'object') {\n      this._log.warn('Invalid signaling error payload', payload);\n      return;\n    }\n\n    const { error: originalError, callsid, voiceeventsid } = payload;\n\n    // voiceeventsid is for call message events which are handled in the call object\n    // missing originalError shouldn't be possible but check here to fail properly\n    if (typeof originalError !== 'object' || !!voiceeventsid) {\n      this._log.warn('Ignoring signaling error payload', { originalError, voiceeventsid });\n      return;\n    }\n\n    const call: Call | undefined =\n      (typeof callsid === 'string' && this._findCall(callsid)) || undefined;\n\n    const { code, message: customMessage } = originalError;\n    let { twilioError } = originalError;\n\n    if (typeof code === 'number') {\n      if (code === 31201) {\n        twilioError = new AuthorizationErrors.AuthenticationFailed(originalError);\n      } else if (code === 31204) {\n        twilioError = new AuthorizationErrors.AccessTokenInvalid(originalError);\n      } else if (code === 31205) {\n        // Stop trying to register presence after token expires\n        this._stopRegistrationTimer();\n        twilioError = new AuthorizationErrors.AccessTokenExpired(originalError);\n      } else {\n        const errorConstructor = getPreciseSignalingErrorByCode(\n          !!this._options.enableImprovedSignalingErrorPrecision,\n          code,\n        );\n        if (typeof errorConstructor !== 'undefined') {\n          twilioError = new errorConstructor(originalError);\n        }\n      }\n    }\n\n    if (!twilioError) {\n      this._log.error('Unknown signaling error: ', originalError);\n      twilioError = new GeneralErrors.UnknownError(customMessage, originalError);\n    }\n\n    this._log.error('Received error: ', twilioError);\n    this._log.debug('#error', originalError);\n    this.emit(Device.EventName.Error, twilioError, call);\n  }\n\n  /**\n   * Called when an 'invite' event is received from the signaling stream.\n   */\n  private _onSignalingInvite = async (payload: Record<string, any>) => {\n    const wasBusy = !!this._activeCall;\n    if (wasBusy && !this._options.allowIncomingWhileBusy) {\n      this._log.info('Device busy; ignoring incoming invite');\n      return;\n    }\n\n    if (!payload.callsid || !payload.sdp) {\n      this._log.debug('#error', payload);\n      this.emit(Device.EventName.Error, new ClientErrors.BadRequest('Malformed invite from gateway'));\n      return;\n    }\n\n    const callParameters = payload.parameters || { };\n    callParameters.CallSid = callParameters.CallSid || payload.callsid;\n\n    const customParameters = Object.assign({ }, queryToJson(callParameters.Params));\n\n    this._makeCallPromise = this._makeCall(\n      customParameters,\n      {\n        callParameters,\n        enableImprovedSignalingErrorPrecision:\n          !!this._options.enableImprovedSignalingErrorPrecision,\n        offerSdp: payload.sdp,\n        reconnectToken: payload.reconnect,\n        voiceEventSidGenerator: this._options.voiceEventSidGenerator,\n      },\n    );\n\n    let call;\n    try {\n      call = await this._makeCallPromise;\n    } finally {\n      this._makeCallPromise = null;\n    }\n\n    this._calls.push(call);\n\n    call.once('accept', () => {\n      this._soundcache.get(Device.SoundName.Incoming).stop();\n      this._publishNetworkChange();\n    });\n\n    const play = (this._audio?.incoming() && !wasBusy)\n      ? () => this._soundcache.get(Device.SoundName.Incoming).play()\n      : () => Promise.resolve();\n\n    this._showIncomingCall(call, play);\n  }\n\n  /**\n   * Called when an 'offline' event is received from the signaling stream.\n   */\n  private _onSignalingOffline = () => {\n    this._log.info('Stream is offline');\n\n    this._edge = null;\n    this._region = null;\n\n    this._shouldReRegister = this.state !== Device.State.Unregistered;\n\n    this._setState(Device.State.Unregistered);\n  }\n\n  /**\n   * Called when a 'ready' event is received from the signaling stream.\n   */\n  private _onSignalingReady = () => {\n    this._log.info('Stream is ready');\n\n    this._setState(Device.State.Registered);\n  }\n\n  /**\n   * Publish a NetworkInformation#change event to Insights if there's an active {@link Call}.\n   */\n  private _publishNetworkChange = () => {\n    if (!this._activeCall) {\n      return;\n    }\n\n    if (this._networkInformation) {\n      this._publisher.info('network-information', 'network-change', {\n        connection_type: this._networkInformation.type,\n        downlink: this._networkInformation.downlink,\n        downlinkMax: this._networkInformation.downlinkMax,\n        effective_type: this._networkInformation.effectiveType,\n        rtt: this._networkInformation.rtt,\n      }, this._activeCall);\n    }\n  }\n\n  /**\n   * Remove a {@link Call} from device.calls by reference\n   * @param call\n   */\n  private _removeCall(call: Call): void {\n    if (this._activeCall === call) {\n      this._activeCall = null;\n      this._makeCallPromise = null;\n    }\n\n    for (let i = this._calls.length - 1; i >= 0; i--) {\n      if (call === this._calls[i]) {\n        this._calls.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Register with the signaling server.\n   */\n  private async _sendPresence(presence: boolean): Promise<void> {\n    const stream = await this._streamConnectedPromise;\n\n    if (!stream) { return; }\n\n    stream.register({ audio: presence });\n    if (presence) {\n      this._startRegistrationTimer();\n    } else {\n      this._stopRegistrationTimer();\n    }\n  }\n\n  /**\n   * Helper function that sets and emits the state of the device.\n   * @param state The new state of the device.\n   */\n   private _setState(state: Device.State): void {\n    if (state === this.state) {\n      return;\n    }\n\n    this._state = state;\n    const name = this._stateEventMapping[state];\n    this._log.debug(`#${name}`);\n    this.emit(name);\n  }\n\n  /**\n   * Set up an audio helper for usage by this {@link Device}.\n   */\n  private _setupAudioHelper(): void {\n    if (!this._audioProcessorEventObserver) {\n      this._audioProcessorEventObserver = new AudioProcessorEventObserver();\n      this._audioProcessorEventObserver.on('event', ({ name, group }) => {\n        this._publisher.info(group, name, {}, this._activeCall);\n      });\n    }\n\n    const audioOptions: AudioHelper.Options = {\n      audioContext: Device.audioContext,\n      audioProcessorEventObserver: this._audioProcessorEventObserver,\n      beforeSetInputDevice: () => {\n        if (this._makeCallPromise) {\n          this._log.debug('beforeSetInputDevice pause detected');\n          return this._makeCallPromise;\n        } else {\n          this._log.debug('beforeSetInputDevice pause not detected, setting default');\n          return Promise.resolve();\n        }\n      },\n      enumerateDevices: this._options.enumerateDevices,\n      getUserMedia: this._options.getUserMedia || getUserMedia,\n    };\n\n    if (this._audio) {\n      this._log.info('Found existing audio helper; updating options...');\n      this._audio._updateUserOptions(audioOptions);\n      return;\n    }\n\n    this._audio = new (this._options.AudioHelper || AudioHelper)(\n      this._updateSinkIds,\n      this._updateInputStream,\n      audioOptions,\n    );\n\n    this._audio.on('deviceChange', (lostActiveDevices: MediaDeviceInfo[]) => {\n      const activeCall: Call | null = this._activeCall;\n      const deviceIds: string[] = lostActiveDevices.map((device: MediaDeviceInfo) => device.deviceId);\n\n      this._publisher.info('audio', 'device-change', {\n        lost_active_device_ids: deviceIds,\n      }, activeCall);\n\n      if (activeCall) {\n        activeCall['_mediaHandler']._onInputDevicesChanged();\n      }\n    });\n  }\n\n  /**\n   * Setup logger's loglevel\n   */\n  private _setupLoglevel(logLevel?: LogLevelDesc): void {\n    const level = typeof logLevel === 'number' ||\n      typeof logLevel === 'string' ?\n      logLevel : LogLevels.ERROR;\n\n    this._log.setDefaultLevel(level);\n    this._log.info('Set logger default level to', level);\n  }\n\n  /**\n   * Create and set a publisher for the {@link Device} to use.\n   */\n  private _setupPublisher(): IPublisher {\n    if (this._publisher) {\n      this._log.info('Found existing publisher; destroying...');\n      this._destroyPublisher();\n    }\n\n    const publisherOptions = {\n      defaultPayload: this._createDefaultPayload,\n      metadata: {\n        app_name: this._options.appName,\n        app_version: this._options.appVersion,\n      },\n    } as any;\n\n    if (this._options.eventgw) {\n      publisherOptions.host = this._options.eventgw;\n    }\n\n    if (this._home) {\n      publisherOptions.host = createEventGatewayURI(this._home);\n    }\n\n    this._publisher = new (this._options.Publisher || Publisher)(PUBLISHER_PRODUCT_NAME, this.token, publisherOptions);\n\n    if (this._options.publishEvents === false) {\n      this._publisher.disable();\n    } else {\n      this._publisher.on('error', (error: Error) => {\n        this._log.warn('Cannot connect to insights.', error);\n      });\n    }\n\n    return this._publisher;\n  }\n\n  /**\n   * Set up the connection to the signaling server. Tears down an existing\n   * stream if called while a stream exists.\n   */\n  private _setupStream(): Promise<IPStream> {\n    if (this._stream) {\n      this._log.info('Found existing stream; destroying...');\n      this._destroyStream();\n    }\n\n    this._log.info('Setting up VSP');\n    this._stream = new (this._options.PStream || PStream)(\n      this.token,\n      this._chunderURIs,\n      {\n        backoffMaxMs: this._options.backoffMaxMs,\n        maxPreferredDurationMs: this._options.maxCallSignalingTimeoutMs,\n      },\n    );\n\n    this._stream.addListener('close', this._onSignalingClose);\n    this._stream.addListener('connected', this._onSignalingConnected);\n    this._stream.addListener('error', this._onSignalingError);\n    this._stream.addListener('invite', this._onSignalingInvite);\n    this._stream.addListener('offline', this._onSignalingOffline);\n    this._stream.addListener('ready', this._onSignalingReady);\n\n    return this._streamConnectedPromise =\n      promisifyEvents(this._stream, 'connected', 'close').then(() => this._stream);\n  }\n\n  /**\n   * Start playing the incoming ringtone, and subsequently emit the incoming event.\n   * @param call\n   * @param play - The function to be used to play the sound. Must return a Promise.\n   */\n  private _showIncomingCall(call: Call, play: Function): Promise<void> {\n    let timeout: NodeJS.Timer;\n    return Promise.race([\n      play(),\n      new Promise((resolve, reject) => {\n        timeout = setTimeout(() => {\n          const msg = 'Playing incoming ringtone took too long; it might not play. Continuing execution...';\n          reject(new Error(msg));\n        }, RINGTONE_PLAY_TIMEOUT);\n      }),\n    ]).catch(reason => {\n      this._log.warn(reason.message);\n    }).then(() => {\n      clearTimeout(timeout);\n      this._log.debug('#incoming', JSON.stringify({\n        customParameters: call.customParameters,\n        parameters: call.parameters,\n      }));\n      this.emit(Device.EventName.Incoming, call);\n    });\n  }\n\n  /**\n   * Set a timeout to send another register message to the signaling server.\n   */\n  private _startRegistrationTimer(): void {\n    this._stopRegistrationTimer();\n    this._regTimer = setTimeout(() => {\n      this._sendPresence(true);\n    }, REGISTRATION_INTERVAL);\n  }\n\n  /**\n   * Stop sending registration messages to the signaling server.\n   */\n  private _stopRegistrationTimer(): void {\n    if (this._regTimer) {\n      clearTimeout(this._regTimer);\n    }\n  }\n\n  /**\n   * Throw an error if the {@link Device} is destroyed.\n   */\n  private _throwIfDestroyed(): void {\n    if (this.state === Device.State.Destroyed) {\n      throw new InvalidStateError('Device has been destroyed.');\n    }\n  }\n\n  /**\n   * Update the input stream being used for calls so that any current call and all future calls\n   * will use the new input stream.\n   * @param inputStream\n   */\n  private _updateInputStream = (inputStream: MediaStream | null): Promise<void> => {\n    const call: Call | null = this._activeCall;\n\n    if (call && !inputStream) {\n      return Promise.reject(new InvalidStateError('Cannot unset input device while a call is in progress.'));\n    }\n\n    this._callInputStream = inputStream;\n    return call\n      ? call._setInputTracksFromStream(inputStream)\n      : Promise.resolve();\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play the incoming ringtone through.\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateRingtoneSinkIds(sinkIds: string[]): Promise<void> {\n    return Promise.resolve(this._soundcache.get(Device.SoundName.Incoming).setSinkIds(sinkIds));\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play sounds through.\n   * @param type - Whether to update ringtone or speaker sounds\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateSinkIds = (type: 'ringtone' | 'speaker', sinkIds: string[]): Promise<void> => {\n    const promise: Promise<void> = type === 'ringtone'\n      ? this._updateRingtoneSinkIds(sinkIds)\n      : this._updateSpeakerSinkIds(sinkIds);\n\n    return promise.then(() => {\n      this._publisher.info('audio', `${type}-devices-set`, {\n        audio_device_ids: sinkIds,\n      }, this._activeCall);\n    }, error => {\n      this._publisher.error('audio', `${type}-devices-set-failed`, {\n        audio_device_ids: sinkIds,\n        message: error.message,\n      }, this._activeCall);\n\n      throw error;\n    });\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play the non-ringtone sounds\n   * and Call audio through.\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateSpeakerSinkIds(sinkIds: string[]): Promise<void> {\n    Array.from(this._soundcache.entries())\n      .filter(entry => entry[0] !== Device.SoundName.Incoming)\n      .forEach(entry => entry[1].setSinkIds(sinkIds));\n\n    this._callSinkIds = sinkIds;\n    const call = this._activeCall;\n    return call\n      ? call._setSinkIds(sinkIds)\n      : Promise.resolve();\n  }\n}\n\nnamespace Device {\n  /**\n   * Emitted when the {@link Device} has been destroyed.\n   * @example `device.on('destroyed', () => { })`\n   * @event\n   */\n  declare function destroyedEvent(): void;\n\n  /**\n   * Emitted when the {@link Device} receives an error.\n   * @param error\n   * @example `device.on('error', call => { })`\n   * @event\n   */\n  declare function errorEvent(error: TwilioError, call?: Call): void;\n\n  /**\n   * Emitted when an incoming {@link Call} is received. You can interact with the call object\n   * using its public APIs, or you can forward it to a different {@link Device} using\n   * {@link Device.connect} and {@link Call.connectToken}, enabling your application to\n   * receive multiple incoming calls for the same identity.\n   *\n   * **Important:** When forwarding a call, the token for target device instance needs to have\n   * the same identity as the token used in the device that originally received the call.\n   *\n   * @example\n   *\n   * ```js\n   * const receiverDevice = new Device(token, options);\n   * await receiverDevice.register();\n   *\n   * receiverDevice.on('incoming', (call) => {\n   *   // Forward this call to a new Device instance using the call.connectToken string.\n   *   forwardCall(call.connectToken);\n   * });\n   *\n   * // The forwardCall function may look something like the following.\n   * async function forwardCall(connectToken) {\n   *   // For every incoming call, we create a new Device instance which we can\n   *   // interact with, without affecting other calls.\n   *   // IMPORTANT: The token for this new device needs to have the same identity\n   *   // as the token used in the receiverDevice.\n   *   const device = new Device(token, options);\n   *   const call = await device.connect({ connectToken });\n   *\n   *   // Destroy the device after the call is completed\n   *   call.on('disconnect', () => device.destroy());\n   * }\n   * ```\n   *\n   * @param call - The incoming {@link Call}.\n   * @event\n   */\n  declare function incomingEvent(call: Call): void;\n\n  /**\n   * Emitted when the {@link Device} is unregistered.\n   * @example `device.on('unregistered', () => { })`\n   * @event\n   */\n  declare function unregisteredEvent(): void;\n\n  /**\n   * Emitted when the {@link Device} is registering.\n   * @example `device.on('registering', () => { })`\n   * @event\n   */\n  declare function registeringEvent(): void;\n\n  /**\n   * Emitted when the {@link Device} is registered.\n   * @example `device.on('registered', () => { })`\n   * @event\n   */\n  declare function registeredEvent(): void;\n\n  /**\n   * Emitted when the {@link Device}'s token is about to expire. Use DeviceOptions.refreshTokenMs\n   * to set a custom warning time. Default is 10000 (10 seconds) prior to the token expiring.\n   * @param device\n   * @example `device.on('tokenWillExpire', device => {\n   *   const token = getNewTokenViaAjax();\n   *   device.updateToken(token);\n   * })`\n   * @event\n   */\n  declare function tokenWillExpireEvent(device: Device): void;\n\n  /**\n   * All valid {@link Device} event names.\n   */\n  export enum EventName {\n    Error = 'error',\n    Incoming = 'incoming',\n    Destroyed = 'destroyed',\n    Unregistered = 'unregistered',\n    Registering = 'registering',\n    Registered = 'registered',\n    TokenWillExpire = 'tokenWillExpire',\n  }\n\n  /**\n   * All possible {@link Device} states.\n   */\n  export enum State {\n    Destroyed = 'destroyed',\n    Unregistered = 'unregistered',\n    Registering = 'registering',\n    Registered = 'registered',\n  }\n\n  /**\n   * Names of all sounds handled by the {@link Device}.\n   */\n  export enum SoundName {\n    Incoming = 'incoming',\n    Outgoing = 'outgoing',\n    Disconnect = 'disconnect',\n    Dtmf0 = 'dtmf0',\n    Dtmf1 = 'dtmf1',\n    Dtmf2 = 'dtmf2',\n    Dtmf3 = 'dtmf3',\n    Dtmf4 = 'dtmf4',\n    Dtmf5 = 'dtmf5',\n    Dtmf6 = 'dtmf6',\n    Dtmf7 = 'dtmf7',\n    Dtmf8 = 'dtmf8',\n    Dtmf9 = 'dtmf9',\n    DtmfS = 'dtmfs',\n    DtmfH = 'dtmfh',\n  }\n\n  /**\n   * Names of all togglable sounds.\n   */\n  export type ToggleableSound = Device.SoundName.Incoming | Device.SoundName.Outgoing | Device.SoundName.Disconnect;\n\n  /**\n   * Options to be passed to {@link Device.connect}.\n   */\n  export interface ConnectOptions extends Call.AcceptOptions {\n    /**\n     * The {@link Call.connectToken} to use to manually reconnect to an existing call.\n     * A call can be manually reconnected if it was previously received (incoming)\n     * or created (outgoing) from a {@link Device} instance.\n     * A call is considered manually reconnected if it was created using the {@link Call.connectToken}.\n     * It will always have a {@link Call.direction} property set to {@link Call.CallDirection.Outgoing}.\n     *\n     * **Warning: Only unanswered incoming calls can be manually reconnected at this time.**\n     * **Invoking this method to an already answered call may introduce unexpected behavior.**\n     *\n     * See {@link Device.incomingEvent} for an example.\n     */\n    connectToken?: string;\n\n    /**\n     * A flat object containing key:value pairs to be sent to the TwiML app.\n     */\n    params?: Record<string, string>;\n  }\n\n  /**\n   * Options that may be passed to the {@link Device} constructor, or Device.setup via public API\n   */\n  export interface Options {\n    /**\n     * Whether the Device should raise the {@link incomingEvent} event when a new call invite is\n     * received while already on an active call. Default behavior is false.\n     */\n    allowIncomingWhileBusy?: boolean;\n\n    /**\n     * A name for the application that is instantiating the {@link Device}. This is used to improve logging\n     * in Insights by associating Insights data with a specific application, particularly in the case where\n     * one account may be connected to by multiple applications.\n     */\n    appName?: string;\n\n    /**\n     * A version for the application that is instantiating the {@link Device}. This is used to improve logging\n     * in Insights by associating Insights data with a specific version of the given application. This can help\n     * track down when application-level bugs were introduced.\n     */\n    appVersion?: string;\n\n    /**\n     * Whether to enable close protection, to prevent users from accidentally\n     * navigating away from the page during a call. If string, the value will\n     * be used as a custom message.\n     */\n    closeProtection?: boolean | string;\n\n    /**\n     * An ordered array of codec names, from most to least preferred.\n     */\n    codecPreferences?: Call.Codec[];\n\n    /**\n     * Whether AudioContext sounds should be disabled. Useful for trouble shooting sound issues\n     * that may be caused by AudioContext-specific sounds. If set to true, will fall back to\n     * HTMLAudioElement sounds.\n     */\n    disableAudioContextSounds?: boolean;\n\n    /**\n     * Whether to use googDscp in RTC constraints.\n     */\n    dscp?: boolean;\n\n    /**\n     * The edge value corresponds to the geographic location that the client\n     * will use to connect to Twilio infrastructure. The default value is\n     * \"roaming\" which automatically selects an edge based on the latency of the\n     * client relative to available edges.\n     */\n    edge?: string[] | string;\n\n    /**\n     * Enhance the precision of errors emitted by `Device` and `Call` objects.\n     *\n     * The default value of this option is `false`.\n     *\n     * When this flag is enabled, some errors that would have been described\n     * with a generic error code, namely `53000` and `31005`, are now described\n     * with a more precise error code. With this feature, the following errors\n     * now have their own error codes. Please see this\n     * [page](https://www.twilio.com/docs/api/errors) for more details about\n     * each error.\n     *\n     * - Device Error Changes\n     *\n     * @example\n     * ```ts\n     * const device = new Device(token, {\n     *   enableImprovedSignalingErrorPrecision: true,\n     * });\n     * device.on('error', (deviceError) => {\n     *   // the following table describes how deviceError will change with this feature flag\n     * });\n     * ```\n     *\n     * | Device Error Name | Device Error Code with Feature Flag Enabled | Device Error Code with Feature Flag Disabled |\n     * | --- | --- | --- |\n     * | `GeneralErrors.ApplicationNotFoundError` | `31001` | `53000` |\n     * | `GeneralErrors.ConnectionDeclinedError` | `31002` | `53000` |\n     * | `GeneralErrors.ConnectionTimeoutError` | `31003` | `53000` |\n     * | `MalformedRequestErrors.MissingParameterArrayError` | `31101` | `53000` |\n     * | `MalformedRequestErrors.AuthorizationTokenMissingError` | `31102` | `53000` |\n     * | `MalformedRequestErrors.MaxParameterLengthExceededError` | `31103` | `53000` |\n     * | `MalformedRequestErrors.InvalidBridgeTokenError` | `31104` | `53000` |\n     * | `MalformedRequestErrors.InvalidClientNameError` | `31105` | `53000` |\n     * | `MalformedRequestErrors.ReconnectParameterInvalidError` | `31107` | `53000` |\n     * | `SignatureValidationErrors.AccessTokenSignatureValidationFailed` | `31202` | `53000` |\n     * | `AuthorizationErrors.NoValidAccountError` | `31203` | `53000` |\n     * | `AuthorizationErrors.JWTTokenExpirationTooLongError` | `31207` | `53000` |\n     * | `ClientErrors.NotFound` | `31404` | `53000` |\n     * | `ClientErrors.TemporarilyUnavilable` | `31480` | `53000` |\n     * | `ClientErrors.BusyHere` | `31486` | `53000` |\n     * | `SIPServerErrors.Decline` | `31603` | `53000` |\n     *\n     * - Call Error Changes\n     *\n     * @example\n     * ```ts\n     * const device = new Device(token, {\n     *   enableImprovedSignalingErrorPrecision: true,\n     * });\n     * const call = device.connect(...);\n     * call.on('error', (callError) => {\n     *   // the following table describes how callError will change with this feature flag\n     * });\n     * ```\n     *\n     * | Call Error Name | Call Error Code with Feature Flag Enabled | Call Error Code with Feature Flag Disabled |\n     * | --- | --- | --- |\n     * | `GeneralErrors.ConnectionDeclinedError` | `31002` | `31005` |\n     * | `AuthorizationErrors.InvalidJWTTokenError` | `31204` | `31005` |\n     * | `AuthorizationErrors.JWTTokenExpiredError` | `31205` | `31005` |\n     *\n     */\n    enableImprovedSignalingErrorPrecision?: boolean;\n\n    /**\n     * Overrides the native MediaDevices.enumerateDevices API.\n     */\n    enumerateDevices?: any;\n\n    /**\n     * Experimental feature.\n     * Whether to use ICE Aggressive nomination.\n     */\n    forceAggressiveIceNomination?: boolean;\n\n    /**\n     * Overrides the native MediaDevices.getUserMedia API.\n     */\n    getUserMedia?: any;\n\n    /**\n     * Sets the log level.\n     *\n     * Possible values include any of the following numbers:\n     * <br/>0 = trace, 1 = debug, 2 = info, 3 = warn, 4 = error, 5 = silent\n     *\n     * Or any of the following strings:\n     * <br/>'trace', 'debug', 'info', 'warn', 'error', 'silent'\n     * <br/>'TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'SILENT'\n     */\n    logLevel?: LogLevelDesc;\n\n    /**\n     * The maximum average audio bitrate to use, in bits per second (bps) based on\n     * [RFC-7587 7.1](https://tools.ietf.org/html/rfc7587#section-7.1). By default, the setting\n     * is not used. If you specify 0, then the setting is not used. Any positive integer is allowed,\n     * but values outside the range 6000 to 510000 are ignored and treated as 0. The recommended\n     * bitrate for speech is between 8000 and 40000 bps as noted in\n     * [RFC-7587 3.1.1](https://tools.ietf.org/html/rfc7587#section-3.1.1).\n     */\n    maxAverageBitrate?: number;\n\n    /**\n     * The maximum duration to attempt to reconnect to a preferred URI.\n     * This is used by signaling reconnection in that during the existence of\n     * any call, edge-fallback is disabled until this length of time has\n     * elapsed.\n     *\n     * Using a value of 30000 as an example: while a call exists, the Device\n     * will attempt to reconnect to the edge that the call was established on\n     * for approximately 30 seconds. After the next failure to connect, the\n     * Device will use edge-fallback.\n     *\n     * This feature is opt-in, and will not work until a number greater than 0\n     * is explicitly specified within the Device options.\n     *\n     * Read more about edge fallback and signaling reconnection on the\n     * [Edge Locations page](https://www.twilio.com/docs/voice/sdks/javascript/edges#edge-fallback-and-signaling-reconnection).\n     *\n     * **Note:** Setting this option to a value greater than zero means Twilio will not terminate the\n     * call until the timeout has expired. Please take this into consideration if your application\n     * contains webhooks that relies on [call status callbacks](https://www.twilio.com/docs/voice/twiml#callstatus-values).\n     */\n    maxCallSignalingTimeoutMs?: number;\n\n    /**\n     * Overrides the native RTCPeerConnection class.\n     *\n     * By default, the SDK will use the `unified-plan` SDP format if the browser supports it.\n     * Unexpected behavior may happen if the `RTCPeerConnection` parameter uses an SDP format\n     * that is different than what the SDK uses.\n     *\n     * For example, if the browser supports `unified-plan` and the `RTCPeerConnection`\n     * parameter uses `plan-b` by default, the SDK will use `unified-plan`\n     * which will cause conflicts with the usage of the `RTCPeerConnection`.\n     *\n     * In order to avoid this issue, you need to explicitly set the SDP format that you want\n     * the SDK to use with the `RTCPeerConnection` via [[Device.ConnectOptions.rtcConfiguration]] for outgoing calls.\n     * Or [[Call.AcceptOptions.rtcConfiguration]] for incoming calls.\n     *\n     * See the example below. Assuming the `RTCPeerConnection` you provided uses `plan-b` by default, the following\n     * code sets the SDP format to `unified-plan` instead.\n     *\n     * ```ts\n     * // Outgoing calls\n     * const call = await device.connect({\n     *   rtcConfiguration: {\n     *     sdpSemantics: 'unified-plan'\n     *   }\n     *   // Other options\n     * });\n     *\n     * // Incoming calls\n     * device.on('incoming', call => {\n     *   call.accept({\n     *     rtcConfiguration: {\n     *       sdpSemantics: 'unified-plan'\n     *     }\n     *     // Other options\n     *   });\n     * });\n     * ```\n     */\n    RTCPeerConnection?: any;\n\n    /**\n     * A mapping of custom sound URLs by sound name.\n     */\n    sounds?: Partial<Record<Device.SoundName, string>>;\n\n    /**\n     * Number of milliseconds fewer than the token's TTL to emit the tokenWillExpire event.\n     * Default is 10000 (10 seconds).\n     */\n    tokenRefreshMs?: number;\n  }\n}\n\nexport default Device;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}