{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\nvar events_1 = require(\"events\");\nvar backoff_1 = require(\"./backoff\");\nvar device_1 = require(\"./device\");\nvar errors_1 = require(\"./errors\");\nvar log_1 = require(\"./log\");\nvar rtc_1 = require(\"./rtc\");\nvar icecandidate_1 = require(\"./rtc/icecandidate\");\nvar sdp_1 = require(\"./rtc/sdp\");\nvar statsMonitor_1 = require(\"./statsMonitor\");\nvar util_1 = require(\"./util\");\nvar uuid_1 = require(\"./uuid\");\nvar constants_1 = require(\"./constants\");\nvar BACKOFF_CONFIG = {\n  factor: 1.1,\n  jitter: 0.5,\n  max: 30000,\n  min: 1\n};\nvar DTMF_INTER_TONE_GAP = 70;\nvar DTMF_PAUSE_DURATION = 500;\nvar DTMF_TONE_DURATION = 160;\nvar METRICS_BATCH_SIZE = 10;\nvar METRICS_DELAY = 5000;\nvar MEDIA_DISCONNECT_ERROR = {\n  disconnect: true,\n  info: {\n    code: 31003,\n    message: 'Connection with Twilio was interrupted.',\n    twilioError: new errors_1.MediaErrors.ConnectionError()\n  }\n};\nvar MULTIPLE_THRESHOLD_WARNING_NAMES = {\n  // The stat `packetsLostFraction` is monitored by two separate thresholds,\n  // `maxAverage` and `max`. Each threshold emits a different warning name.\n  packetsLostFraction: {\n    max: 'packet-loss',\n    maxAverage: 'packets-lost-fraction'\n  }\n};\nvar WARNING_NAMES = {\n  audioInputLevel: 'audio-input-level',\n  audioOutputLevel: 'audio-output-level',\n  bytesReceived: 'bytes-received',\n  bytesSent: 'bytes-sent',\n  jitter: 'jitter',\n  mos: 'mos',\n  rtt: 'rtt'\n};\nvar WARNING_PREFIXES = {\n  max: 'high-',\n  maxAverage: 'high-',\n  maxDuration: 'constant-',\n  min: 'low-',\n  minStandardDeviation: 'constant-'\n};\n/**\n * A {@link Call} represents a media and signaling connection to a TwiML application.\n * @publicapi\n */\nvar Call = /** @class */function (_super) {\n  __extends(Call, _super);\n  /**\n   * @constructor\n   * @private\n   * @param config - Mandatory configuration options\n   * @param [options] - Optional settings\n   */\n  function Call(config, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * Call parameters received from Twilio for an incoming call.\n     */\n    _this.parameters = {};\n    /**\n     * The number of times input volume has been the same consecutively.\n     */\n    _this._inputVolumeStreak = 0;\n    /**\n     * Whether the call has been answered.\n     */\n    _this._isAnswered = false;\n    /**\n     * Whether the call has been cancelled.\n     */\n    _this._isCancelled = false;\n    /**\n     * Whether the call has been rejected\n     */\n    _this._isRejected = false;\n    /**\n     * The most recent public input volume value. 0 -> 1 representing -100 to -30 dB.\n     */\n    _this._latestInputVolume = 0;\n    /**\n     * The most recent public output volume value. 0 -> 1 representing -100 to -30 dB.\n     */\n    _this._latestOutputVolume = 0;\n    /**\n     * An instance of Logger to use.\n     */\n    _this._log = new log_1.default('Call');\n    /**\n     * State of the {@link Call}'s media.\n     */\n    _this._mediaStatus = Call.State.Pending;\n    /**\n     * A map of messages sent via sendMessage API using voiceEventSid as the key.\n     * The message will be deleted once an 'ack' or an error is received from the server.\n     */\n    _this._messages = new Map();\n    /**\n     * A batch of metrics samples to send to Insights. Gets cleared after\n     * each send and appended to on each new sample.\n     */\n    _this._metricsSamples = [];\n    /**\n     * Options passed to this {@link Call}.\n     */\n    _this._options = {\n      MediaHandler: rtc_1.PeerConnection,\n      enableImprovedSignalingErrorPrecision: false,\n      offerSdp: null,\n      shouldPlayDisconnect: function () {\n        return true;\n      },\n      voiceEventSidGenerator: uuid_1.generateVoiceEventSid\n    };\n    /**\n     * The number of times output volume has been the same consecutively.\n     */\n    _this._outputVolumeStreak = 0;\n    /**\n     * Whether the {@link Call} should send a hangup on disconnect.\n     */\n    _this._shouldSendHangup = true;\n    /**\n     * State of the {@link Call}'s signaling.\n     */\n    _this._signalingStatus = Call.State.Pending;\n    /**\n     * A Map of Sounds to play.\n     */\n    _this._soundcache = new Map();\n    /**\n     * State of the {@link Call}.\n     */\n    _this._status = Call.State.Pending;\n    /**\n     * Whether the {@link Call} has been connected. Used to determine if we are reconnected.\n     */\n    _this._wasConnected = false;\n    /**\n     * String representation of {@link Call} instance.\n     * @private\n     */\n    _this.toString = function () {\n      return '[Twilio.Call instance]';\n    };\n    _this._emitWarning = function (groupPrefix, warningName, threshold, value, wasCleared, warningData) {\n      var groupSuffix = wasCleared ? '-cleared' : '-raised';\n      var groupName = groupPrefix + \"warning\" + groupSuffix;\n      // Ignore constant input if the Call is muted (Expected)\n      if (warningName === 'constant-audio-input-level' && _this.isMuted()) {\n        return;\n      }\n      var level = wasCleared ? 'info' : 'warning';\n      // Avoid throwing false positives as warnings until we refactor volume metrics\n      if (warningName === 'constant-audio-output-level') {\n        level = 'info';\n      }\n      var payloadData = {\n        threshold: threshold\n      };\n      if (value) {\n        if (value instanceof Array) {\n          payloadData.values = value.map(function (val) {\n            if (typeof val === 'number') {\n              return Math.round(val * 100) / 100;\n            }\n            return value;\n          });\n        } else {\n          payloadData.value = value;\n        }\n      }\n      _this._publisher.post(level, groupName, warningName, {\n        data: payloadData\n      }, _this);\n      if (warningName !== 'constant-audio-output-level') {\n        var emitName = wasCleared ? 'warning-cleared' : 'warning';\n        _this._log.debug(\"#\" + emitName, warningName);\n        _this.emit(emitName, warningName, warningData && !wasCleared ? warningData : null);\n      }\n    };\n    /**\n     * Called when the {@link Call} receives an ack from signaling\n     * @param payload\n     */\n    _this._onAck = function (payload) {\n      var acktype = payload.acktype,\n        callsid = payload.callsid,\n        voiceeventsid = payload.voiceeventsid;\n      if (_this.parameters.CallSid !== callsid) {\n        _this._log.warn(\"Received ack from a different callsid: \" + callsid);\n        return;\n      }\n      if (acktype === 'message') {\n        _this._onMessageSent(voiceeventsid);\n      }\n    };\n    /**\n     * Called when the {@link Call} is answered.\n     * @param payload\n     */\n    _this._onAnswer = function (payload) {\n      if (typeof payload.reconnect === 'string') {\n        _this._signalingReconnectToken = payload.reconnect;\n      }\n      // answerOnBridge=false will send a 183 which we need to catch in _onRinging when\n      // the enableRingingState flag is disabled. In that case, we will receive a 200 after\n      // the callee accepts the call firing a second `accept` event if we don't\n      // short circuit here.\n      if (_this._isAnswered && _this._status !== Call.State.Reconnecting) {\n        return;\n      }\n      _this._setCallSid(payload);\n      _this._isAnswered = true;\n      _this._maybeTransitionToOpen();\n    };\n    /**\n     * Called when the {@link Call} is cancelled.\n     * @param payload\n     */\n    _this._onCancel = function (payload) {\n      // (rrowland) Is this check necessary? Verify, and if so move to pstream / VSP module.\n      var callsid = payload.callsid;\n      if (_this.parameters.CallSid === callsid) {\n        _this._isCancelled = true;\n        _this._publisher.info('connection', 'cancel', null, _this);\n        _this._cleanupEventListeners();\n        _this._mediaHandler.close();\n        _this._status = Call.State.Closed;\n        _this._log.debug('#cancel');\n        _this.emit('cancel');\n        _this._pstream.removeListener('cancel', _this._onCancel);\n      }\n    };\n    /**\n     * Called when we receive a connected event from pstream.\n     * Re-emits the event.\n     */\n    _this._onConnected = function () {\n      _this._log.info('Received connected from pstream');\n      if (_this._signalingReconnectToken && _this._mediaHandler.version) {\n        _this._pstream.reconnect(_this._mediaHandler.version.getSDP(), _this.parameters.CallSid, _this._signalingReconnectToken);\n      }\n    };\n    /**\n     * Called when the {@link Call} is hung up.\n     * @param payload\n     */\n    _this._onHangup = function (payload) {\n      if (_this.status() === Call.State.Closed) {\n        return;\n      }\n      /**\n       *  see if callsid passed in message matches either callsid or outbound id\n       *  call should always have either callsid or outbound id\n       *  if no callsid passed hangup anyways\n       */\n      if (payload.callsid && (_this.parameters.CallSid || _this.outboundConnectionId)) {\n        if (payload.callsid !== _this.parameters.CallSid && payload.callsid !== _this.outboundConnectionId) {\n          return;\n        }\n      } else if (payload.callsid) {\n        // hangup is for another call\n        return;\n      }\n      _this._log.info('Received HANGUP from gateway');\n      if (payload.error) {\n        var code = payload.error.code;\n        var errorConstructor = errors_1.getPreciseSignalingErrorByCode(_this._options.enableImprovedSignalingErrorPrecision, code);\n        var error = typeof errorConstructor !== 'undefined' ? new errorConstructor(payload.error.message) : new errors_1.GeneralErrors.ConnectionError('Error sent from gateway in HANGUP');\n        _this._log.error('Received an error from the gateway:', error);\n        _this._log.debug('#error', error);\n        _this.emit('error', error);\n      }\n      _this._shouldSendHangup = false;\n      _this._publisher.info('connection', 'disconnected-by-remote', null, _this);\n      _this._disconnect(null, true);\n      _this._cleanupEventListeners();\n    };\n    /**\n     * Called when there is a media failure.\n     * Manages all media-related states and takes action base on the states\n     * @param type - Type of media failure\n     */\n    _this._onMediaFailure = function (type) {\n      var _a = Call.MediaFailure,\n        ConnectionDisconnected = _a.ConnectionDisconnected,\n        ConnectionFailed = _a.ConnectionFailed,\n        IceGatheringFailed = _a.IceGatheringFailed,\n        LowBytes = _a.LowBytes;\n      // These types signifies the end of a single ICE cycle\n      var isEndOfIceCycle = type === ConnectionFailed || type === IceGatheringFailed;\n      // All browsers except chrome doesn't update pc.iceConnectionState and pc.connectionState\n      // after issuing an ICE Restart, which we use to determine if ICE Restart is complete.\n      // Since we cannot detect if ICE Restart is complete, we will not retry.\n      if (!util_1.isChrome(window, window.navigator) && type === ConnectionFailed) {\n        return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n      }\n      // Ignore subsequent requests if ice restart is in progress\n      if (_this._mediaStatus === Call.State.Reconnecting) {\n        // This is a retry. Previous ICE Restart failed\n        if (isEndOfIceCycle) {\n          // We already exceeded max retry time.\n          if (Date.now() - _this._mediaReconnectStartTime > BACKOFF_CONFIG.max) {\n            _this._log.warn('Exceeded max ICE retries');\n            return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n          }\n          // Issue ICE restart with backoff\n          try {\n            _this._mediaReconnectBackoff.backoff();\n          } catch (error) {\n            // Catch and ignore 'Backoff in progress.' errors. If a backoff is\n            // ongoing and we try to start another one, there shouldn't be a\n            // problem.\n            if (!(error.message && error.message === 'Backoff in progress.')) {\n              throw error;\n            }\n          }\n        }\n        return;\n      }\n      var pc = _this._mediaHandler.version.pc;\n      var isIceDisconnected = pc && pc.iceConnectionState === 'disconnected';\n      var hasLowBytesWarning = _this._monitor.hasActiveWarning('bytesSent', 'min') || _this._monitor.hasActiveWarning('bytesReceived', 'min');\n      // Only certain conditions can trigger media reconnection\n      if (type === LowBytes && isIceDisconnected || type === ConnectionDisconnected && hasLowBytesWarning || isEndOfIceCycle) {\n        var mediaReconnectionError = new errors_1.MediaErrors.ConnectionError('Media connection failed.');\n        _this._log.warn('ICE Connection disconnected.');\n        _this._publisher.warn('connection', 'error', mediaReconnectionError, _this);\n        _this._publisher.info('connection', 'reconnecting', null, _this);\n        _this._mediaReconnectStartTime = Date.now();\n        _this._status = Call.State.Reconnecting;\n        _this._mediaStatus = Call.State.Reconnecting;\n        _this._mediaReconnectBackoff.reset();\n        _this._mediaReconnectBackoff.backoff();\n        _this._log.debug('#reconnecting');\n        _this.emit('reconnecting', mediaReconnectionError);\n      }\n    };\n    /**\n     * Called when media call is restored\n     */\n    _this._onMediaReconnected = function () {\n      // Only trigger once.\n      // This can trigger on pc.onIceConnectionChange and pc.onConnectionChange.\n      if (_this._mediaStatus !== Call.State.Reconnecting) {\n        return;\n      }\n      _this._log.info('ICE Connection reestablished.');\n      _this._mediaStatus = Call.State.Open;\n      if (_this._signalingStatus === Call.State.Open) {\n        _this._publisher.info('connection', 'reconnected', null, _this);\n        _this._log.debug('#reconnected');\n        _this.emit('reconnected');\n        _this._status = Call.State.Open;\n      }\n    };\n    /**\n     * Raised when a Call receives a message from the backend.\n     * @param payload - A record representing the payload of the message from the\n     * Twilio backend.\n     */\n    _this._onMessageReceived = function (payload) {\n      var callsid = payload.callsid,\n        content = payload.content,\n        contenttype = payload.contenttype,\n        messagetype = payload.messagetype,\n        voiceeventsid = payload.voiceeventsid;\n      if (_this.parameters.CallSid !== callsid) {\n        _this._log.warn(\"Received a message from a different callsid: \" + callsid);\n        return;\n      }\n      var data = {\n        content: content,\n        contentType: contenttype,\n        messageType: messagetype,\n        voiceEventSid: voiceeventsid\n      };\n      _this._publisher.info('call-message', messagetype, {\n        content_type: contenttype,\n        event_type: 'received',\n        voice_event_sid: voiceeventsid\n      }, _this);\n      _this._log.debug('#messageReceived', JSON.stringify(data));\n      _this.emit('messageReceived', data);\n    };\n    /**\n     * Raised when a Call receives an 'ack' with an 'acktype' of 'message.\n     * This means that the message sent via sendMessage API has been received by the signaling server.\n     * @param voiceEventSid\n     */\n    _this._onMessageSent = function (voiceEventSid) {\n      if (!_this._messages.has(voiceEventSid)) {\n        _this._log.warn(\"Received a messageSent with a voiceEventSid that doesn't exists: \" + voiceEventSid);\n        return;\n      }\n      var message = _this._messages.get(voiceEventSid);\n      _this._messages.delete(voiceEventSid);\n      _this._publisher.info('call-message', message === null || message === void 0 ? void 0 : message.messageType, {\n        content_type: message === null || message === void 0 ? void 0 : message.contentType,\n        event_type: 'sent',\n        voice_event_sid: voiceEventSid\n      }, _this);\n      _this._log.debug('#messageSent', JSON.stringify(message));\n      _this.emit('messageSent', message);\n    };\n    /**\n     * When we get a RINGING signal from PStream, update the {@link Call} status.\n     * @param payload\n     */\n    _this._onRinging = function (payload) {\n      _this._setCallSid(payload);\n      // If we're not in 'connecting' or 'ringing' state, this event was received out of order.\n      if (_this._status !== Call.State.Connecting && _this._status !== Call.State.Ringing) {\n        return;\n      }\n      var hasEarlyMedia = !!payload.sdp;\n      _this._status = Call.State.Ringing;\n      _this._publisher.info('connection', 'outgoing-ringing', {\n        hasEarlyMedia: hasEarlyMedia\n      }, _this);\n      _this._log.debug('#ringing');\n      _this.emit('ringing', hasEarlyMedia);\n    };\n    /**\n     * Called each time StatsMonitor emits a sample.\n     * Emits stats event and batches the call stats metrics and sends them to Insights.\n     * @param sample\n     */\n    _this._onRTCSample = function (sample) {\n      var callMetrics = __assign(__assign({}, sample), {\n        inputVolume: _this._latestInputVolume,\n        outputVolume: _this._latestOutputVolume\n      });\n      _this._codec = callMetrics.codecName;\n      _this._metricsSamples.push(callMetrics);\n      if (_this._metricsSamples.length >= METRICS_BATCH_SIZE) {\n        _this._publishMetrics();\n      }\n      _this.emit('sample', sample);\n    };\n    /**\n     * Called when an 'error' event is received from the signaling stream.\n     */\n    _this._onSignalingError = function (payload) {\n      var callsid = payload.callsid,\n        voiceeventsid = payload.voiceeventsid,\n        error = payload.error;\n      if (_this.parameters.CallSid !== callsid) {\n        _this._log.warn(\"Received an error from a different callsid: \" + callsid);\n        return;\n      }\n      if (voiceeventsid && _this._messages.has(voiceeventsid)) {\n        // Do not emit an error here. Device is handling all signaling related errors.\n        _this._messages.delete(voiceeventsid);\n        _this._log.warn(\"Received an error while sending a message.\", payload);\n        _this._publisher.error('call-message', 'error', {\n          code: error.code,\n          message: error.message,\n          voice_event_sid: voiceeventsid\n        }, _this);\n        var twilioError = void 0;\n        var errorConstructor = errors_1.getPreciseSignalingErrorByCode(!!_this._options.enableImprovedSignalingErrorPrecision, error.code);\n        if (typeof errorConstructor !== 'undefined') {\n          twilioError = new errorConstructor(error);\n        }\n        if (!twilioError) {\n          _this._log.error('Unknown Call Message Error: ', error);\n          twilioError = new errors_1.GeneralErrors.UnknownError(error.message, error);\n        }\n        _this._log.debug('#error', error, twilioError);\n        _this.emit('error', twilioError);\n      }\n    };\n    /**\n     * Called when signaling is restored\n     */\n    _this._onSignalingReconnected = function () {\n      if (_this._signalingStatus !== Call.State.Reconnecting) {\n        return;\n      }\n      _this._log.info('Signaling Connection reestablished.');\n      _this._signalingStatus = Call.State.Open;\n      if (_this._mediaStatus === Call.State.Open) {\n        _this._publisher.info('connection', 'reconnected', null, _this);\n        _this._log.debug('#reconnected');\n        _this.emit('reconnected');\n        _this._status = Call.State.Open;\n      }\n    };\n    /**\n     * Called when we receive a transportClose event from pstream.\n     * Re-emits the event.\n     */\n    _this._onTransportClose = function () {\n      _this._log.error('Received transportClose from pstream');\n      _this._log.debug('#transportClose');\n      _this.emit('transportClose');\n      if (_this._signalingReconnectToken) {\n        _this._status = Call.State.Reconnecting;\n        _this._signalingStatus = Call.State.Reconnecting;\n        _this._log.debug('#reconnecting');\n        _this.emit('reconnecting', new errors_1.SignalingErrors.ConnectionDisconnected());\n      } else {\n        _this._status = Call.State.Closed;\n        _this._signalingStatus = Call.State.Closed;\n      }\n    };\n    /**\n     * Re-emit an StatsMonitor warning as a {@link Call}.warning or .warning-cleared event.\n     * @param warningData\n     * @param wasCleared - Whether this is a -cleared or -raised event.\n     */\n    _this._reemitWarning = function (warningData, wasCleared) {\n      var groupPrefix = /^audio/.test(warningData.name) ? 'audio-level-' : 'network-quality-';\n      var warningPrefix = WARNING_PREFIXES[warningData.threshold.name];\n      /**\n       * NOTE: There are two \"packet-loss\" warnings: `high-packet-loss` and\n       * `high-packets-lost-fraction`, so in this case we need to use a different\n       * `WARNING_NAME` mapping.\n       */\n      var warningName;\n      if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {\n        warningName = MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][warningData.threshold.name];\n      } else if (warningData.name in WARNING_NAMES) {\n        warningName = WARNING_NAMES[warningData.name];\n      }\n      var warning = warningPrefix + warningName;\n      _this._emitWarning(groupPrefix, warning, warningData.threshold.value, warningData.values || warningData.value, wasCleared, warningData);\n    };\n    /**\n     * Re-emit an StatsMonitor warning-cleared as a .warning-cleared event.\n     * @param warningData\n     */\n    _this._reemitWarningCleared = function (warningData) {\n      _this._reemitWarning(warningData, true);\n    };\n    _this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;\n    _this._soundcache = config.soundcache;\n    if (typeof config.onIgnore === 'function') {\n      _this._onIgnore = config.onIgnore;\n    }\n    var message = options && options.twimlParams || {};\n    _this.customParameters = new Map(Object.entries(message).map(function (_a) {\n      var key = _a[0],\n        val = _a[1];\n      return [key, String(val)];\n    }));\n    Object.assign(_this._options, options);\n    if (_this._options.callParameters) {\n      _this.parameters = _this._options.callParameters;\n    }\n    if (_this._options.reconnectToken) {\n      _this._signalingReconnectToken = _this._options.reconnectToken;\n    }\n    _this._voiceEventSidGenerator = _this._options.voiceEventSidGenerator || uuid_1.generateVoiceEventSid;\n    _this._direction = _this.parameters.CallSid && !_this._options.reconnectCallSid ? Call.CallDirection.Incoming : Call.CallDirection.Outgoing;\n    if (_this.parameters) {\n      _this.callerInfo = _this.parameters.StirStatus ? {\n        isVerified: _this.parameters.StirStatus === 'TN-Validation-Passed-A'\n      } : null;\n    } else {\n      _this.callerInfo = null;\n    }\n    _this._mediaReconnectBackoff = new backoff_1.default(BACKOFF_CONFIG);\n    _this._mediaReconnectBackoff.on('ready', function () {\n      return _this._mediaHandler.iceRestart();\n    });\n    // temporary call sid to be used for outgoing calls\n    _this.outboundConnectionId = generateTempCallSid();\n    var publisher = _this._publisher = config.publisher;\n    if (_this._direction === Call.CallDirection.Incoming) {\n      publisher.info('connection', 'incoming', null, _this);\n    } else {\n      publisher.info('connection', 'outgoing', {\n        preflight: _this._options.preflight,\n        reconnect: !!_this._options.reconnectCallSid\n      }, _this);\n    }\n    var monitor = _this._monitor = new (_this._options.StatsMonitor || statsMonitor_1.default)();\n    monitor.on('sample', _this._onRTCSample);\n    // First 20 seconds or so are choppy, so let's not bother with these warnings.\n    monitor.disableWarnings();\n    setTimeout(function () {\n      return monitor.enableWarnings();\n    }, METRICS_DELAY);\n    monitor.on('warning', function (data, wasCleared) {\n      if (data.name === 'bytesSent' || data.name === 'bytesReceived') {\n        _this._onMediaFailure(Call.MediaFailure.LowBytes);\n      }\n      _this._reemitWarning(data, wasCleared);\n    });\n    monitor.on('warning-cleared', function (data) {\n      _this._reemitWarningCleared(data);\n    });\n    _this._mediaHandler = new _this._options.MediaHandler(config.audioHelper, config.pstream, {\n      RTCPeerConnection: _this._options.RTCPeerConnection,\n      codecPreferences: _this._options.codecPreferences,\n      dscp: _this._options.dscp,\n      forceAggressiveIceNomination: _this._options.forceAggressiveIceNomination,\n      isUnifiedPlan: _this._isUnifiedPlanDefault,\n      maxAverageBitrate: _this._options.maxAverageBitrate\n    });\n    _this.on('volume', function (inputVolume, outputVolume) {\n      _this._inputVolumeStreak = _this._checkVolume(inputVolume, _this._inputVolumeStreak, _this._latestInputVolume, 'input');\n      _this._outputVolumeStreak = _this._checkVolume(outputVolume, _this._outputVolumeStreak, _this._latestOutputVolume, 'output');\n      _this._latestInputVolume = inputVolume;\n      _this._latestOutputVolume = outputVolume;\n    });\n    _this._mediaHandler.onaudio = function (remoteAudio) {\n      _this._log.debug('#audio');\n      _this.emit('audio', remoteAudio);\n    };\n    _this._mediaHandler.onvolume = function (inputVolume, outputVolume, internalInputVolume, internalOutputVolume) {\n      // (rrowland) These values mock the 0 -> 32767 format used by legacy getStats. We should look into\n      // migrating to a newer standard, either 0.0 -> linear or -127 to 0 in dB, matching the range\n      // chosen below.\n      monitor.addVolumes(internalInputVolume / 255 * 32767, internalOutputVolume / 255 * 32767);\n      // (rrowland) 0.0 -> 1.0 linear\n      _this.emit('volume', inputVolume, outputVolume);\n    };\n    _this._mediaHandler.ondtlstransportstatechange = function (state) {\n      var level = state === 'failed' ? 'error' : 'debug';\n      _this._publisher.post(level, 'dtls-transport-state', state, null, _this);\n    };\n    _this._mediaHandler.onpcconnectionstatechange = function (state) {\n      var level = 'debug';\n      var dtlsTransport = _this._mediaHandler.getRTCDtlsTransport();\n      if (state === 'failed') {\n        level = dtlsTransport && dtlsTransport.state === 'failed' ? 'error' : 'warning';\n      }\n      _this._publisher.post(level, 'pc-connection-state', state, null, _this);\n    };\n    _this._mediaHandler.onicecandidate = function (candidate) {\n      var payload = new icecandidate_1.IceCandidate(candidate).toPayload();\n      _this._publisher.debug('ice-candidate', 'ice-candidate', payload, _this);\n    };\n    _this._mediaHandler.onselectedcandidatepairchange = function (pair) {\n      var localCandidatePayload = new icecandidate_1.IceCandidate(pair.local).toPayload();\n      var remoteCandidatePayload = new icecandidate_1.IceCandidate(pair.remote, true).toPayload();\n      _this._publisher.debug('ice-candidate', 'selected-ice-candidate-pair', {\n        local_candidate: localCandidatePayload,\n        remote_candidate: remoteCandidatePayload\n      }, _this);\n    };\n    _this._mediaHandler.oniceconnectionstatechange = function (state) {\n      var level = state === 'failed' ? 'error' : 'debug';\n      _this._publisher.post(level, 'ice-connection-state', state, null, _this);\n    };\n    _this._mediaHandler.onicegatheringfailure = function (type) {\n      _this._publisher.warn('ice-gathering-state', type, null, _this);\n      _this._onMediaFailure(Call.MediaFailure.IceGatheringFailed);\n    };\n    _this._mediaHandler.onicegatheringstatechange = function (state) {\n      _this._publisher.debug('ice-gathering-state', state, null, _this);\n    };\n    _this._mediaHandler.onsignalingstatechange = function (state) {\n      _this._publisher.debug('signaling-state', state, null, _this);\n    };\n    _this._mediaHandler.ondisconnected = function (msg) {\n      _this._log.warn(msg);\n      _this._publisher.warn('network-quality-warning-raised', 'ice-connectivity-lost', {\n        message: msg\n      }, _this);\n      _this._log.debug('#warning', 'ice-connectivity-lost');\n      _this.emit('warning', 'ice-connectivity-lost');\n      _this._onMediaFailure(Call.MediaFailure.ConnectionDisconnected);\n    };\n    _this._mediaHandler.onfailed = function (msg) {\n      _this._onMediaFailure(Call.MediaFailure.ConnectionFailed);\n    };\n    _this._mediaHandler.onconnected = function () {\n      // First time _mediaHandler is connected, but ICE Gathering issued an ICE restart and succeeded.\n      if (_this._status === Call.State.Reconnecting) {\n        _this._onMediaReconnected();\n      }\n    };\n    _this._mediaHandler.onreconnected = function (msg) {\n      _this._log.info(msg);\n      _this._publisher.info('network-quality-warning-cleared', 'ice-connectivity-lost', {\n        message: msg\n      }, _this);\n      _this._log.debug('#warning-cleared', 'ice-connectivity-lost');\n      _this.emit('warning-cleared', 'ice-connectivity-lost');\n      _this._onMediaReconnected();\n    };\n    _this._mediaHandler.onerror = function (e) {\n      if (e.disconnect === true) {\n        _this._disconnect(e.info && e.info.message);\n      }\n      var error = e.info.twilioError || new errors_1.GeneralErrors.UnknownError(e.info.message);\n      _this._log.error('Received an error from MediaStream:', e);\n      _this._log.debug('#error', error);\n      _this.emit('error', error);\n    };\n    _this._mediaHandler.onopen = function () {\n      // NOTE(mroberts): While this may have been happening in previous\n      // versions of Chrome, since Chrome 45 we have seen the\n      // PeerConnection's onsignalingstatechange handler invoked multiple\n      // times in the same signalingState 'stable'. When this happens, we\n      // invoke this onopen function. If we invoke it twice without checking\n      // for _status 'open', we'd accidentally close the PeerConnection.\n      //\n      // See <https://code.google.com/p/webrtc/issues/detail?id=4996>.\n      if (_this._status === Call.State.Open || _this._status === Call.State.Reconnecting) {\n        return;\n      } else if (_this._status === Call.State.Ringing || _this._status === Call.State.Connecting) {\n        _this.mute(_this._mediaHandler.isMuted);\n        _this._mediaStatus = Call.State.Open;\n        _this._maybeTransitionToOpen();\n      } else {\n        // call was probably canceled sometime before this\n        _this._mediaHandler.close();\n      }\n    };\n    _this._mediaHandler.onclose = function () {\n      _this._status = Call.State.Closed;\n      if (_this._options.shouldPlayDisconnect && _this._options.shouldPlayDisconnect()\n      // Don't play disconnect sound if this was from a cancel event. i.e. the call\n      // was ignored or hung up even before it was answered.\n      // Similarly, don't play disconnect sound if the call was rejected.\n      && !_this._isCancelled && !_this._isRejected) {\n        _this._soundcache.get(device_1.default.SoundName.Disconnect).play();\n      }\n      monitor.disable();\n      _this._publishMetrics();\n      if (!_this._isCancelled && !_this._isRejected) {\n        // tslint:disable no-console\n        _this._log.debug('#disconnect');\n        _this.emit('disconnect', _this);\n      }\n    };\n    _this._pstream = config.pstream;\n    _this._pstream.on('ack', _this._onAck);\n    _this._pstream.on('cancel', _this._onCancel);\n    _this._pstream.on('error', _this._onSignalingError);\n    _this._pstream.on('ringing', _this._onRinging);\n    _this._pstream.on('transportClose', _this._onTransportClose);\n    _this._pstream.on('connected', _this._onConnected);\n    _this._pstream.on('message', _this._onMessageReceived);\n    _this.on('error', function (error) {\n      _this._publisher.error('connection', 'error', {\n        code: error.code,\n        message: error.message\n      }, _this);\n      if (_this._pstream && _this._pstream.status === 'disconnected') {\n        _this._cleanupEventListeners();\n      }\n    });\n    _this.on('disconnect', function () {\n      _this._cleanupEventListeners();\n    });\n    return _this;\n  }\n  Object.defineProperty(Call.prototype, \"direction\", {\n    /**\n     * Whether this {@link Call} is incoming or outgoing.\n     */\n    get: function () {\n      return this._direction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Call.prototype, \"codec\", {\n    /**\n     * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n     * will copy whatever we get from RTC stats.\n     */\n    get: function () {\n      return this._codec;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Call.prototype, \"connectToken\", {\n    /**\n     * The connect token is available as soon as the call is established\n     * and connected to Twilio. Use this token to reconnect to a call via the {@link Device.connect}\n     * method.\n     *\n     * For incoming calls, it is available in the call object after the {@link Device.incomingEvent} is emitted.\n     * For outgoing calls, it is available after the {@link Call.acceptEvent} is emitted.\n     */\n    get: function () {\n      var _this = this;\n      var signalingReconnectToken = this._signalingReconnectToken;\n      var callSid = this.parameters && this.parameters.CallSid ? this.parameters.CallSid : undefined;\n      if (!signalingReconnectToken || !callSid) {\n        return;\n      }\n      var customParameters = this.customParameters && typeof this.customParameters.keys === 'function' ? Array.from(this.customParameters.keys()).reduce(function (result, key) {\n        result[key] = _this.customParameters.get(key);\n        return result;\n      }, {}) : {};\n      var parameters = this.parameters || {};\n      return btoa(encodeURIComponent(JSON.stringify({\n        customParameters: customParameters,\n        parameters: parameters,\n        signalingReconnectToken: signalingReconnectToken\n      })));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Set the audio input tracks from a given stream.\n   * @param stream\n   * @private\n   */\n  Call.prototype._setInputTracksFromStream = function (stream) {\n    return this._mediaHandler.setInputTracksFromStream(stream);\n  };\n  /**\n   * Set the audio output sink IDs.\n   * @param sinkIds\n   * @private\n   */\n  Call.prototype._setSinkIds = function (sinkIds) {\n    return this._mediaHandler._setSinkIds(sinkIds);\n  };\n  /**\n   * Accept the incoming {@link Call}.\n   * @param [options]\n   */\n  Call.prototype.accept = function (options) {\n    var _this = this;\n    this._log.debug('.accept', options);\n    if (this._status !== Call.State.Pending) {\n      this._log.debug(\".accept noop. status is '\" + this._status + \"'\");\n      return;\n    }\n    options = options || {};\n    var rtcConfiguration = options.rtcConfiguration || this._options.rtcConfiguration;\n    var rtcConstraints = options.rtcConstraints || this._options.rtcConstraints || {};\n    var audioConstraints = {\n      audio: typeof rtcConstraints.audio !== 'undefined' ? rtcConstraints.audio : true\n    };\n    this._status = Call.State.Connecting;\n    var connect = function () {\n      if (_this._status !== Call.State.Connecting) {\n        // call must have been canceled\n        _this._cleanupEventListeners();\n        _this._mediaHandler.close();\n        return;\n      }\n      var onAnswer = function (pc) {\n        // Report that the call was answered, and directionality\n        var eventName = _this._direction === Call.CallDirection.Incoming ? 'accepted-by-local' : 'accepted-by-remote';\n        _this._publisher.info('connection', eventName, null, _this);\n        // Report the preferred codec and params as they appear in the SDP\n        var _a = sdp_1.getPreferredCodecInfo(_this._mediaHandler.version.getSDP()),\n          codecName = _a.codecName,\n          codecParams = _a.codecParams;\n        _this._publisher.info('settings', 'codec', {\n          codec_params: codecParams,\n          selected_codec: codecName\n        }, _this);\n        // Enable RTC monitoring\n        _this._monitor.enable(pc);\n      };\n      var sinkIds = typeof _this._options.getSinkIds === 'function' && _this._options.getSinkIds();\n      if (Array.isArray(sinkIds)) {\n        _this._mediaHandler._setSinkIds(sinkIds).catch(function () {\n          // (rrowland) We don't want this to throw to console since the customer\n          // can't control this. This will most commonly be rejected on browsers\n          // that don't support setting sink IDs.\n        });\n      }\n      _this._pstream.addListener('hangup', _this._onHangup);\n      if (_this._direction === Call.CallDirection.Incoming) {\n        _this._isAnswered = true;\n        _this._pstream.on('answer', _this._onAnswer);\n        _this._mediaHandler.answerIncomingCall(_this.parameters.CallSid, _this._options.offerSdp, rtcConfiguration, onAnswer);\n      } else {\n        var params = Array.from(_this.customParameters.entries()).map(function (pair) {\n          return encodeURIComponent(pair[0]) + \"=\" + encodeURIComponent(pair[1]);\n        }).join('&');\n        _this._pstream.on('answer', _this._onAnswer);\n        _this._mediaHandler.makeOutgoingCall(params, _this._signalingReconnectToken, _this._options.reconnectCallSid || _this.outboundConnectionId, rtcConfiguration, onAnswer);\n      }\n    };\n    if (this._options.beforeAccept) {\n      this._options.beforeAccept(this);\n    }\n    var inputStream = typeof this._options.getInputStream === 'function' && this._options.getInputStream();\n    var promise = inputStream ? this._mediaHandler.setInputTracksFromStream(inputStream) : this._mediaHandler.openDefaultDeviceWithConstraints(audioConstraints);\n    promise.then(function () {\n      _this._publisher.info('get-user-media', 'succeeded', {\n        data: {\n          audioConstraints: audioConstraints\n        }\n      }, _this);\n      connect();\n    }, function (error) {\n      var twilioError;\n      if (error.code === 31208 || ['PermissionDeniedError', 'NotAllowedError'].indexOf(error.name) !== -1) {\n        twilioError = new errors_1.UserMediaErrors.PermissionDeniedError();\n        _this._publisher.error('get-user-media', 'denied', {\n          data: {\n            audioConstraints: audioConstraints,\n            error: error\n          }\n        }, _this);\n      } else {\n        twilioError = new errors_1.UserMediaErrors.AcquisitionFailedError();\n        _this._publisher.error('get-user-media', 'failed', {\n          data: {\n            audioConstraints: audioConstraints,\n            error: error\n          }\n        }, _this);\n      }\n      _this._disconnect();\n      _this._log.debug('#error', error);\n      _this.emit('error', twilioError);\n    });\n  };\n  /**\n   * Disconnect from the {@link Call}.\n   */\n  Call.prototype.disconnect = function () {\n    this._log.debug('.disconnect');\n    this._disconnect();\n  };\n  /**\n   * Get the local MediaStream, if set.\n   */\n  Call.prototype.getLocalStream = function () {\n    return this._mediaHandler && this._mediaHandler.stream;\n  };\n  /**\n   * Get the remote MediaStream, if set.\n   */\n  Call.prototype.getRemoteStream = function () {\n    return this._mediaHandler && this._mediaHandler._remoteStream;\n  };\n  /**\n   * Ignore the incoming {@link Call}.\n   */\n  Call.prototype.ignore = function () {\n    this._log.debug('.ignore');\n    if (this._status !== Call.State.Pending) {\n      this._log.debug(\".ignore noop. status is '\" + this._status + \"'\");\n      return;\n    }\n    this._status = Call.State.Closed;\n    this._mediaHandler.ignore(this.parameters.CallSid);\n    this._publisher.info('connection', 'ignored-by-local', null, this);\n    if (this._onIgnore) {\n      this._onIgnore();\n    }\n  };\n  /**\n   * Check whether call is muted\n   */\n  Call.prototype.isMuted = function () {\n    return this._mediaHandler.isMuted;\n  };\n  /**\n   * Mute incoming audio.\n   * @param shouldMute - Whether the incoming audio should be muted. Defaults to true.\n   */\n  Call.prototype.mute = function (shouldMute) {\n    if (shouldMute === void 0) {\n      shouldMute = true;\n    }\n    this._log.debug('.mute', shouldMute);\n    var wasMuted = this._mediaHandler.isMuted;\n    this._mediaHandler.mute(shouldMute);\n    var isMuted = this._mediaHandler.isMuted;\n    if (wasMuted !== isMuted) {\n      this._publisher.info('connection', isMuted ? 'muted' : 'unmuted', null, this);\n      this._log.debug('#mute', isMuted);\n      this.emit('mute', isMuted, this);\n    }\n  };\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has given call quality feedback. Called without a score, this\n   *   will report that the customer declined to give feedback.\n   * @param score - The end-user's rating of the call; an\n   *   integer 1 through 5. Or undefined if the user declined to give\n   *   feedback.\n   * @param issue - The primary issue the end user\n   *   experienced on the call. Can be: ['one-way-audio', 'choppy-audio',\n   *   'dropped-call', 'audio-latency', 'noisy-call', 'echo']\n   */\n  Call.prototype.postFeedback = function (score, issue) {\n    if (typeof score === 'undefined' || score === null) {\n      return this._postFeedbackDeclined();\n    }\n    if (!Object.values(Call.FeedbackScore).includes(score)) {\n      throw new errors_1.InvalidArgumentError(\"Feedback score must be one of: \" + Object.values(Call.FeedbackScore));\n    }\n    if (typeof issue !== 'undefined' && issue !== null && !Object.values(Call.FeedbackIssue).includes(issue)) {\n      throw new errors_1.InvalidArgumentError(\"Feedback issue must be one of: \" + Object.values(Call.FeedbackIssue));\n    }\n    return this._publisher.info('feedback', 'received', {\n      issue_name: issue,\n      quality_score: score\n    }, this, true);\n  };\n  /**\n   * Reject the incoming {@link Call}.\n   */\n  Call.prototype.reject = function () {\n    this._log.debug('.reject');\n    if (this._status !== Call.State.Pending) {\n      this._log.debug(\".reject noop. status is '\" + this._status + \"'\");\n      return;\n    }\n    this._isRejected = true;\n    this._pstream.reject(this.parameters.CallSid);\n    this._mediaHandler.reject(this.parameters.CallSid);\n    this._publisher.info('connection', 'rejected-by-local', null, this);\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n    this._status = Call.State.Closed;\n    this._log.debug('#reject');\n    this.emit('reject');\n  };\n  /**\n   * Send a string of digits.\n   * @param digits\n   */\n  Call.prototype.sendDigits = function (digits) {\n    var _this = this;\n    this._log.debug('.sendDigits', digits);\n    if (digits.match(/[^0-9*#w]/)) {\n      throw new errors_1.InvalidArgumentError('Illegal character passed into sendDigits');\n    }\n    var customSounds = this._options.customSounds || {};\n    var sequence = [];\n    digits.split('').forEach(function (digit) {\n      var dtmf = digit !== 'w' ? \"dtmf\" + digit : '';\n      if (dtmf === 'dtmf*') {\n        dtmf = 'dtmfs';\n      }\n      if (dtmf === 'dtmf#') {\n        dtmf = 'dtmfh';\n      }\n      sequence.push(dtmf);\n    });\n    var playNextDigit = function () {\n      var digit = sequence.shift();\n      if (digit) {\n        if (_this._options.dialtonePlayer && !customSounds[digit]) {\n          _this._options.dialtonePlayer.play(digit);\n        } else {\n          _this._soundcache.get(digit).play();\n        }\n      }\n      if (sequence.length) {\n        setTimeout(function () {\n          return playNextDigit();\n        }, 200);\n      }\n    };\n    playNextDigit();\n    var dtmfSender = this._mediaHandler.getOrCreateDTMFSender();\n    function insertDTMF(dtmfs) {\n      if (!dtmfs.length) {\n        return;\n      }\n      var dtmf = dtmfs.shift();\n      if (dtmf && dtmf.length) {\n        dtmfSender.insertDTMF(dtmf, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);\n      }\n      setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);\n    }\n    if (dtmfSender) {\n      if (!('canInsertDTMF' in dtmfSender) || dtmfSender.canInsertDTMF) {\n        this._log.info('Sending digits using RTCDTMFSender');\n        // NOTE(mroberts): We can't just map 'w' to ',' since\n        // RTCDTMFSender's pause duration is 2 s and Twilio's is more\n        // like 500 ms. Instead, we will fudge it with setTimeout.\n        insertDTMF(digits.split('w'));\n        return;\n      }\n      this._log.info('RTCDTMFSender cannot insert DTMF');\n    }\n    // send pstream message to send DTMF\n    this._log.info('Sending digits over PStream');\n    if (this._pstream !== null && this._pstream.status !== 'disconnected') {\n      this._pstream.dtmf(this.parameters.CallSid, digits);\n    } else {\n      var error = new errors_1.GeneralErrors.ConnectionError('Could not send DTMF: Signaling channel is disconnected');\n      this._log.debug('#error', error);\n      this.emit('error', error);\n    }\n  };\n  /**\n   * Send a message to Twilio. Your backend application can listen for these\n   * messages to allow communication between your frontend and backend applications.\n   * <br/><br/>This feature is currently in Beta.\n   * @param message - The message object to send.\n   * @returns A voice event sid that uniquely identifies the message that was sent.\n   */\n  Call.prototype.sendMessage = function (message) {\n    this._log.debug('.sendMessage', JSON.stringify(message));\n    var content = message.content,\n      contentType = message.contentType,\n      messageType = message.messageType;\n    if (typeof content === 'undefined' || content === null) {\n      throw new errors_1.InvalidArgumentError('`content` is empty');\n    }\n    if (typeof messageType !== 'string') {\n      throw new errors_1.InvalidArgumentError('`messageType` must be a string.');\n    }\n    if (messageType.length === 0) {\n      throw new errors_1.InvalidArgumentError('`messageType` must be a non-empty string.');\n    }\n    if (this._pstream === null) {\n      throw new errors_1.InvalidStateError('Could not send CallMessage; Signaling channel is disconnected');\n    }\n    var callSid = this.parameters.CallSid;\n    if (typeof this.parameters.CallSid === 'undefined') {\n      throw new errors_1.InvalidStateError('Could not send CallMessage; Call has no CallSid');\n    }\n    var voiceEventSid = this._voiceEventSidGenerator();\n    this._messages.set(voiceEventSid, {\n      content: content,\n      contentType: contentType,\n      messageType: messageType,\n      voiceEventSid: voiceEventSid\n    });\n    this._pstream.sendMessage(callSid, content, contentType, messageType, voiceEventSid);\n    return voiceEventSid;\n  };\n  /**\n   * Get the current {@link Call} status.\n   */\n  Call.prototype.status = function () {\n    return this._status;\n  };\n  /**\n   * Check the volume passed, emitting a warning if one way audio is detected or cleared.\n   * @param currentVolume - The current volume for this direction\n   * @param streakFieldName - The name of the field on the {@link Call} object that tracks how many times the\n   *   current value has been repeated consecutively.\n   * @param lastValueFieldName - The name of the field on the {@link Call} object that tracks the most recent\n   *   volume for this direction\n   * @param direction - The directionality of this audio track, either 'input' or 'output'\n   * @returns The current streak; how many times in a row the same value has been polled.\n   */\n  Call.prototype._checkVolume = function (currentVolume, currentStreak, lastValue, direction) {\n    var wasWarningRaised = currentStreak >= 10;\n    var newStreak = 0;\n    if (lastValue === currentVolume) {\n      newStreak = currentStreak;\n    }\n    if (newStreak >= 10) {\n      this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, false);\n    } else if (wasWarningRaised) {\n      this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, true);\n    }\n    return newStreak;\n  };\n  /**\n   * Clean up event listeners.\n   */\n  Call.prototype._cleanupEventListeners = function () {\n    var _this = this;\n    var cleanup = function () {\n      if (!_this._pstream) {\n        return;\n      }\n      _this._pstream.removeListener('ack', _this._onAck);\n      _this._pstream.removeListener('answer', _this._onAnswer);\n      _this._pstream.removeListener('cancel', _this._onCancel);\n      _this._pstream.removeListener('error', _this._onSignalingError);\n      _this._pstream.removeListener('hangup', _this._onHangup);\n      _this._pstream.removeListener('ringing', _this._onRinging);\n      _this._pstream.removeListener('transportClose', _this._onTransportClose);\n      _this._pstream.removeListener('connected', _this._onConnected);\n      _this._pstream.removeListener('message', _this._onMessageReceived);\n    };\n    // This is kind of a hack, but it lets us avoid rewriting more code.\n    // Basically, there's a sequencing problem with the way PeerConnection raises\n    // the\n    //\n    //   Cannot establish call. SDK is disconnected\n    //\n    // error in Call#accept. It calls PeerConnection#onerror, which emits\n    // the error event on Call. An error handler on Call then calls\n    // cleanupEventListeners, but then control returns to Call#accept. It's\n    // at this point that we add a listener for the answer event that never gets\n    // removed. setTimeout will allow us to rerun cleanup again, _after_\n    // Call#accept returns.\n    cleanup();\n    setTimeout(cleanup, 0);\n  };\n  /**\n   * Create the payload wrapper for a batch of metrics to be sent to Insights.\n   */\n  Call.prototype._createMetricPayload = function () {\n    var payload = {\n      call_sid: this.parameters.CallSid,\n      dscp: !!this._options.dscp,\n      sdk_version: constants_1.RELEASE_VERSION\n    };\n    if (this._options.gateway) {\n      payload.gateway = this._options.gateway;\n    }\n    payload.direction = this._direction;\n    return payload;\n  };\n  /**\n   * Disconnect the {@link Call}.\n   * @param message - A message explaining why the {@link Call} is being disconnected.\n   * @param wasRemote - Whether the disconnect was triggered locally or remotely.\n   */\n  Call.prototype._disconnect = function (message, wasRemote) {\n    message = typeof message === 'string' ? message : null;\n    if (this._status !== Call.State.Open && this._status !== Call.State.Connecting && this._status !== Call.State.Reconnecting && this._status !== Call.State.Ringing) {\n      return;\n    }\n    this._log.info('Disconnecting...');\n    // send pstream hangup message\n    if (this._pstream !== null && this._pstream.status !== 'disconnected' && this._shouldSendHangup) {\n      var callsid = this.parameters.CallSid || this.outboundConnectionId;\n      if (callsid) {\n        this._pstream.hangup(callsid, message);\n      }\n    }\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n    if (!wasRemote) {\n      this._publisher.info('connection', 'disconnected-by-local', null, this);\n    }\n  };\n  /**\n   * Transition to {@link CallStatus.Open} if criteria is met.\n   */\n  Call.prototype._maybeTransitionToOpen = function () {\n    var wasConnected = this._wasConnected;\n    if (this._isAnswered) {\n      this._onSignalingReconnected();\n      this._signalingStatus = Call.State.Open;\n      if (this._mediaHandler && this._mediaHandler.status === 'open') {\n        this._status = Call.State.Open;\n        if (!this._wasConnected) {\n          this._wasConnected = true;\n          this._log.debug('#accept');\n          this.emit('accept', this);\n        }\n      }\n    }\n  };\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has ignored a request for feedback.\n   */\n  Call.prototype._postFeedbackDeclined = function () {\n    return this._publisher.info('feedback', 'received-none', null, this, true);\n  };\n  /**\n   * Publish the current set of queued metrics samples to Insights.\n   */\n  Call.prototype._publishMetrics = function () {\n    var _this = this;\n    if (this._metricsSamples.length === 0) {\n      return;\n    }\n    this._publisher.postMetrics('quality-metrics-samples', 'metrics-sample', this._metricsSamples.splice(0), this._createMetricPayload(), this).catch(function (e) {\n      _this._log.warn('Unable to post metrics to Insights. Received error:', e);\n    });\n  };\n  /**\n   * Set the CallSid\n   * @param payload\n   */\n  Call.prototype._setCallSid = function (payload) {\n    var callSid = payload.callsid;\n    if (!callSid) {\n      return;\n    }\n    this.parameters.CallSid = callSid;\n    this._mediaHandler.callSid = callSid;\n  };\n  /**\n   * String representation of the {@link Call} class.\n   * @private\n   */\n  Call.toString = function () {\n    return '[Twilio.Call class]';\n  };\n  return Call;\n}(events_1.EventEmitter);\n(function (Call) {\n  /**\n   * Possible states of the {@link Call}.\n   */\n  var State;\n  (function (State) {\n    State[\"Closed\"] = \"closed\";\n    State[\"Connecting\"] = \"connecting\";\n    State[\"Open\"] = \"open\";\n    State[\"Pending\"] = \"pending\";\n    State[\"Reconnecting\"] = \"reconnecting\";\n    State[\"Ringing\"] = \"ringing\";\n  })(State = Call.State || (Call.State = {}));\n  /**\n   * Different issues that may have been experienced during a call, that can be\n   * reported to Twilio Insights via {@link Call}.postFeedback().\n   */\n  var FeedbackIssue;\n  (function (FeedbackIssue) {\n    FeedbackIssue[\"AudioLatency\"] = \"audio-latency\";\n    FeedbackIssue[\"ChoppyAudio\"] = \"choppy-audio\";\n    FeedbackIssue[\"DroppedCall\"] = \"dropped-call\";\n    FeedbackIssue[\"Echo\"] = \"echo\";\n    FeedbackIssue[\"NoisyCall\"] = \"noisy-call\";\n    FeedbackIssue[\"OneWayAudio\"] = \"one-way-audio\";\n  })(FeedbackIssue = Call.FeedbackIssue || (Call.FeedbackIssue = {}));\n  /**\n   * A rating of call quality experienced during a call, to be reported to Twilio Insights\n   * via {@link Call}.postFeedback().\n   */\n  var FeedbackScore;\n  (function (FeedbackScore) {\n    FeedbackScore[FeedbackScore[\"One\"] = 1] = \"One\";\n    FeedbackScore[FeedbackScore[\"Two\"] = 2] = \"Two\";\n    FeedbackScore[FeedbackScore[\"Three\"] = 3] = \"Three\";\n    FeedbackScore[FeedbackScore[\"Four\"] = 4] = \"Four\";\n    FeedbackScore[FeedbackScore[\"Five\"] = 5] = \"Five\";\n  })(FeedbackScore = Call.FeedbackScore || (Call.FeedbackScore = {}));\n  /**\n   * The directionality of the {@link Call}, whether incoming or outgoing.\n   */\n  var CallDirection;\n  (function (CallDirection) {\n    CallDirection[\"Incoming\"] = \"INCOMING\";\n    CallDirection[\"Outgoing\"] = \"OUTGOING\";\n  })(CallDirection = Call.CallDirection || (Call.CallDirection = {}));\n  /**\n   * Valid audio codecs to use for the media connection.\n   */\n  var Codec;\n  (function (Codec) {\n    Codec[\"Opus\"] = \"opus\";\n    Codec[\"PCMU\"] = \"pcmu\";\n  })(Codec = Call.Codec || (Call.Codec = {}));\n  /**\n   * Possible ICE Gathering failures\n   */\n  var IceGatheringFailureReason;\n  (function (IceGatheringFailureReason) {\n    IceGatheringFailureReason[\"None\"] = \"none\";\n    IceGatheringFailureReason[\"Timeout\"] = \"timeout\";\n  })(IceGatheringFailureReason = Call.IceGatheringFailureReason || (Call.IceGatheringFailureReason = {}));\n  /**\n   * Possible media failures\n   */\n  var MediaFailure;\n  (function (MediaFailure) {\n    MediaFailure[\"ConnectionDisconnected\"] = \"ConnectionDisconnected\";\n    MediaFailure[\"ConnectionFailed\"] = \"ConnectionFailed\";\n    MediaFailure[\"IceGatheringFailed\"] = \"IceGatheringFailed\";\n    MediaFailure[\"LowBytes\"] = \"LowBytes\";\n  })(MediaFailure = Call.MediaFailure || (Call.MediaFailure = {}));\n})(Call || (Call = {}));\nfunction generateTempCallSid() {\n  return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    /* tslint:disable:no-bitwise */\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    /* tslint:enable:no-bitwise */\n    return v.toString(16);\n  });\n}\nexports.default = Call;","map":{"version":3,"names":["events_1","require","backoff_1","device_1","errors_1","log_1","rtc_1","icecandidate_1","sdp_1","statsMonitor_1","util_1","uuid_1","constants_1","BACKOFF_CONFIG","factor","jitter","max","min","DTMF_INTER_TONE_GAP","DTMF_PAUSE_DURATION","DTMF_TONE_DURATION","METRICS_BATCH_SIZE","METRICS_DELAY","MEDIA_DISCONNECT_ERROR","disconnect","info","code","message","twilioError","MediaErrors","ConnectionError","MULTIPLE_THRESHOLD_WARNING_NAMES","packetsLostFraction","maxAverage","WARNING_NAMES","audioInputLevel","audioOutputLevel","bytesReceived","bytesSent","mos","rtt","WARNING_PREFIXES","maxDuration","minStandardDeviation","Call","_super","__extends","config","options","_this","call","parameters","_inputVolumeStreak","_isAnswered","_isCancelled","_isRejected","_latestInputVolume","_latestOutputVolume","_log","default","_mediaStatus","State","Pending","_messages","Map","_metricsSamples","_options","MediaHandler","PeerConnection","enableImprovedSignalingErrorPrecision","offerSdp","shouldPlayDisconnect","voiceEventSidGenerator","generateVoiceEventSid","_outputVolumeStreak","_shouldSendHangup","_signalingStatus","_soundcache","_status","_wasConnected","toString","_emitWarning","groupPrefix","warningName","threshold","value","wasCleared","warningData","groupSuffix","groupName","isMuted","level","payloadData","Array","values","map","val","Math","round","_publisher","post","data","emitName","debug","emit","_onAck","payload","acktype","callsid","voiceeventsid","CallSid","warn","_onMessageSent","_onAnswer","reconnect","_signalingReconnectToken","Reconnecting","_setCallSid","_maybeTransitionToOpen","_onCancel","_cleanupEventListeners","_mediaHandler","close","Closed","_pstream","removeListener","_onConnected","version","getSDP","_onHangup","status","outboundConnectionId","error","errorConstructor","getPreciseSignalingErrorByCode","GeneralErrors","_disconnect","_onMediaFailure","type","_a","MediaFailure","ConnectionDisconnected","ConnectionFailed","IceGatheringFailed","LowBytes","isEndOfIceCycle","isChrome","window","navigator","onerror","Date","now","_mediaReconnectStartTime","_mediaReconnectBackoff","backoff","pc","isIceDisconnected","iceConnectionState","hasLowBytesWarning","_monitor","hasActiveWarning","mediaReconnectionError","reset","_onMediaReconnected","Open","_onMessageReceived","content","contenttype","messagetype","contentType","messageType","voiceEventSid","content_type","event_type","voice_event_sid","JSON","stringify","has","get","delete","_onRinging","Connecting","Ringing","hasEarlyMedia","sdp","_onRTCSample","sample","callMetrics","__assign","inputVolume","outputVolume","_codec","codecName","push","length","_publishMetrics","_onSignalingError","UnknownError","_onSignalingReconnected","_onTransportClose","SignalingErrors","_reemitWarning","test","name","warningPrefix","warning","_reemitWarningCleared","_isUnifiedPlanDefault","isUnifiedPlanDefault","soundcache","onIgnore","_onIgnore","twimlParams","customParameters","Object","entries","key","String","assign","callParameters","reconnectToken","_voiceEventSidGenerator","_direction","reconnectCallSid","CallDirection","Incoming","Outgoing","callerInfo","StirStatus","isVerified","on","iceRestart","generateTempCallSid","publisher","preflight","monitor","StatsMonitor","disableWarnings","setTimeout","enableWarnings","audioHelper","pstream","RTCPeerConnection","codecPreferences","dscp","forceAggressiveIceNomination","isUnifiedPlan","maxAverageBitrate","_checkVolume","onaudio","remoteAudio","onvolume","internalInputVolume","internalOutputVolume","addVolumes","ondtlstransportstatechange","state","onpcconnectionstatechange","dtlsTransport","getRTCDtlsTransport","onicecandidate","candidate","IceCandidate","toPayload","onselectedcandidatepairchange","pair","localCandidatePayload","local","remoteCandidatePayload","remote","local_candidate","remote_candidate","oniceconnectionstatechange","onicegatheringfailure","onicegatheringstatechange","onsignalingstatechange","ondisconnected","msg","onfailed","onconnected","onreconnected","e","onopen","mute","onclose","SoundName","Disconnect","play","disable","defineProperty","prototype","signalingReconnectToken","callSid","undefined","keys","from","reduce","result","btoa","encodeURIComponent","_setInputTracksFromStream","stream","setInputTracksFromStream","_setSinkIds","sinkIds","accept","rtcConfiguration","rtcConstraints","audioConstraints","audio","connect","onAnswer","eventName","getPreferredCodecInfo","codecParams","codec_params","selected_codec","enable","getSinkIds","isArray","catch","addListener","answerIncomingCall","params","join","makeOutgoingCall","beforeAccept","inputStream","getInputStream","promise","openDefaultDeviceWithConstraints","then","indexOf","UserMediaErrors","PermissionDeniedError","AcquisitionFailedError","getLocalStream","getRemoteStream","_remoteStream","ignore","shouldMute","wasMuted","postFeedback","score","issue","_postFeedbackDeclined","FeedbackScore","includes","InvalidArgumentError","FeedbackIssue","issue_name","quality_score","reject","sendDigits","digits","match","customSounds","sequence","split","forEach","digit","dtmf","playNextDigit","shift","dialtonePlayer","dtmfSender","getOrCreateDTMFSender","insertDTMF","dtmfs","bind","canInsertDTMF","sendMessage","InvalidStateError","set","currentVolume","currentStreak","lastValue","direction","wasWarningRaised","newStreak","cleanup","_createMetricPayload","call_sid","sdk_version","RELEASE_VERSION","gateway","wasRemote","hangup","wasConnected","postMetrics","splice","EventEmitter","Codec","IceGatheringFailureReason","replace","c","r","random","v","exports"],"sources":["C:\\Users\\91629\\Desktop\\Delote\\calling software\\node_modules\\@twilio\\voice-sdk\\lib\\twilio\\call.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\nimport { EventEmitter } from 'events';\nimport Backoff from './backoff';\nimport Device from './device';\nimport DialtonePlayer from './dialtonePlayer';\nimport {\n  GeneralErrors,\n  getPreciseSignalingErrorByCode,\n  InvalidArgumentError,\n  InvalidStateError,\n  MediaErrors,\n  SignalingErrors,\n  TwilioError,\n  UserMediaErrors,\n} from './errors';\nimport Log from './log';\nimport { PeerConnection } from './rtc';\nimport { IceCandidate, RTCIceCandidate } from './rtc/icecandidate';\nimport RTCSample from './rtc/sample';\nimport { getPreferredCodecInfo } from './rtc/sdp';\nimport RTCWarning from './rtc/warning';\nimport StatsMonitor from './statsMonitor';\nimport { isChrome } from './util';\nimport { generateVoiceEventSid } from './uuid';\n\nimport { RELEASE_VERSION } from './constants';\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IAudioHelper = any;\n/**\n * @private\n */\nexport type IPStream = any;\n/**\n * @private\n */\nexport type IPeerConnection = any;\n/**\n * @private\n */\nexport type IPublisher = any;\n/**\n * @private\n */\nexport type ISound = any;\n\nconst BACKOFF_CONFIG = {\n  factor: 1.1,\n  jitter: 0.5,\n  max: 30000,\n  min: 1,\n};\n\nconst DTMF_INTER_TONE_GAP: number = 70;\nconst DTMF_PAUSE_DURATION: number = 500;\nconst DTMF_TONE_DURATION: number = 160;\n\nconst METRICS_BATCH_SIZE: number = 10;\nconst METRICS_DELAY: number = 5000;\n\nconst MEDIA_DISCONNECT_ERROR = {\n  disconnect: true,\n  info: {\n    code: 31003,\n    message: 'Connection with Twilio was interrupted.',\n    twilioError: new MediaErrors.ConnectionError(),\n  },\n};\n\nconst MULTIPLE_THRESHOLD_WARNING_NAMES: Record<string, Record<string, string>> = {\n  // The stat `packetsLostFraction` is monitored by two separate thresholds,\n  // `maxAverage` and `max`. Each threshold emits a different warning name.\n  packetsLostFraction: {\n    max: 'packet-loss',\n    maxAverage: 'packets-lost-fraction',\n  },\n};\n\nconst WARNING_NAMES: Record<string, string> = {\n  audioInputLevel: 'audio-input-level',\n  audioOutputLevel: 'audio-output-level',\n  bytesReceived: 'bytes-received',\n  bytesSent: 'bytes-sent',\n  jitter: 'jitter',\n  mos: 'mos',\n  rtt: 'rtt',\n};\n\nconst WARNING_PREFIXES: Record<string, string> = {\n  max: 'high-',\n  maxAverage: 'high-',\n  maxDuration: 'constant-',\n  min: 'low-',\n  minStandardDeviation: 'constant-',\n};\n\n/**\n * A {@link Call} represents a media and signaling connection to a TwiML application.\n * @publicapi\n */\nclass Call extends EventEmitter {\n  /**\n   * String representation of the {@link Call} class.\n   * @private\n   */\n  static toString = () => '[Twilio.Call class]';\n\n  /**\n   * Returns caller verification information about the caller.\n   * If no caller verification information is available this will return null.\n   */\n  readonly callerInfo: Call.CallerInfo | null;\n\n  /**\n   * The custom parameters sent to (outgoing) or received by (incoming) the TwiML app.\n   */\n  readonly customParameters: Map<string, string>;\n\n  /**\n   * Whether this {@link Call} is incoming or outgoing.\n   */\n  get direction(): Call.CallDirection {\n    return this._direction;\n  }\n\n  /**\n   * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n   * will copy whatever we get from RTC stats.\n   */\n  get codec(): string {\n    return this._codec;\n  }\n\n  /**\n   * The connect token is available as soon as the call is established\n   * and connected to Twilio. Use this token to reconnect to a call via the {@link Device.connect}\n   * method.\n   *\n   * For incoming calls, it is available in the call object after the {@link Device.incomingEvent} is emitted.\n   * For outgoing calls, it is available after the {@link Call.acceptEvent} is emitted.\n   */\n  get connectToken(): string | undefined {\n    const signalingReconnectToken = this._signalingReconnectToken;\n    const callSid = this.parameters && this.parameters.CallSid ? this.parameters.CallSid : undefined;\n\n    if (!signalingReconnectToken || !callSid) {\n      return;\n    }\n\n    const customParameters = this.customParameters && typeof this.customParameters.keys === 'function' ?\n    Array.from(this.customParameters.keys()).reduce((result: Record<string, string>, key: string) => {\n      result[key] = this.customParameters.get(key)!;\n      return result;\n    }, {}) : {};\n\n    const parameters = this.parameters || {};\n\n    return btoa(encodeURIComponent(JSON.stringify({\n      customParameters,\n      parameters,\n      signalingReconnectToken,\n    })));\n  }\n\n  /**\n   * The temporary CallSid for this call, if it's outbound.\n   */\n  readonly outboundConnectionId?: string;\n\n  /**\n   * Call parameters received from Twilio for an incoming call.\n   */\n  parameters: Record<string, string> = { };\n\n  /**\n   * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n   * will copy whatever we get from RTC stats.\n   */\n  private _codec: string;\n\n  /**\n   * Whether this {@link Call} is incoming or outgoing.\n   */\n  private readonly _direction: Call.CallDirection;\n\n  /**\n   * The number of times input volume has been the same consecutively.\n   */\n  private _inputVolumeStreak: number = 0;\n\n  /**\n   * Whether the call has been answered.\n   */\n  private _isAnswered: boolean = false;\n\n  /**\n   * Whether the call has been cancelled.\n   */\n  private _isCancelled: boolean = false;\n\n  /**\n   * Whether the call has been rejected\n   */\n  private _isRejected: boolean = false;\n\n  /**\n   * Whether or not the browser uses unified-plan SDP by default.\n   */\n  private readonly _isUnifiedPlanDefault: boolean | undefined;\n\n  /**\n   * The most recent public input volume value. 0 -> 1 representing -100 to -30 dB.\n   */\n  private _latestInputVolume: number = 0;\n\n  /**\n   * The most recent public output volume value. 0 -> 1 representing -100 to -30 dB.\n   */\n  private _latestOutputVolume: number = 0;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = new Log('Call');\n\n  /**\n   * The MediaHandler (Twilio PeerConnection) this {@link Call} is using for\n   * media signaling.\n   */\n  private _mediaHandler: IPeerConnection;\n\n  /**\n   * An instance of Backoff for media reconnection\n   */\n  private _mediaReconnectBackoff: any;\n\n  /**\n   * Timestamp for the initial media reconnection\n   */\n  private _mediaReconnectStartTime: number;\n\n  /**\n   * State of the {@link Call}'s media.\n   */\n  private _mediaStatus: Call.State = Call.State.Pending;\n\n  /**\n   * A map of messages sent via sendMessage API using voiceEventSid as the key.\n   * The message will be deleted once an 'ack' or an error is received from the server.\n   */\n  private _messages: Map<string, Call.Message> = new Map();\n\n  /**\n   * A batch of metrics samples to send to Insights. Gets cleared after\n   * each send and appended to on each new sample.\n   */\n  private readonly _metricsSamples: Call.CallMetrics[] = [];\n\n  /**\n   * An instance of StatsMonitor.\n   */\n  private readonly _monitor: StatsMonitor;\n\n  /**\n   * Method to be run after {@link Call.ignore} is called.\n   */\n  private _onIgnore: () => void;\n\n  /**\n   * Options passed to this {@link Call}.\n   */\n  private _options: Call.Options = {\n    MediaHandler: PeerConnection,\n    enableImprovedSignalingErrorPrecision: false,\n    offerSdp: null,\n    shouldPlayDisconnect: () => true,\n    voiceEventSidGenerator: generateVoiceEventSid,\n  };\n\n  /**\n   * The number of times output volume has been the same consecutively.\n   */\n  private _outputVolumeStreak: number = 0;\n\n  /**\n   * The PStream instance to use for Twilio call signaling.\n   */\n  private readonly _pstream: IPStream;\n\n  /**\n   * An instance of EventPublisher.\n   */\n  private readonly _publisher: IPublisher;\n\n  /**\n   * Whether the {@link Call} should send a hangup on disconnect.\n   */\n  private _shouldSendHangup: boolean = true;\n\n  /**\n   * The signaling reconnection token used to re-establish a lost signaling connection.\n   */\n  private _signalingReconnectToken: string | undefined;\n\n  /**\n   * State of the {@link Call}'s signaling.\n   */\n  private _signalingStatus: Call.State = Call.State.Pending;\n\n  /**\n   * A Map of Sounds to play.\n   */\n  private readonly _soundcache: Map<Device.SoundName, ISound> = new Map();\n\n  /**\n   * State of the {@link Call}.\n   */\n  private _status: Call.State = Call.State.Pending;\n\n  /**\n   * Voice event SID generator, creates a unique voice event SID.\n   */\n  private _voiceEventSidGenerator: () => string;\n\n  /**\n   * Whether the {@link Call} has been connected. Used to determine if we are reconnected.\n   */\n  private _wasConnected: boolean = false;\n\n  /**\n   * @constructor\n   * @private\n   * @param config - Mandatory configuration options\n   * @param [options] - Optional settings\n   */\n  constructor(config: Call.Config, options?: Call.Options) {\n    super();\n\n    this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;\n    this._soundcache = config.soundcache;\n\n    if (typeof config.onIgnore === 'function') {\n      this._onIgnore = config.onIgnore;\n    }\n\n    const message = options && options.twimlParams || { };\n    this.customParameters = new Map(\n      Object.entries(message).map(([key, val]: [string, any]): [string, string] => [key, String(val)]));\n\n    Object.assign(this._options, options);\n\n    if (this._options.callParameters) {\n      this.parameters = this._options.callParameters;\n    }\n\n    if (this._options.reconnectToken) {\n      this._signalingReconnectToken = this._options.reconnectToken;\n    }\n\n    this._voiceEventSidGenerator =\n      this._options.voiceEventSidGenerator || generateVoiceEventSid;\n\n    this._direction = this.parameters.CallSid && !this._options.reconnectCallSid ?\n      Call.CallDirection.Incoming : Call.CallDirection.Outgoing;\n\n    if (this.parameters) {\n      this.callerInfo = this.parameters.StirStatus\n        ? { isVerified: this.parameters.StirStatus === 'TN-Validation-Passed-A' }\n        : null;\n    } else {\n      this.callerInfo = null;\n    }\n\n    this._mediaReconnectBackoff = new Backoff(BACKOFF_CONFIG);\n    this._mediaReconnectBackoff.on('ready', () => this._mediaHandler.iceRestart());\n\n    // temporary call sid to be used for outgoing calls\n    this.outboundConnectionId = generateTempCallSid();\n\n    const publisher = this._publisher = config.publisher;\n\n    if (this._direction === Call.CallDirection.Incoming) {\n      publisher.info('connection', 'incoming', null, this);\n    } else {\n      publisher.info('connection', 'outgoing', {\n        preflight: this._options.preflight,\n        reconnect: !!this._options.reconnectCallSid,\n      }, this);\n    }\n\n    const monitor = this._monitor = new (this._options.StatsMonitor || StatsMonitor)();\n    monitor.on('sample', this._onRTCSample);\n\n    // First 20 seconds or so are choppy, so let's not bother with these warnings.\n    monitor.disableWarnings();\n    setTimeout(() => monitor.enableWarnings(), METRICS_DELAY);\n\n    monitor.on('warning', (data: RTCWarning, wasCleared?: boolean) => {\n      if (data.name === 'bytesSent' || data.name === 'bytesReceived') {\n        this._onMediaFailure(Call.MediaFailure.LowBytes);\n      }\n      this._reemitWarning(data, wasCleared);\n    });\n    monitor.on('warning-cleared', (data: RTCWarning) => {\n      this._reemitWarningCleared(data);\n    });\n\n    this._mediaHandler = new (this._options.MediaHandler)\n      (config.audioHelper, config.pstream, {\n        RTCPeerConnection: this._options.RTCPeerConnection,\n        codecPreferences: this._options.codecPreferences,\n        dscp: this._options.dscp,\n        forceAggressiveIceNomination: this._options.forceAggressiveIceNomination,\n        isUnifiedPlan: this._isUnifiedPlanDefault,\n        maxAverageBitrate: this._options.maxAverageBitrate,\n      });\n\n    this.on('volume', (inputVolume: number, outputVolume: number): void => {\n      this._inputVolumeStreak = this._checkVolume(\n        inputVolume, this._inputVolumeStreak, this._latestInputVolume, 'input');\n      this._outputVolumeStreak = this._checkVolume(\n        outputVolume, this._outputVolumeStreak, this._latestOutputVolume, 'output');\n      this._latestInputVolume = inputVolume;\n      this._latestOutputVolume = outputVolume;\n    });\n\n    this._mediaHandler.onaudio = (remoteAudio: typeof Audio) => {\n      this._log.debug('#audio');\n      this.emit('audio', remoteAudio);\n    };\n\n    this._mediaHandler.onvolume = (inputVolume: number, outputVolume: number,\n                                   internalInputVolume: number, internalOutputVolume: number) => {\n      // (rrowland) These values mock the 0 -> 32767 format used by legacy getStats. We should look into\n      // migrating to a newer standard, either 0.0 -> linear or -127 to 0 in dB, matching the range\n      // chosen below.\n      monitor.addVolumes((internalInputVolume / 255) * 32767, (internalOutputVolume / 255) * 32767);\n\n      // (rrowland) 0.0 -> 1.0 linear\n      this.emit('volume', inputVolume, outputVolume);\n    };\n\n    this._mediaHandler.ondtlstransportstatechange = (state: string): void => {\n      const level = state === 'failed' ? 'error' : 'debug';\n      this._publisher.post(level, 'dtls-transport-state', state, null, this);\n    };\n\n    this._mediaHandler.onpcconnectionstatechange = (state: string): void => {\n      let level = 'debug';\n      const dtlsTransport = this._mediaHandler.getRTCDtlsTransport();\n\n      if (state === 'failed') {\n        level = dtlsTransport && dtlsTransport.state === 'failed' ? 'error' : 'warning';\n      }\n      this._publisher.post(level, 'pc-connection-state', state, null, this);\n    };\n\n    this._mediaHandler.onicecandidate = (candidate: RTCIceCandidate): void => {\n      const payload = new IceCandidate(candidate).toPayload();\n      this._publisher.debug('ice-candidate', 'ice-candidate', payload, this);\n    };\n\n    this._mediaHandler.onselectedcandidatepairchange = (pair: RTCIceCandidatePair): void => {\n      const localCandidatePayload = new IceCandidate(pair.local).toPayload();\n      const remoteCandidatePayload = new IceCandidate(pair.remote, true).toPayload();\n\n      this._publisher.debug('ice-candidate', 'selected-ice-candidate-pair', {\n        local_candidate: localCandidatePayload,\n        remote_candidate: remoteCandidatePayload,\n      }, this);\n    };\n\n    this._mediaHandler.oniceconnectionstatechange = (state: string): void => {\n      const level = state === 'failed' ? 'error' : 'debug';\n      this._publisher.post(level, 'ice-connection-state', state, null, this);\n    };\n\n    this._mediaHandler.onicegatheringfailure = (type: Call.IceGatheringFailureReason): void => {\n      this._publisher.warn('ice-gathering-state', type, null, this);\n      this._onMediaFailure(Call.MediaFailure.IceGatheringFailed);\n    };\n\n    this._mediaHandler.onicegatheringstatechange = (state: string): void => {\n      this._publisher.debug('ice-gathering-state', state, null, this);\n    };\n\n    this._mediaHandler.onsignalingstatechange = (state: string): void => {\n      this._publisher.debug('signaling-state', state, null, this);\n    };\n\n    this._mediaHandler.ondisconnected = (msg: string): void => {\n      this._log.warn(msg);\n      this._publisher.warn('network-quality-warning-raised', 'ice-connectivity-lost', {\n        message: msg,\n      }, this);\n      this._log.debug('#warning', 'ice-connectivity-lost');\n      this.emit('warning', 'ice-connectivity-lost');\n\n      this._onMediaFailure(Call.MediaFailure.ConnectionDisconnected);\n    };\n\n    this._mediaHandler.onfailed = (msg: string): void => {\n      this._onMediaFailure(Call.MediaFailure.ConnectionFailed);\n    };\n\n    this._mediaHandler.onconnected = (): void => {\n      // First time _mediaHandler is connected, but ICE Gathering issued an ICE restart and succeeded.\n      if (this._status === Call.State.Reconnecting) {\n        this._onMediaReconnected();\n      }\n    };\n\n    this._mediaHandler.onreconnected = (msg: string): void => {\n      this._log.info(msg);\n      this._publisher.info('network-quality-warning-cleared', 'ice-connectivity-lost', {\n        message: msg,\n      }, this);\n      this._log.debug('#warning-cleared', 'ice-connectivity-lost');\n      this.emit('warning-cleared', 'ice-connectivity-lost');\n      this._onMediaReconnected();\n    };\n\n    this._mediaHandler.onerror = (e: any): void => {\n      if (e.disconnect === true) {\n        this._disconnect(e.info && e.info.message);\n      }\n\n      const error = e.info.twilioError || new GeneralErrors.UnknownError(e.info.message);\n      this._log.error('Received an error from MediaStream:', e);\n      this._log.debug('#error', error);\n      this.emit('error', error);\n    };\n\n    this._mediaHandler.onopen = () => {\n      // NOTE(mroberts): While this may have been happening in previous\n      // versions of Chrome, since Chrome 45 we have seen the\n      // PeerConnection's onsignalingstatechange handler invoked multiple\n      // times in the same signalingState 'stable'. When this happens, we\n      // invoke this onopen function. If we invoke it twice without checking\n      // for _status 'open', we'd accidentally close the PeerConnection.\n      //\n      // See <https://code.google.com/p/webrtc/issues/detail?id=4996>.\n      if (this._status === Call.State.Open || this._status === Call.State.Reconnecting) {\n        return;\n      } else if (this._status === Call.State.Ringing || this._status === Call.State.Connecting) {\n        this.mute(this._mediaHandler.isMuted);\n        this._mediaStatus = Call.State.Open;\n        this._maybeTransitionToOpen();\n      } else {\n        // call was probably canceled sometime before this\n        this._mediaHandler.close();\n      }\n    };\n\n    this._mediaHandler.onclose = () => {\n      this._status = Call.State.Closed;\n      if (this._options.shouldPlayDisconnect && this._options.shouldPlayDisconnect()\n        // Don't play disconnect sound if this was from a cancel event. i.e. the call\n        // was ignored or hung up even before it was answered.\n        // Similarly, don't play disconnect sound if the call was rejected.\n        && !this._isCancelled && !this._isRejected) {\n\n        this._soundcache.get(Device.SoundName.Disconnect).play();\n      }\n\n      monitor.disable();\n      this._publishMetrics();\n\n      if (!this._isCancelled && !this._isRejected) {\n        // tslint:disable no-console\n        this._log.debug('#disconnect');\n        this.emit('disconnect', this);\n      }\n    };\n\n    this._pstream = config.pstream;\n    this._pstream.on('ack', this._onAck);\n    this._pstream.on('cancel', this._onCancel);\n    this._pstream.on('error', this._onSignalingError);\n    this._pstream.on('ringing', this._onRinging);\n    this._pstream.on('transportClose', this._onTransportClose);\n    this._pstream.on('connected', this._onConnected);\n    this._pstream.on('message', this._onMessageReceived);\n\n    this.on('error', error => {\n      this._publisher.error('connection', 'error', {\n        code: error.code, message: error.message,\n      }, this);\n\n      if (this._pstream && this._pstream.status === 'disconnected') {\n        this._cleanupEventListeners();\n      }\n    });\n\n    this.on('disconnect', () => {\n      this._cleanupEventListeners();\n    });\n  }\n\n  /**\n   * Set the audio input tracks from a given stream.\n   * @param stream\n   * @private\n   */\n  _setInputTracksFromStream(stream: MediaStream | null): Promise<void> {\n    return this._mediaHandler.setInputTracksFromStream(stream);\n  }\n\n  /**\n   * Set the audio output sink IDs.\n   * @param sinkIds\n   * @private\n   */\n  _setSinkIds(sinkIds: string[]): Promise<void> {\n    return this._mediaHandler._setSinkIds(sinkIds);\n  }\n\n  /**\n   * Accept the incoming {@link Call}.\n   * @param [options]\n   */\n  accept(options?: Call.AcceptOptions): void {\n    this._log.debug('.accept', options);\n    if (this._status !== Call.State.Pending) {\n      this._log.debug(`.accept noop. status is '${this._status}'`);\n      return;\n    }\n\n    options = options || { };\n    const rtcConfiguration = options.rtcConfiguration || this._options.rtcConfiguration;\n    const rtcConstraints = options.rtcConstraints || this._options.rtcConstraints || { };\n    const audioConstraints = {\n      audio: typeof rtcConstraints.audio !== 'undefined' ? rtcConstraints.audio : true,\n    };\n\n    this._status = Call.State.Connecting;\n\n    const connect = () => {\n      if (this._status !== Call.State.Connecting) {\n        // call must have been canceled\n        this._cleanupEventListeners();\n        this._mediaHandler.close();\n        return;\n      }\n\n      const onAnswer = (pc: RTCPeerConnection) => {\n        // Report that the call was answered, and directionality\n        const eventName = this._direction === Call.CallDirection.Incoming\n          ? 'accepted-by-local'\n          : 'accepted-by-remote';\n        this._publisher.info('connection', eventName, null, this);\n\n        // Report the preferred codec and params as they appear in the SDP\n        const { codecName, codecParams } = getPreferredCodecInfo(this._mediaHandler.version.getSDP());\n        this._publisher.info('settings', 'codec', {\n          codec_params: codecParams,\n          selected_codec: codecName,\n        }, this);\n\n        // Enable RTC monitoring\n        this._monitor.enable(pc);\n      };\n\n      const sinkIds = typeof this._options.getSinkIds === 'function' && this._options.getSinkIds();\n      if (Array.isArray(sinkIds)) {\n        this._mediaHandler._setSinkIds(sinkIds).catch(() => {\n          // (rrowland) We don't want this to throw to console since the customer\n          // can't control this. This will most commonly be rejected on browsers\n          // that don't support setting sink IDs.\n        });\n      }\n\n      this._pstream.addListener('hangup', this._onHangup);\n\n      if (this._direction === Call.CallDirection.Incoming) {\n        this._isAnswered = true;\n        this._pstream.on('answer', this._onAnswer);\n        this._mediaHandler.answerIncomingCall(this.parameters.CallSid,\n          this._options.offerSdp, rtcConfiguration, onAnswer);\n      } else {\n        const params = Array.from(this.customParameters.entries()).map(pair =>\n         `${encodeURIComponent(pair[0])}=${encodeURIComponent(pair[1])}`).join('&');\n        this._pstream.on('answer', this._onAnswer);\n        this._mediaHandler.makeOutgoingCall(params, this._signalingReconnectToken,\n          this._options.reconnectCallSid || this.outboundConnectionId, rtcConfiguration, onAnswer);\n      }\n    };\n\n    if (this._options.beforeAccept) {\n      this._options.beforeAccept(this);\n    }\n\n    const inputStream = typeof this._options.getInputStream === 'function' && this._options.getInputStream();\n\n    const promise = inputStream\n      ? this._mediaHandler.setInputTracksFromStream(inputStream)\n      : this._mediaHandler.openDefaultDeviceWithConstraints(audioConstraints);\n\n    promise.then(() => {\n      this._publisher.info('get-user-media', 'succeeded', {\n        data: { audioConstraints },\n      }, this);\n\n      connect();\n    }, (error: Record<string, any>) => {\n      let twilioError;\n\n      if (error.code === 31208\n        || ['PermissionDeniedError', 'NotAllowedError'].indexOf(error.name) !== -1) {\n        twilioError = new UserMediaErrors.PermissionDeniedError();\n        this._publisher.error('get-user-media', 'denied', {\n          data: {\n            audioConstraints,\n            error,\n          },\n        }, this);\n      } else {\n        twilioError = new UserMediaErrors.AcquisitionFailedError();\n\n        this._publisher.error('get-user-media', 'failed', {\n          data: {\n            audioConstraints,\n            error,\n          },\n        }, this);\n      }\n\n      this._disconnect();\n      this._log.debug('#error', error);\n      this.emit('error', twilioError);\n    });\n  }\n\n  /**\n   * Disconnect from the {@link Call}.\n   */\n  disconnect(): void {\n    this._log.debug('.disconnect');\n    this._disconnect();\n  }\n\n  /**\n   * Get the local MediaStream, if set.\n   */\n  getLocalStream(): MediaStream | undefined {\n    return this._mediaHandler && this._mediaHandler.stream;\n  }\n\n  /**\n   * Get the remote MediaStream, if set.\n   */\n  getRemoteStream(): MediaStream | undefined {\n    return this._mediaHandler && this._mediaHandler._remoteStream;\n  }\n\n  /**\n   * Ignore the incoming {@link Call}.\n   */\n  ignore(): void {\n    this._log.debug('.ignore');\n    if (this._status !== Call.State.Pending) {\n      this._log.debug(`.ignore noop. status is '${this._status}'`);\n      return;\n    }\n\n    this._status = Call.State.Closed;\n    this._mediaHandler.ignore(this.parameters.CallSid);\n    this._publisher.info('connection', 'ignored-by-local', null, this);\n\n    if (this._onIgnore) {\n      this._onIgnore();\n    }\n  }\n\n  /**\n   * Check whether call is muted\n   */\n  isMuted(): boolean {\n    return this._mediaHandler.isMuted;\n  }\n\n  /**\n   * Mute incoming audio.\n   * @param shouldMute - Whether the incoming audio should be muted. Defaults to true.\n   */\n  mute(shouldMute: boolean = true): void {\n    this._log.debug('.mute', shouldMute);\n    const wasMuted = this._mediaHandler.isMuted;\n    this._mediaHandler.mute(shouldMute);\n\n    const isMuted = this._mediaHandler.isMuted;\n    if (wasMuted !== isMuted) {\n      this._publisher.info('connection', isMuted ? 'muted' : 'unmuted', null, this);\n      this._log.debug('#mute', isMuted);\n      this.emit('mute', isMuted, this);\n    }\n  }\n\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has given call quality feedback. Called without a score, this\n   *   will report that the customer declined to give feedback.\n   * @param score - The end-user's rating of the call; an\n   *   integer 1 through 5. Or undefined if the user declined to give\n   *   feedback.\n   * @param issue - The primary issue the end user\n   *   experienced on the call. Can be: ['one-way-audio', 'choppy-audio',\n   *   'dropped-call', 'audio-latency', 'noisy-call', 'echo']\n   */\n  postFeedback(score?: Call.FeedbackScore, issue?: Call.FeedbackIssue): Promise<void> {\n    if (typeof score === 'undefined' || score === null) {\n      return this._postFeedbackDeclined();\n    }\n\n    if (!Object.values(Call.FeedbackScore).includes(score)) {\n      throw new InvalidArgumentError(`Feedback score must be one of: ${Object.values(Call.FeedbackScore)}`);\n    }\n\n    if (typeof issue !== 'undefined' && issue !== null && !Object.values(Call.FeedbackIssue).includes(issue)) {\n      throw new InvalidArgumentError(`Feedback issue must be one of: ${Object.values(Call.FeedbackIssue)}`);\n    }\n\n    return this._publisher.info('feedback', 'received', {\n      issue_name: issue,\n      quality_score: score,\n    }, this, true);\n  }\n\n  /**\n   * Reject the incoming {@link Call}.\n   */\n  reject(): void {\n    this._log.debug('.reject');\n    if (this._status !== Call.State.Pending) {\n      this._log.debug(`.reject noop. status is '${this._status}'`);\n      return;\n    }\n\n    this._isRejected = true;\n    this._pstream.reject(this.parameters.CallSid);\n    this._mediaHandler.reject(this.parameters.CallSid);\n    this._publisher.info('connection', 'rejected-by-local', null, this);\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n    this._status = Call.State.Closed;\n    this._log.debug('#reject');\n    this.emit('reject');\n  }\n\n  /**\n   * Send a string of digits.\n   * @param digits\n   */\n  sendDigits(digits: string): void {\n    this._log.debug('.sendDigits', digits);\n    if (digits.match(/[^0-9*#w]/)) {\n      throw new InvalidArgumentError('Illegal character passed into sendDigits');\n    }\n\n    const customSounds = this._options.customSounds || {};\n    const sequence: string[] = [];\n    digits.split('').forEach((digit: string) => {\n      let dtmf = (digit !== 'w') ? `dtmf${digit}` : '';\n      if (dtmf === 'dtmf*') { dtmf = 'dtmfs'; }\n      if (dtmf === 'dtmf#') { dtmf = 'dtmfh'; }\n      sequence.push(dtmf);\n    });\n\n    const playNextDigit = () => {\n      const digit = sequence.shift() as Device.SoundName | undefined;\n      if (digit) {\n        if (this._options.dialtonePlayer && !customSounds[digit]) {\n          this._options.dialtonePlayer.play(digit);\n        } else {\n          this._soundcache.get(digit).play();\n        }\n      }\n      if (sequence.length) {\n        setTimeout(() => playNextDigit(), 200);\n      }\n    };\n    playNextDigit();\n\n    const dtmfSender = this._mediaHandler.getOrCreateDTMFSender();\n\n    function insertDTMF(dtmfs: string[]) {\n      if (!dtmfs.length) { return; }\n      const dtmf: string | undefined = dtmfs.shift();\n\n      if (dtmf && dtmf.length) {\n        dtmfSender.insertDTMF(dtmf, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);\n      }\n\n      setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);\n    }\n\n    if (dtmfSender) {\n      if (!('canInsertDTMF' in dtmfSender) || dtmfSender.canInsertDTMF) {\n        this._log.info('Sending digits using RTCDTMFSender');\n        // NOTE(mroberts): We can't just map 'w' to ',' since\n        // RTCDTMFSender's pause duration is 2 s and Twilio's is more\n        // like 500 ms. Instead, we will fudge it with setTimeout.\n        insertDTMF(digits.split('w'));\n        return;\n      }\n\n      this._log.info('RTCDTMFSender cannot insert DTMF');\n    }\n\n    // send pstream message to send DTMF\n    this._log.info('Sending digits over PStream');\n\n    if (this._pstream !== null && this._pstream.status !== 'disconnected') {\n      this._pstream.dtmf(this.parameters.CallSid, digits);\n    } else {\n      const error = new GeneralErrors.ConnectionError('Could not send DTMF: Signaling channel is disconnected');\n      this._log.debug('#error', error);\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Send a message to Twilio. Your backend application can listen for these\n   * messages to allow communication between your frontend and backend applications.\n   * <br/><br/>This feature is currently in Beta.\n   * @param message - The message object to send.\n   * @returns A voice event sid that uniquely identifies the message that was sent.\n   */\n  sendMessage(message: Call.Message): string {\n    this._log.debug('.sendMessage', JSON.stringify(message));\n    const { content, contentType, messageType } = message;\n\n    if (typeof content === 'undefined' || content === null) {\n      throw new InvalidArgumentError('`content` is empty');\n    }\n\n    if (typeof messageType !== 'string') {\n      throw new InvalidArgumentError(\n        '`messageType` must be a string.',\n      );\n    }\n\n    if (messageType.length === 0) {\n      throw new InvalidArgumentError(\n        '`messageType` must be a non-empty string.',\n      );\n    }\n\n    if (this._pstream === null) {\n      throw new InvalidStateError(\n        'Could not send CallMessage; Signaling channel is disconnected',\n      );\n    }\n\n    const callSid = this.parameters.CallSid;\n    if (typeof this.parameters.CallSid === 'undefined') {\n      throw new InvalidStateError(\n        'Could not send CallMessage; Call has no CallSid',\n      );\n    }\n\n    const voiceEventSid = this._voiceEventSidGenerator();\n    this._messages.set(voiceEventSid, { content, contentType, messageType, voiceEventSid });\n    this._pstream.sendMessage(callSid, content, contentType, messageType, voiceEventSid);\n    return voiceEventSid;\n  }\n\n  /**\n   * Get the current {@link Call} status.\n   */\n  status(): Call.State {\n    return this._status;\n  }\n\n  /**\n   * String representation of {@link Call} instance.\n   * @private\n   */\n  toString = () => '[Twilio.Call instance]';\n\n  /**\n   * Check the volume passed, emitting a warning if one way audio is detected or cleared.\n   * @param currentVolume - The current volume for this direction\n   * @param streakFieldName - The name of the field on the {@link Call} object that tracks how many times the\n   *   current value has been repeated consecutively.\n   * @param lastValueFieldName - The name of the field on the {@link Call} object that tracks the most recent\n   *   volume for this direction\n   * @param direction - The directionality of this audio track, either 'input' or 'output'\n   * @returns The current streak; how many times in a row the same value has been polled.\n   */\n  private _checkVolume(currentVolume: number, currentStreak: number,\n                       lastValue: number, direction: 'input'|'output'): number {\n    const wasWarningRaised: boolean = currentStreak >= 10;\n    let newStreak: number = 0;\n\n    if (lastValue === currentVolume) {\n      newStreak = currentStreak;\n    }\n\n    if (newStreak >= 10) {\n      this._emitWarning('audio-level-', `constant-audio-${direction}-level`, 10, newStreak, false);\n    } else if (wasWarningRaised) {\n      this._emitWarning('audio-level-', `constant-audio-${direction}-level`, 10, newStreak, true);\n    }\n\n    return newStreak;\n  }\n\n  /**\n   * Clean up event listeners.\n   */\n  private _cleanupEventListeners(): void {\n    const cleanup = () => {\n      if (!this._pstream) { return; }\n\n      this._pstream.removeListener('ack', this._onAck);\n      this._pstream.removeListener('answer', this._onAnswer);\n      this._pstream.removeListener('cancel', this._onCancel);\n      this._pstream.removeListener('error', this._onSignalingError);\n      this._pstream.removeListener('hangup', this._onHangup);\n      this._pstream.removeListener('ringing', this._onRinging);\n      this._pstream.removeListener('transportClose', this._onTransportClose);\n      this._pstream.removeListener('connected', this._onConnected);\n      this._pstream.removeListener('message', this._onMessageReceived);\n    };\n\n    // This is kind of a hack, but it lets us avoid rewriting more code.\n    // Basically, there's a sequencing problem with the way PeerConnection raises\n    // the\n    //\n    //   Cannot establish call. SDK is disconnected\n    //\n    // error in Call#accept. It calls PeerConnection#onerror, which emits\n    // the error event on Call. An error handler on Call then calls\n    // cleanupEventListeners, but then control returns to Call#accept. It's\n    // at this point that we add a listener for the answer event that never gets\n    // removed. setTimeout will allow us to rerun cleanup again, _after_\n    // Call#accept returns.\n    cleanup();\n    setTimeout(cleanup, 0);\n  }\n\n  /**\n   * Create the payload wrapper for a batch of metrics to be sent to Insights.\n   */\n  private _createMetricPayload(): Partial<Record<string, string|boolean>> {\n    const payload: Partial<Record<string, string|boolean>> = {\n      call_sid: this.parameters.CallSid,\n      dscp: !!this._options.dscp,\n      sdk_version: RELEASE_VERSION,\n    };\n\n    if (this._options.gateway) {\n      payload.gateway = this._options.gateway;\n    }\n\n    payload.direction = this._direction;\n    return payload;\n  }\n\n  /**\n   * Disconnect the {@link Call}.\n   * @param message - A message explaining why the {@link Call} is being disconnected.\n   * @param wasRemote - Whether the disconnect was triggered locally or remotely.\n   */\n  private _disconnect(message?: string | null, wasRemote?: boolean): void {\n    message = typeof message === 'string' ? message : null;\n\n    if (this._status !== Call.State.Open\n        && this._status !== Call.State.Connecting\n        && this._status !== Call.State.Reconnecting\n        && this._status !== Call.State.Ringing) {\n      return;\n    }\n\n    this._log.info('Disconnecting...');\n\n    // send pstream hangup message\n    if (this._pstream !== null && this._pstream.status !== 'disconnected' && this._shouldSendHangup) {\n      const callsid: string | undefined = this.parameters.CallSid || this.outboundConnectionId;\n      if (callsid) {\n        this._pstream.hangup(callsid, message);\n      }\n    }\n\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n\n    if (!wasRemote) {\n      this._publisher.info('connection', 'disconnected-by-local', null, this);\n    }\n  }\n\n  private _emitWarning = (groupPrefix: string, warningName: string, threshold: number,\n                          value: number|number[], wasCleared?: boolean, warningData?: RTCWarning): void => {\n    const groupSuffix = wasCleared ? '-cleared' : '-raised';\n    const groupName = `${groupPrefix}warning${groupSuffix}`;\n\n    // Ignore constant input if the Call is muted (Expected)\n    if (warningName === 'constant-audio-input-level' && this.isMuted()) {\n      return;\n    }\n\n    let level = wasCleared ? 'info' : 'warning';\n\n    // Avoid throwing false positives as warnings until we refactor volume metrics\n    if (warningName === 'constant-audio-output-level') {\n      level = 'info';\n    }\n\n    const payloadData: Record<string, any> = { threshold };\n\n    if (value) {\n      if (value instanceof Array) {\n        payloadData.values = value.map((val: any) => {\n          if (typeof val === 'number') {\n            return Math.round(val * 100) / 100;\n          }\n\n          return value;\n        });\n      } else {\n        payloadData.value = value;\n      }\n    }\n\n    this._publisher.post(level, groupName, warningName, { data: payloadData }, this);\n\n    if (warningName !== 'constant-audio-output-level') {\n      const emitName = wasCleared ? 'warning-cleared' : 'warning';\n      this._log.debug(`#${emitName}`, warningName);\n      this.emit(emitName, warningName, warningData && !wasCleared ? warningData : null);\n    }\n  }\n\n  /**\n   * Transition to {@link CallStatus.Open} if criteria is met.\n   */\n  private _maybeTransitionToOpen(): void {\n    const wasConnected = this._wasConnected;\n    if (this._isAnswered) {\n      this._onSignalingReconnected();\n      this._signalingStatus = Call.State.Open;\n      if (this._mediaHandler && this._mediaHandler.status === 'open') {\n        this._status = Call.State.Open;\n        if (!this._wasConnected) {\n          this._wasConnected = true;\n          this._log.debug('#accept');\n          this.emit('accept', this);\n        }\n      }\n    }\n  }\n\n  /**\n   * Called when the {@link Call} receives an ack from signaling\n   * @param payload\n   */\n  private _onAck = (payload: Record<string, any>): void => {\n    const { acktype, callsid, voiceeventsid } = payload;\n    if (this.parameters.CallSid !== callsid) {\n      this._log.warn(`Received ack from a different callsid: ${callsid}`);\n      return;\n    }\n    if (acktype === 'message') {\n      this._onMessageSent(voiceeventsid);\n    }\n  }\n\n  /**\n   * Called when the {@link Call} is answered.\n   * @param payload\n   */\n  private _onAnswer = (payload: Record<string, any>): void => {\n    if (typeof payload.reconnect === 'string') {\n      this._signalingReconnectToken = payload.reconnect;\n    }\n\n    // answerOnBridge=false will send a 183 which we need to catch in _onRinging when\n    // the enableRingingState flag is disabled. In that case, we will receive a 200 after\n    // the callee accepts the call firing a second `accept` event if we don't\n    // short circuit here.\n    if (this._isAnswered && this._status !== Call.State.Reconnecting) {\n      return;\n    }\n\n    this._setCallSid(payload);\n    this._isAnswered = true;\n    this._maybeTransitionToOpen();\n  }\n\n  /**\n   * Called when the {@link Call} is cancelled.\n   * @param payload\n   */\n  private _onCancel = (payload: Record<string, any>): void => {\n    // (rrowland) Is this check necessary? Verify, and if so move to pstream / VSP module.\n    const callsid = payload.callsid;\n    if (this.parameters.CallSid === callsid) {\n      this._isCancelled = true;\n      this._publisher.info('connection', 'cancel', null, this);\n      this._cleanupEventListeners();\n      this._mediaHandler.close();\n\n      this._status = Call.State.Closed;\n      this._log.debug('#cancel');\n      this.emit('cancel');\n      this._pstream.removeListener('cancel', this._onCancel);\n    }\n  }\n\n  /**\n   * Called when we receive a connected event from pstream.\n   * Re-emits the event.\n   */\n  private _onConnected = (): void => {\n    this._log.info('Received connected from pstream');\n    if (this._signalingReconnectToken && this._mediaHandler.version) {\n      this._pstream.reconnect(\n        this._mediaHandler.version.getSDP(),\n        this.parameters.CallSid,\n        this._signalingReconnectToken,\n      );\n    }\n  }\n\n  /**\n   * Called when the {@link Call} is hung up.\n   * @param payload\n   */\n  private _onHangup = (payload: Record<string, any>): void => {\n    if (this.status() === Call.State.Closed) {\n      return;\n    }\n\n    /**\n     *  see if callsid passed in message matches either callsid or outbound id\n     *  call should always have either callsid or outbound id\n     *  if no callsid passed hangup anyways\n     */\n    if (payload.callsid && (this.parameters.CallSid || this.outboundConnectionId)) {\n      if (payload.callsid !== this.parameters.CallSid\n          && payload.callsid !== this.outboundConnectionId) {\n        return;\n      }\n    } else if (payload.callsid) {\n      // hangup is for another call\n      return;\n    }\n\n    this._log.info('Received HANGUP from gateway');\n    if (payload.error) {\n      const code = payload.error.code;\n      const errorConstructor = getPreciseSignalingErrorByCode(\n        this._options.enableImprovedSignalingErrorPrecision,\n        code,\n      );\n      const error = typeof errorConstructor !== 'undefined'\n        ? new errorConstructor(payload.error.message)\n        : new GeneralErrors.ConnectionError(\n            'Error sent from gateway in HANGUP',\n          );\n      this._log.error('Received an error from the gateway:', error);\n      this._log.debug('#error', error);\n      this.emit('error', error);\n    }\n    this._shouldSendHangup = false;\n    this._publisher.info('connection', 'disconnected-by-remote', null, this);\n    this._disconnect(null, true);\n    this._cleanupEventListeners();\n  }\n\n  /**\n   * Called when there is a media failure.\n   * Manages all media-related states and takes action base on the states\n   * @param type - Type of media failure\n   */\n  private _onMediaFailure = (type: Call.MediaFailure): void => {\n    const {\n      ConnectionDisconnected, ConnectionFailed, IceGatheringFailed, LowBytes,\n    } = Call.MediaFailure;\n\n    // These types signifies the end of a single ICE cycle\n    const isEndOfIceCycle = type === ConnectionFailed || type === IceGatheringFailed;\n\n    // All browsers except chrome doesn't update pc.iceConnectionState and pc.connectionState\n    // after issuing an ICE Restart, which we use to determine if ICE Restart is complete.\n    // Since we cannot detect if ICE Restart is complete, we will not retry.\n    if (!isChrome(window, window.navigator) && type === ConnectionFailed) {\n      return this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n    }\n\n    // Ignore subsequent requests if ice restart is in progress\n    if (this._mediaStatus === Call.State.Reconnecting) {\n\n      // This is a retry. Previous ICE Restart failed\n      if (isEndOfIceCycle) {\n\n        // We already exceeded max retry time.\n        if (Date.now() - this._mediaReconnectStartTime > BACKOFF_CONFIG.max) {\n          this._log.warn('Exceeded max ICE retries');\n          return this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n        }\n\n        // Issue ICE restart with backoff\n        try {\n          this._mediaReconnectBackoff.backoff();\n        } catch (error) {\n          // Catch and ignore 'Backoff in progress.' errors. If a backoff is\n          // ongoing and we try to start another one, there shouldn't be a\n          // problem.\n          if (!(error.message && error.message === 'Backoff in progress.')) {\n            throw error;\n          }\n        }\n      }\n\n      return;\n    }\n\n    const pc = this._mediaHandler.version.pc;\n    const isIceDisconnected = pc && pc.iceConnectionState === 'disconnected';\n    const hasLowBytesWarning = this._monitor.hasActiveWarning('bytesSent', 'min')\n      || this._monitor.hasActiveWarning('bytesReceived', 'min');\n\n    // Only certain conditions can trigger media reconnection\n    if ((type === LowBytes && isIceDisconnected)\n      || (type === ConnectionDisconnected && hasLowBytesWarning)\n      || isEndOfIceCycle) {\n\n      const mediaReconnectionError = new MediaErrors.ConnectionError('Media connection failed.');\n      this._log.warn('ICE Connection disconnected.');\n      this._publisher.warn('connection', 'error', mediaReconnectionError, this);\n      this._publisher.info('connection', 'reconnecting', null, this);\n\n      this._mediaReconnectStartTime = Date.now();\n      this._status = Call.State.Reconnecting;\n      this._mediaStatus = Call.State.Reconnecting;\n      this._mediaReconnectBackoff.reset();\n      this._mediaReconnectBackoff.backoff();\n\n      this._log.debug('#reconnecting');\n      this.emit('reconnecting', mediaReconnectionError);\n    }\n  }\n\n  /**\n   * Called when media call is restored\n   */\n  private _onMediaReconnected = (): void => {\n    // Only trigger once.\n    // This can trigger on pc.onIceConnectionChange and pc.onConnectionChange.\n    if (this._mediaStatus !== Call.State.Reconnecting) {\n      return;\n    }\n    this._log.info('ICE Connection reestablished.');\n    this._mediaStatus = Call.State.Open;\n\n    if (this._signalingStatus === Call.State.Open) {\n      this._publisher.info('connection', 'reconnected', null, this);\n      this._log.debug('#reconnected');\n      this.emit('reconnected');\n      this._status = Call.State.Open;\n    }\n  }\n\n  /**\n   * Raised when a Call receives a message from the backend.\n   * @param payload - A record representing the payload of the message from the\n   * Twilio backend.\n   */\n  private _onMessageReceived = (payload: Record<string, any>): void => {\n    const { callsid, content, contenttype, messagetype, voiceeventsid } = payload;\n\n    if (this.parameters.CallSid !== callsid) {\n      this._log.warn(`Received a message from a different callsid: ${callsid}`);\n      return;\n    }\n    const data = {\n      content,\n      contentType: contenttype,\n      messageType: messagetype,\n      voiceEventSid: voiceeventsid,\n    };\n    this._publisher.info('call-message', messagetype, {\n      content_type: contenttype,\n      event_type: 'received',\n      voice_event_sid: voiceeventsid,\n    }, this);\n    this._log.debug('#messageReceived', JSON.stringify(data));\n    this.emit('messageReceived', data);\n  }\n\n  /**\n   * Raised when a Call receives an 'ack' with an 'acktype' of 'message.\n   * This means that the message sent via sendMessage API has been received by the signaling server.\n   * @param voiceEventSid\n   */\n  private _onMessageSent = (voiceEventSid: string): void => {\n    if (!this._messages.has(voiceEventSid)) {\n      this._log.warn(`Received a messageSent with a voiceEventSid that doesn't exists: ${voiceEventSid}`);\n      return;\n    }\n    const message = this._messages.get(voiceEventSid);\n    this._messages.delete(voiceEventSid);\n    this._publisher.info('call-message', message?.messageType, {\n      content_type: message?.contentType,\n      event_type: 'sent',\n      voice_event_sid: voiceEventSid,\n    }, this);\n    this._log.debug('#messageSent', JSON.stringify(message));\n    this.emit('messageSent', message);\n  }\n\n  /**\n   * When we get a RINGING signal from PStream, update the {@link Call} status.\n   * @param payload\n   */\n  private _onRinging = (payload: Record<string, any>): void => {\n    this._setCallSid(payload);\n\n    // If we're not in 'connecting' or 'ringing' state, this event was received out of order.\n    if (this._status !== Call.State.Connecting && this._status !== Call.State.Ringing) {\n      return;\n    }\n\n    const hasEarlyMedia = !!payload.sdp;\n    this._status = Call.State.Ringing;\n    this._publisher.info('connection', 'outgoing-ringing', { hasEarlyMedia }, this);\n    this._log.debug('#ringing');\n    this.emit('ringing', hasEarlyMedia);\n  }\n\n  /**\n   * Called each time StatsMonitor emits a sample.\n   * Emits stats event and batches the call stats metrics and sends them to Insights.\n   * @param sample\n   */\n  private _onRTCSample = (sample: RTCSample): void => {\n    const callMetrics: Call.CallMetrics = {\n      ...sample,\n      inputVolume: this._latestInputVolume,\n      outputVolume: this._latestOutputVolume,\n    };\n\n    this._codec = callMetrics.codecName;\n\n    this._metricsSamples.push(callMetrics);\n    if (this._metricsSamples.length >= METRICS_BATCH_SIZE) {\n      this._publishMetrics();\n    }\n\n    this.emit('sample', sample);\n  }\n\n  /**\n   * Called when an 'error' event is received from the signaling stream.\n   */\n  private _onSignalingError = (payload: Record<string, any>): void => {\n    const { callsid, voiceeventsid, error } = payload;\n    if (this.parameters.CallSid !== callsid) {\n      this._log.warn(`Received an error from a different callsid: ${callsid}`);\n      return;\n    }\n    if (voiceeventsid && this._messages.has(voiceeventsid)) {\n      // Do not emit an error here. Device is handling all signaling related errors.\n      this._messages.delete(voiceeventsid);\n      this._log.warn(`Received an error while sending a message.`, payload);\n\n      this._publisher.error('call-message', 'error', {\n        code: error.code,\n        message: error.message,\n        voice_event_sid: voiceeventsid,\n      }, this);\n\n      let twilioError;\n      const errorConstructor = getPreciseSignalingErrorByCode(\n        !!this._options.enableImprovedSignalingErrorPrecision,\n        error.code,\n      );\n\n      if (typeof errorConstructor !== 'undefined') {\n        twilioError = new errorConstructor(error);\n      }\n\n      if (!twilioError) {\n        this._log.error('Unknown Call Message Error: ', error);\n        twilioError = new GeneralErrors.UnknownError(error.message, error);\n      }\n\n      this._log.debug('#error', error, twilioError);\n      this.emit('error', twilioError);\n    }\n   }\n\n  /**\n   * Called when signaling is restored\n   */\n  private _onSignalingReconnected = (): void => {\n    if (this._signalingStatus !== Call.State.Reconnecting) {\n      return;\n    }\n    this._log.info('Signaling Connection reestablished.');\n\n    this._signalingStatus = Call.State.Open;\n\n    if (this._mediaStatus === Call.State.Open) {\n      this._publisher.info('connection', 'reconnected', null, this);\n      this._log.debug('#reconnected');\n      this.emit('reconnected');\n      this._status = Call.State.Open;\n    }\n  }\n\n  /**\n   * Called when we receive a transportClose event from pstream.\n   * Re-emits the event.\n   */\n  private _onTransportClose = (): void => {\n    this._log.error('Received transportClose from pstream');\n    this._log.debug('#transportClose');\n    this.emit('transportClose');\n    if (this._signalingReconnectToken) {\n      this._status = Call.State.Reconnecting;\n      this._signalingStatus = Call.State.Reconnecting;\n      this._log.debug('#reconnecting');\n      this.emit('reconnecting', new SignalingErrors.ConnectionDisconnected());\n    } else {\n      this._status = Call.State.Closed;\n      this._signalingStatus = Call.State.Closed;\n    }\n  }\n\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has ignored a request for feedback.\n   */\n  private _postFeedbackDeclined(): Promise<void> {\n    return this._publisher.info('feedback', 'received-none', null, this, true);\n  }\n\n  /**\n   * Publish the current set of queued metrics samples to Insights.\n   */\n  private _publishMetrics(): void {\n    if (this._metricsSamples.length === 0) {\n      return;\n    }\n\n    this._publisher.postMetrics(\n      'quality-metrics-samples', 'metrics-sample', this._metricsSamples.splice(0), this._createMetricPayload(), this,\n    ).catch((e: any) => {\n      this._log.warn('Unable to post metrics to Insights. Received error:', e);\n    });\n  }\n\n  /**\n   * Re-emit an StatsMonitor warning as a {@link Call}.warning or .warning-cleared event.\n   * @param warningData\n   * @param wasCleared - Whether this is a -cleared or -raised event.\n   */\n  private _reemitWarning = (warningData: Record<string, any>, wasCleared?: boolean): void => {\n    const groupPrefix = /^audio/.test(warningData.name) ?\n      'audio-level-' : 'network-quality-';\n\n    const warningPrefix = WARNING_PREFIXES[warningData.threshold.name];\n\n    /**\n     * NOTE: There are two \"packet-loss\" warnings: `high-packet-loss` and\n     * `high-packets-lost-fraction`, so in this case we need to use a different\n     * `WARNING_NAME` mapping.\n     */\n    let warningName: string | undefined;\n    if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {\n      warningName = MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][warningData.threshold.name];\n    } else if (warningData.name in WARNING_NAMES) {\n      warningName = WARNING_NAMES[warningData.name];\n    }\n\n    const warning: string = warningPrefix + warningName;\n\n    this._emitWarning(groupPrefix, warning, warningData.threshold.value,\n                      warningData.values || warningData.value, wasCleared, warningData);\n  }\n\n  /**\n   * Re-emit an StatsMonitor warning-cleared as a .warning-cleared event.\n   * @param warningData\n   */\n  private _reemitWarningCleared = (warningData: Record<string, any>): void => {\n    this._reemitWarning(warningData, true);\n  }\n\n  /**\n   * Set the CallSid\n   * @param payload\n   */\n  private _setCallSid(payload: Record<string, string>): void {\n    const callSid = payload.callsid;\n    if (!callSid) { return; }\n\n    this.parameters.CallSid = callSid;\n    this._mediaHandler.callSid = callSid;\n  }\n}\n\nnamespace Call {\n  /**\n   * Emitted when the {@link Call} is accepted.\n   * @param call - The {@link Call}.\n   * @example `call.on('accept', call => { })`\n   * @event\n   */\n  declare function acceptEvent(call: Call): void;\n\n  /**\n   * Emitted after the HTMLAudioElement for the remote audio is created.\n   * @param remoteAudio - The HTMLAudioElement.\n   * @example `call.on('audio', handler(remoteAudio))`\n   * @event\n   */\n  declare function audioEvent(remoteAudio: HTMLAudioElement): void;\n\n  /**\n   * Emitted when the {@link Call} is canceled.\n   * @example `call.on('cancel', () => { })`\n   * @event\n   */\n  declare function cancelEvent(): void;\n\n  /**\n   * Emitted when the {@link Call} is disconnected.\n   * @param call - The {@link Call}.\n   * @example `call.on('disconnect', call => { })`\n   * @event\n   */\n  declare function disconnectEvent(call: Call): void;\n\n  /**\n   * Emitted when the {@link Call} receives an error.\n   * @param error\n   * @example `call.on('error', error => { })`\n   * @event\n   */\n  declare function errorEvent(error: TwilioError): void;\n\n  /**\n   * Emitted when a Call receives a message from the backend.\n   * <br/><br/>This feature is currently in Beta.\n   * @param message - A message object representing the payload\n   * that was received from the Twilio backend.\n   * @event\n   */\n  declare function messageReceivedEvent(message: Call.Message): void;\n\n  /**\n   * Emitted after calling the {@link Call.sendMessage} API.\n   * This event indicates that Twilio has received the message.\n   * <br/><br/>This feature is currently in Beta.\n   * @param message - A message object that was sent to the Twilio backend.\n   * @event\n   */\n  declare function messageSentEvent(message: Call.Message): void;\n\n  /**\n   * Emitted when the {@link Call} is muted or unmuted.\n   * @param isMuted - Whether the {@link Call} is muted.\n   * @param call - The {@link Call}.\n   * @example `call.on('mute', (isMuted, call) => { })`\n   * @event\n   */\n  declare function muteEvent(isMuted: boolean, call: Call): void;\n\n  /**\n   * Emitted when the {@link Call} has regained media connectivity.\n   * @example `call.on('reconnected', () => { })`\n   * @event\n   */\n  declare function reconnectedEvent(): void;\n\n  /**\n   * Emitted when the {@link Call} has lost media connectivity and is reconnecting.\n   * @param error - The {@link TwilioError} that caused the media connectivity loss\n   * @example `call.on('reconnecting', error => { })`\n   * @event\n   */\n  declare function reconnectingEvent(error: TwilioError): void;\n\n  /**\n   * Emitted when the {@link Call} is rejected.\n   * @example `call.on('reject', () => { })`\n   * @event\n   */\n  declare function rejectEvent(): void;\n\n  /**\n   * Emitted when the {@link Call} has entered the `ringing` state.\n   * When using the Dial verb with `answerOnBridge=true`, the ringing state will begin when\n   * the callee has been notified of the call and will transition into open after the callee accepts the call,\n   * or closed if the call is rejected or cancelled.\n   * @param hasEarlyMedia - Denotes whether there is early media available from the callee.\n   * If `true`, the Client SDK will automatically play the early media. Sometimes this is ringing,\n   * other times it may be an important message about the call. If `false`, there is no remote media to play,\n   * so the application may want to play its own outgoing ringtone sound.\n   * @example `call.on('ringing', hasEarlyMedia => { })`\n   * @event\n   */\n  declare function ringingEvent(hasEarlyMedia: boolean): void;\n\n  /**\n   * Emitted when the {@link Call} gets a webrtc sample object.\n   * This event is published every second.\n   * @param sample\n   * @example `call.on('sample', sample => { })`\n   * @event\n   */\n  declare function sampleEvent(sample: RTCSample): void;\n\n  /**\n   * Emitted every 50ms with the current input and output volumes, as a percentage of maximum\n   * volume, between -100dB and -30dB. Represented by a floating point number.\n   * @param inputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @param outputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @example `call.on('volume', (inputVolume, outputVolume) => { })`\n   * @event\n   */\n  declare function volumeEvent(inputVolume: number, outputVolume: number): void;\n\n  /**\n   * Emitted when the SDK detects a drop in call quality or other conditions that may indicate\n   * the user is having trouble with the call. You can implement callbacks on these events to\n   * alert the user of an issue.\n   *\n   * To alert the user that an issue has been resolved, you can listen for the `warning-cleared` event,\n   * which indicates that a call quality metric has returned to normal.\n   *\n   * For a full list of conditions that will raise a warning event, check the\n   * [Voice Insights SDK Events Reference](https://www.twilio.com/docs/voice/voice-insights/api/call/details-sdk-call-quality-events) page.\n   *\n   * @param name - The name of the warning\n   * @param data - An object containing data on the warning\n   * @example `call.on('warning', (name, data) => { })`\n   * @event\n   */\n  declare function warningEvent(name: string, data: any): void;\n\n  /**\n   * Emitted when a call quality metric has returned to normal.\n   * You can listen for this event to update the user when a call quality issue has been resolved.\n   *\n   * @param name - The name of the warning\n   * @example `call.on('warning-cleared', name => { })`\n   * @event\n   */\n  declare function warningClearedEvent(name: string): void;\n\n  /**\n   * Possible states of the {@link Call}.\n   */\n  export enum State {\n    Closed = 'closed',\n    Connecting = 'connecting',\n    Open = 'open',\n    Pending = 'pending',\n    Reconnecting = 'reconnecting',\n    Ringing = 'ringing',\n  }\n\n  /**\n   * Different issues that may have been experienced during a call, that can be\n   * reported to Twilio Insights via {@link Call}.postFeedback().\n   */\n  export enum FeedbackIssue {\n    AudioLatency = 'audio-latency',\n    ChoppyAudio = 'choppy-audio',\n    DroppedCall = 'dropped-call',\n    Echo = 'echo',\n    NoisyCall = 'noisy-call',\n    OneWayAudio = 'one-way-audio',\n  }\n\n  /**\n   * A rating of call quality experienced during a call, to be reported to Twilio Insights\n   * via {@link Call}.postFeedback().\n   */\n  export enum FeedbackScore {\n    One = 1,\n    Two,\n    Three,\n    Four,\n    Five,\n  }\n\n  /**\n   * The directionality of the {@link Call}, whether incoming or outgoing.\n   */\n  export enum CallDirection {\n    Incoming = 'INCOMING',\n    Outgoing = 'OUTGOING',\n  }\n\n  /**\n   * Valid audio codecs to use for the media connection.\n   */\n  export enum Codec {\n    Opus = 'opus',\n    PCMU = 'pcmu',\n  }\n\n  /**\n   * Possible ICE Gathering failures\n   */\n  export enum IceGatheringFailureReason {\n    None = 'none',\n    Timeout = 'timeout',\n  }\n\n  /**\n   * Possible media failures\n   */\n  export enum MediaFailure {\n    ConnectionDisconnected = 'ConnectionDisconnected',\n    ConnectionFailed = 'ConnectionFailed',\n    IceGatheringFailed = 'IceGatheringFailed',\n    LowBytes = 'LowBytes',\n  }\n\n  /**\n   * Options to be used to acquire media tracks and connect media.\n   */\n  export interface AcceptOptions {\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n\n    /**\n     * MediaStreamConstraints to pass to getUserMedia when making or accepting a Call.\n     */\n    rtcConstraints?: MediaStreamConstraints;\n  }\n\n  /**\n   * A CallerInfo provides caller verification information.\n   */\n  export interface CallerInfo {\n    /**\n     * Whether or not the caller's phone number has been verified by\n     * Twilio using SHAKEN/STIR validation. True if the caller has\n     * been validated at level 'A', false if the caller has been\n     * verified at any lower level or has failed validation.\n     */\n    isVerified: boolean;\n  }\n\n  /**\n   * Mandatory config options to be passed to the {@link Call} constructor.\n   * @private\n   */\n  export interface Config {\n    /**\n     * An AudioHelper instance to be used for input/output devices.\n     */\n    audioHelper: IAudioHelper;\n\n    /**\n     * Whether or not the browser uses unified-plan SDP by default.\n     */\n    isUnifiedPlanDefault: boolean;\n\n    /**\n     * A function to be called after {@link Call.ignore} is called.\n     */\n    onIgnore: () => void;\n\n    /**\n     * The PStream instance to use for Twilio call signaling.\n     */\n    pstream: IPStream;\n\n    /**\n     * An EventPublisher instance to use for publishing events\n     */\n    publisher: IPublisher;\n\n    /**\n     * A Map of Sounds to play.\n     */\n    soundcache: Map<Device.SoundName, ISound>;\n  }\n\n  /**\n   * A Call Message represents the data that is being transferred between\n   * Twilio and the SDK.\n   */\n  export interface Message {\n    /**\n     * The content of the message which should match the contentType parameter.\n     */\n    content: any;\n\n    /**\n     * The MIME type of the content. The default value is application/json\n     * and is the only contentType that is supported at the moment.\n     */\n    contentType?: string;\n\n    /**\n     * The type of message. Currently, only 'user-defined-message' is supported.\n     * More message types will be added in the future.\n     * See [call resource](https://www.twilio.com/docs/voice/api/call-resource) documentation for more details.\n     */\n    messageType: string;\n\n    /**\n     * An autogenerated id that uniquely identifies the instance of this message.\n     * This is not required when sending a message from the SDK as this is autogenerated.\n     * But it will be available after the message is sent, or when a message is received.\n     */\n    voiceEventSid?: string;\n  }\n\n  /**\n   * Options to be passed to the {@link Call} constructor.\n   * @private\n   */\n  export interface Options {\n    /**\n     * A method to call before Call.accept is processed.\n     */\n    beforeAccept?: (call: Call) => void;\n\n    /**\n     * Custom format context parameters associated with this call.\n     */\n    callParameters?: Record<string, string>;\n\n    /**\n     * An ordered array of codec names, from most to least preferred.\n     */\n    codecPreferences?: Codec[];\n\n    /**\n     * A mapping of custom sound URLs by sound name.\n     */\n    customSounds?: Partial<Record<Device.SoundName, string>>;\n\n    /**\n     * A DialTone player, to play mock DTMF sounds.\n     */\n    dialtonePlayer?: DialtonePlayer;\n\n    /**\n     * Whether or not to enable DSCP.\n     */\n    dscp?: boolean;\n\n    enableImprovedSignalingErrorPrecision: boolean;\n\n    /**\n     * Experimental feature.\n     * Force Chrome's ICE agent to use aggressive nomination when selecting a candidate pair.\n     */\n    forceAggressiveIceNomination?: boolean;\n\n    /**\n     * The gateway currently connected to.\n     */\n    gateway?: string;\n\n    /**\n     * A method that returns the current input MediaStream set on {@link Device}.\n     */\n    getInputStream?: () => MediaStream;\n\n    /**\n     * A method that returns the current SinkIDs set on {@link Device}.\n     */\n    getSinkIds?: () => string[];\n\n    /**\n     * The maximum average audio bitrate to use, in bits per second (bps) based on\n     * [RFC-7587 7.1](https://tools.ietf.org/html/rfc7587#section-7.1). By default, the setting\n     * is not used. If you specify 0, then the setting is not used. Any positive integer is allowed,\n     * but values outside the range 6000 to 510000 are ignored and treated as 0. The recommended\n     * bitrate for speech is between 8000 and 40000 bps as noted in\n     * [RFC-7587 3.1.1](https://tools.ietf.org/html/rfc7587#section-3.1.1).\n     */\n    maxAverageBitrate?: number;\n\n    /**\n     * Custom MediaHandler (PeerConnection) constructor.\n     */\n    MediaHandler?: IPeerConnection;\n\n    /**\n     * The offer SDP, if this is an incoming call.\n     */\n    offerSdp?: string | null;\n\n    /**\n     * Whether this is a preflight call or not\n     */\n    preflight?: boolean;\n\n    /**\n     * The callSid to reconnect to.\n     */\n    reconnectCallSid?: string;\n\n    /**\n     * A reconnect token for the {@link Call}. Passed in for incoming {@link Calls}.\n     */\n    reconnectToken?: string;\n\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n\n    /**\n     * RTC Constraints to pass to getUserMedia when making or accepting a Call.\n     * The format of this object depends on browser.\n     */\n    rtcConstraints?: MediaStreamConstraints;\n\n    /**\n     * The RTCPeerConnection passed to {@link Device} on setup.\n     */\n    RTCPeerConnection?: any;\n\n    /**\n     * Whether the disconnect sound should be played.\n     */\n    shouldPlayDisconnect?: () => boolean;\n\n    /**\n     * An override for the StatsMonitor dependency.\n     */\n    StatsMonitor?: new () => StatsMonitor;\n\n    /**\n     * TwiML params for the call. May be set for either outgoing or incoming calls.\n     */\n    twimlParams?: Record<string, any>;\n\n    /**\n     * Voice event SID generator.\n     */\n    voiceEventSidGenerator?: () => string;\n  }\n\n  /**\n   * Call metrics published to Insight Metrics.\n   * This include rtc samples and audio information.\n   * @private\n   */\n  export interface CallMetrics extends RTCSample {\n    /**\n     * Percentage of maximum volume, between 0.0 to 1.0, representing -100 to -30 dB.\n     */\n    inputVolume: number;\n\n    /**\n     * Percentage of maximum volume, between 0.0 to 1.0, representing -100 to -30 dB.\n     */\n    outputVolume: number;\n  }\n}\n\nfunction generateTempCallSid() {\n  return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    /* tslint:disable:no-bitwise */\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    /* tslint:enable:no-bitwise */\n    return v.toString(16);\n  });\n}\n\nexport default Call;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}