{"ast":null,"code":"\"use strict\";\n\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WSTransportState = void 0;\nvar events_1 = require(\"events\");\nvar backoff_1 = require(\"./backoff\");\nvar errors_1 = require(\"./errors\");\nvar log_1 = require(\"./log\");\nvar WebSocket = globalThis.WebSocket;\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\nvar MAX_PREFERRED_DURATION = 15000;\nvar MAX_PRIMARY_DURATION = Infinity;\nvar MAX_PREFERRED_DELAY = 1000;\nvar MAX_PRIMARY_DELAY = 20000;\n/**\n * All possible states of WSTransport.\n */\nvar WSTransportState;\n(function (WSTransportState) {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  WSTransportState[\"Connecting\"] = \"connecting\";\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  WSTransportState[\"Closed\"] = \"closed\";\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\nvar WSTransport = /** @class */function (_super) {\n  __extends(WSTransport, _super);\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  function WSTransport(uris, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * The current state of the WSTransport.\n     */\n    _this.state = WSTransportState.Closed;\n    /**\n     * Start timestamp values for backoffs.\n     */\n    _this._backoffStartTime = {\n      preferred: null,\n      primary: null\n    };\n    /**\n     * The URI that the transport is connecting or connected to. The value of this\n     * property is `null` if a connection attempt has not been made yet.\n     */\n    _this._connectedUri = null;\n    /**\n     * An instance of Logger to use.\n     */\n    _this._log = new log_1.default('WSTransport');\n    /**\n     * Whether we should attempt to fallback if we receive an applicable error\n     * when trying to connect to a signaling endpoint.\n     */\n    _this._shouldFallback = false;\n    /**\n     * The current uri index that the transport is connected to.\n     */\n    _this._uriIndex = 0;\n    /**\n     * Move the uri index to the next index\n     * If the index is at the end, the index goes back to the first one.\n     */\n    _this._moveUriIndex = function () {\n      _this._uriIndex++;\n      if (_this._uriIndex >= _this._uris.length) {\n        _this._uriIndex = 0;\n      }\n    };\n    /**\n     * Called in response to WebSocket#close event.\n     */\n    _this._onSocketClose = function (event) {\n      _this._log.error(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason);\n      // 1006: Abnormal close. When the server is unreacheable\n      // 1015: TLS Handshake error\n      if (event.code === 1006 || event.code === 1015) {\n        _this.emit('error', {\n          code: 31005,\n          message: event.reason || 'Websocket connection to Twilio\\'s signaling servers were ' + 'unexpectedly ended. If this is happening consistently, there may ' + 'be an issue resolving the hostname provided. If a region or an ' + 'edge is being specified in Device setup, ensure it is valid.',\n          twilioError: new errors_1.SignalingErrors.ConnectionError()\n        });\n        var wasConnected =\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        _this.state === WSTransportState.Open ||\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        _this._previousState === WSTransportState.Open;\n        // Only fallback if this is not the first error\n        // and if we were not connected previously\n        if (_this._shouldFallback || !wasConnected) {\n          _this._moveUriIndex();\n        }\n        _this._shouldFallback = true;\n      }\n      _this._closeSocket();\n    };\n    /**\n     * Called in response to WebSocket#error event.\n     */\n    _this._onSocketError = function (err) {\n      _this._log.error(\"WebSocket received error: \" + err.message);\n      _this.emit('error', {\n        code: 31000,\n        message: err.message || 'WSTransport socket error',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n    };\n    /**\n     * Called in response to WebSocket#message event.\n     */\n    _this._onSocketMessage = function (message) {\n      // Clear heartbeat timeout on any incoming message, as they\n      // all indicate an active connection.\n      _this._setHeartbeatTimeout();\n      // Filter and respond to heartbeats\n      if (_this._socket && message.data === '\\n') {\n        _this._socket.send('\\n');\n        _this._log.debug('heartbeat');\n        return;\n      }\n      if (message && typeof message.data === 'string') {\n        _this._log.debug(\"Received: \" + message.data);\n      }\n      _this.emit('message', message);\n    };\n    /**\n     * Called in response to WebSocket#open event.\n     */\n    _this._onSocketOpen = function () {\n      _this._log.info('WebSocket opened successfully.');\n      _this._timeOpened = Date.now();\n      _this._shouldFallback = false;\n      _this._setState(WSTransportState.Open);\n      clearTimeout(_this._connectTimeout);\n      _this._resetBackoffs();\n      _this._setHeartbeatTimeout();\n      _this.emit('open');\n    };\n    _this._options = __assign(__assign({}, WSTransport.defaultConstructorOptions), options);\n    _this._uris = uris;\n    _this._backoff = _this._setupBackoffs();\n    return _this;\n  }\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  WSTransport.prototype.close = function () {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  };\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  WSTransport.prototype.open = function () {\n    this._log.info('WSTransport.open() called...');\n    if (this._socket && (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n    if (this._preferredUri) {\n      this._connect(this._preferredUri);\n    } else {\n      this._connect(this._uris[this._uriIndex]);\n    }\n  };\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  WSTransport.prototype.send = function (message) {\n    this._log.debug(\"Sending: \" + message);\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      this._log.debug('Cannot send message. WebSocket is not open.');\n      return false;\n    }\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.error('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n    return true;\n  };\n  /**\n   * Update the preferred URI to connect to. Useful for Call signaling\n   * reconnection, which requires connecting on the same edge. If `null` is\n   * passed, the preferred URI is unset and the original `uris` array and\n   * `uriIndex` is used to determine the signaling URI to connect to.\n   * @param uri\n   */\n  WSTransport.prototype.updatePreferredURI = function (uri) {\n    this._preferredUri = uri;\n  };\n  /**\n   * Update acceptable URIs to reconnect to. Resets the URI index to 0.\n   */\n  WSTransport.prototype.updateURIs = function (uris) {\n    if (typeof uris === 'string') {\n      uris = [uris];\n    }\n    this._uris = uris;\n    this._uriIndex = 0;\n  };\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  WSTransport.prototype._close = function () {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  };\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  WSTransport.prototype._closeSocket = function () {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n    this._log.info('Closing and cleaning up WebSocket...');\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n    this._socket.removeEventListener('close', this._onSocketClose);\n    this._socket.removeEventListener('error', this._onSocketError);\n    this._socket.removeEventListener('message', this._onSocketMessage);\n    this._socket.removeEventListener('open', this._onSocketOpen);\n    if (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._resetBackoffs();\n    }\n    if (this.state !== WSTransportState.Closed) {\n      this._performBackoff();\n    }\n    delete this._socket;\n    this.emit('close');\n  };\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [uri] - URI string to connect to.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  WSTransport.prototype._connect = function (uri, retryCount) {\n    var _this = this;\n    this._log.info(typeof retryCount === 'number' ? \"Attempting to reconnect (retry #\" + retryCount + \")...\" : 'Attempting to connect...');\n    this._closeSocket();\n    this._setState(WSTransportState.Connecting);\n    this._connectedUri = uri;\n    try {\n      this._socket = new this._options.WebSocket(this._connectedUri);\n    } catch (e) {\n      this._log.error('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || \"Could not connect to \" + this._connectedUri,\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n      return;\n    }\n    this._socket.addEventListener('close', this._onSocketClose);\n    this._socket.addEventListener('error', this._onSocketError);\n    this._socket.addEventListener('message', this._onSocketMessage);\n    this._socket.addEventListener('open', this._onSocketOpen);\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(function () {\n      _this._log.info('WebSocket connection attempt timed out.');\n      _this._moveUriIndex();\n      _this._closeSocket();\n    }, this._options.connectTimeoutMs);\n  };\n  /**\n   * Perform a backoff. If a preferred URI is set (not null), then backoff\n   * using the preferred mechanism. Otherwise, use the primary mechanism.\n   */\n  WSTransport.prototype._performBackoff = function () {\n    if (this._preferredUri) {\n      this._log.info('Preferred URI set; backing off.');\n      this._backoff.preferred.backoff();\n    } else {\n      this._log.info('Preferred URI not set; backing off.');\n      this._backoff.primary.backoff();\n    }\n  };\n  /**\n   * Reset both primary and preferred backoff mechanisms.\n   */\n  WSTransport.prototype._resetBackoffs = function () {\n    this._backoff.preferred.reset();\n    this._backoff.primary.reset();\n    this._backoffStartTime.preferred = null;\n    this._backoffStartTime.primary = null;\n  };\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  WSTransport.prototype._setHeartbeatTimeout = function () {\n    var _this = this;\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(function () {\n      _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n      _this._shouldFallback = true;\n      _this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  };\n  /**\n   * Set the current and previous state\n   */\n  WSTransport.prototype._setState = function (state) {\n    this._previousState = this.state;\n    this.state = state;\n  };\n  /**\n   * Set up the primary and preferred backoff mechanisms.\n   */\n  WSTransport.prototype._setupBackoffs = function () {\n    var _this = this;\n    var preferredBackoffConfig = {\n      factor: 2.0,\n      jitter: 0.40,\n      max: this._options.maxPreferredDelayMs,\n      min: 100\n    };\n    this._log.info('Initializing preferred transport backoff using config: ', preferredBackoffConfig);\n    var preferredBackoff = new backoff_1.default(preferredBackoffConfig);\n    preferredBackoff.on('backoff', function (attempt, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Preferred backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      _this._log.info(\"Will attempt to reconnect Websocket to preferred URI in \" + delay + \"ms\");\n      if (attempt === 0) {\n        _this._backoffStartTime.preferred = Date.now();\n        _this._log.info(\"Preferred backoff start; \" + _this._backoffStartTime.preferred);\n      }\n    });\n    preferredBackoff.on('ready', function (attempt, _delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Preferred backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (_this._backoffStartTime.preferred === null) {\n        _this._log.info('Preferred backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - _this._backoffStartTime.preferred > _this._options.maxPreferredDurationMs) {\n        _this._log.info('Max preferred backoff attempt time exceeded; falling back to primary backoff.');\n        _this._preferredUri = null;\n        _this._backoff.primary.backoff();\n        return;\n      }\n      if (typeof _this._preferredUri !== 'string') {\n        _this._log.info('Preferred URI cleared; falling back to primary backoff.');\n        _this._preferredUri = null;\n        _this._backoff.primary.backoff();\n        return;\n      }\n      _this._connect(_this._preferredUri, attempt + 1);\n    });\n    var primaryBackoffConfig = {\n      factor: 2.0,\n      jitter: 0.40,\n      max: this._options.maxPrimaryDelayMs,\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      min: this._uris && this._uris.length > 1 ? Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000 : 100\n    };\n    this._log.info('Initializing primary transport backoff using config: ', primaryBackoffConfig);\n    var primaryBackoff = new backoff_1.default(primaryBackoffConfig);\n    primaryBackoff.on('backoff', function (attempt, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Primary backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n      if (attempt === 0) {\n        _this._backoffStartTime.primary = Date.now();\n        _this._log.info(\"Primary backoff start; \" + _this._backoffStartTime.primary);\n      }\n    });\n    primaryBackoff.on('ready', function (attempt, _delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Primary backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (_this._backoffStartTime.primary === null) {\n        _this._log.info('Primary backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - _this._backoffStartTime.primary > _this._options.maxPrimaryDurationMs) {\n        _this._log.info('Max primary backoff attempt time exceeded; not attempting a connection.');\n        return;\n      }\n      _this._connect(_this._uris[_this._uriIndex], attempt + 1);\n    });\n    return {\n      preferred: preferredBackoff,\n      primary: primaryBackoff\n    };\n  };\n  Object.defineProperty(WSTransport.prototype, \"uri\", {\n    /**\n     * The uri the transport is currently connected to\n     */\n    get: function () {\n      return this._connectedUri;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WSTransport.defaultConstructorOptions = {\n    WebSocket: WebSocket,\n    connectTimeoutMs: CONNECT_TIMEOUT,\n    maxPreferredDelayMs: MAX_PREFERRED_DELAY,\n    maxPreferredDurationMs: MAX_PREFERRED_DURATION,\n    maxPrimaryDelayMs: MAX_PRIMARY_DELAY,\n    maxPrimaryDurationMs: MAX_PRIMARY_DURATION\n  };\n  return WSTransport;\n}(events_1.EventEmitter);\nexports.default = WSTransport;","map":{"version":3,"names":["events_1","require","backoff_1","errors_1","log_1","WebSocket","globalThis","CONNECT_SUCCESS_TIMEOUT","CONNECT_TIMEOUT","HEARTBEAT_TIMEOUT","MAX_PREFERRED_DURATION","MAX_PRIMARY_DURATION","Infinity","MAX_PREFERRED_DELAY","MAX_PRIMARY_DELAY","WSTransportState","exports","WSTransport","_super","__extends","uris","options","_this","call","state","Closed","_backoffStartTime","preferred","primary","_connectedUri","_log","default","_shouldFallback","_uriIndex","_moveUriIndex","_uris","length","_onSocketClose","event","error","code","reason","emit","message","twilioError","SignalingErrors","ConnectionError","wasConnected","Open","_previousState","_closeSocket","_onSocketError","err","ConnectionDisconnected","_onSocketMessage","_setHeartbeatTimeout","_socket","data","send","debug","_onSocketOpen","info","_timeOpened","Date","now","_setState","clearTimeout","_connectTimeout","_resetBackoffs","_options","__assign","defaultConstructorOptions","_backoff","_setupBackoffs","prototype","close","_close","open","readyState","CONNECTING","OPEN","_preferredUri","_connect","e","updatePreferredURI","uri","updateURIs","_heartbeatTimeout","removeEventListener","_performBackoff","retryCount","Connecting","addEventListener","setTimeout","connectTimeoutMs","backoff","reset","preferredBackoffConfig","factor","jitter","max","maxPreferredDelayMs","min","preferredBackoff","on","attempt","delay","_delay","maxPreferredDurationMs","primaryBackoffConfig","maxPrimaryDelayMs","Math","floor","random","primaryBackoff","maxPrimaryDurationMs","Object","defineProperty","get","EventEmitter"],"sources":["C:\\Users\\91629\\Desktop\\Delote\\calling software\\node_modules\\@twilio\\voice-sdk\\lib\\twilio\\wstransport.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport Backoff from './backoff';\nimport { SignalingErrors } from './errors';\nimport Log from './log';\n\nconst WebSocket = globalThis.WebSocket;\n\nconst CONNECT_SUCCESS_TIMEOUT = 10000;\nconst CONNECT_TIMEOUT = 5000;\nconst HEARTBEAT_TIMEOUT = 15000;\nconst MAX_PREFERRED_DURATION = 15000;\nconst MAX_PRIMARY_DURATION = Infinity;\nconst MAX_PREFERRED_DELAY = 1000;\nconst MAX_PRIMARY_DELAY = 20000;\n\nexport interface IMessageEvent {\n  data: string;\n  target: WebSocket;\n  type: string;\n}\n\n/**\n * All possible states of WSTransport.\n */\nexport enum WSTransportState {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  Closed = 'closed',\n\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  Open = 'open',\n}\n\n/**\n * Options to be passed to the WSTransport constructor.\n */\nexport interface IWSTransportConstructorOptions {\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  connectTimeoutMs?: number;\n\n  /**\n   * The maximum delay for the preferred backoff to make a connection attempt.\n   */\n  maxPreferredDelayMs?: number;\n\n  /**\n   * Max duration to attempt connecting to a preferred URI.\n   */\n  maxPreferredDurationMs?: number;\n\n  /**\n   * The maximum delay for the rimary backoff to make a connection attempt.\n   */\n  maxPrimaryDelayMs?: number;\n\n  /**\n   * Max duration to attempt connecting to a preferred URI.\n   */\n  maxPrimaryDurationMs?: number;\n\n  /**\n   * A WebSocket factory to use instead of WebSocket.\n   */\n  WebSocket?: typeof WebSocket;\n}\n\n/**\n * Type of the stored options property internally used by the WSTransport class.\n */\ntype IInternalWSTransportConstructorOptions = Required<IWSTransportConstructorOptions>;\n\n/**\n * WebSocket Transport\n */\nexport default class WSTransport extends EventEmitter {\n  private static defaultConstructorOptions: IInternalWSTransportConstructorOptions = {\n    WebSocket,\n    connectTimeoutMs: CONNECT_TIMEOUT,\n    maxPreferredDelayMs: MAX_PREFERRED_DELAY,\n    maxPreferredDurationMs: MAX_PREFERRED_DURATION,\n    maxPrimaryDelayMs: MAX_PRIMARY_DELAY,\n    maxPrimaryDurationMs: MAX_PRIMARY_DURATION,\n  };\n\n  /**\n   * The current state of the WSTransport.\n   */\n  state: WSTransportState = WSTransportState.Closed;\n\n  /**\n   * The backoff instance used to schedule reconnection attempts.\n   */\n  private readonly _backoff: {\n    preferred: any;\n    primary: any;\n  };\n\n  /**\n   * Start timestamp values for backoffs.\n   */\n  private _backoffStartTime: {\n    preferred: number | null;\n    primary: number | null;\n  } = {\n    preferred: null,\n    primary: null,\n  };\n\n  /**\n   * The URI that the transport is connecting or connected to. The value of this\n   * property is `null` if a connection attempt has not been made yet.\n   */\n  private _connectedUri: string | null = null;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _connectTimeout?: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _heartbeatTimeout?: any;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = new Log('WSTransport');\n\n  /**\n   * Options after missing values are defaulted.\n   */\n  private _options: IInternalWSTransportConstructorOptions;\n\n  /**\n   * Preferred URI endpoint to connect to.\n   */\n  private _preferredUri: string | null;\n\n  /**\n   * Previous state of the connection\n   */\n  private _previousState: WSTransportState;\n\n  /**\n   * Whether we should attempt to fallback if we receive an applicable error\n   * when trying to connect to a signaling endpoint.\n   */\n  private _shouldFallback: boolean = false;\n\n  /**\n   * The currently connecting or open WebSocket.\n   */\n  private _socket?: WebSocket;\n\n  /**\n   * The time the active connection was opened.\n   */\n  private _timeOpened?: number;\n\n  /**\n   * The current uri index that the transport is connected to.\n   */\n  private _uriIndex: number = 0;\n\n  /**\n   * List of URI of the endpoints to connect to.\n   */\n  private _uris: string[];\n\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  constructor(uris: string[], options: IWSTransportConstructorOptions = { }) {\n    super();\n\n    this._options = { ...WSTransport.defaultConstructorOptions, ...options };\n\n    this._uris = uris;\n\n    this._backoff = this._setupBackoffs();\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  close(): void {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  }\n\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  open(): void {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket &&\n        (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n\n    if (this._preferredUri) {\n      this._connect(this._preferredUri);\n    } else {\n      this._connect(this._uris[this._uriIndex]);\n    }\n  }\n\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  send(message: string): boolean {\n    this._log.debug(`Sending: ${message}`);\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      this._log.debug('Cannot send message. WebSocket is not open.');\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.error('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Update the preferred URI to connect to. Useful for Call signaling\n   * reconnection, which requires connecting on the same edge. If `null` is\n   * passed, the preferred URI is unset and the original `uris` array and\n   * `uriIndex` is used to determine the signaling URI to connect to.\n   * @param uri\n   */\n  updatePreferredURI(uri: string | null) {\n    this._preferredUri = uri;\n  }\n\n  /**\n   * Update acceptable URIs to reconnect to. Resets the URI index to 0.\n   */\n  updateURIs(uris: string[] | string) {\n    if (typeof uris === 'string') {\n      uris = [uris];\n    }\n\n    this._uris = uris;\n    this._uriIndex = 0;\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  private _close(): void {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  }\n\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  private _closeSocket(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose as any);\n    this._socket.removeEventListener('error', this._onSocketError as any);\n    this._socket.removeEventListener('message', this._onSocketMessage as any);\n    this._socket.removeEventListener('open', this._onSocketOpen as any);\n\n    if (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._resetBackoffs();\n    }\n\n    if (this.state !== WSTransportState.Closed) {\n      this._performBackoff();\n    }\n    delete this._socket;\n\n    this.emit('close');\n  }\n\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [uri] - URI string to connect to.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  private _connect(uri: string, retryCount?: number): void {\n    this._log.info(\n      typeof retryCount === 'number'\n        ? `Attempting to reconnect (retry #${retryCount})...`\n        : 'Attempting to connect...',\n    );\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n    this._connectedUri = uri;\n\n    try {\n      this._socket = new this._options.WebSocket(this._connectedUri);\n    } catch (e) {\n      this._log.error('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || `Could not connect to ${this._connectedUri}`,\n        twilioError: new SignalingErrors.ConnectionDisconnected(),\n      });\n      return;\n    }\n\n    this._socket.addEventListener('close', this._onSocketClose as any);\n    this._socket.addEventListener('error', this._onSocketError as any);\n    this._socket.addEventListener('message', this._onSocketMessage as any);\n    this._socket.addEventListener('open', this._onSocketOpen as any);\n\n    delete this._timeOpened;\n\n    this._connectTimeout = setTimeout(() => {\n      this._log.info('WebSocket connection attempt timed out.');\n      this._moveUriIndex();\n      this._closeSocket();\n    }, this._options.connectTimeoutMs);\n  }\n\n  /**\n   * Move the uri index to the next index\n   * If the index is at the end, the index goes back to the first one.\n   */\n  private _moveUriIndex = (): void => {\n    this._uriIndex++;\n    if (this._uriIndex >= this._uris.length) {\n      this._uriIndex = 0;\n    }\n  }\n\n  /**\n   * Called in response to WebSocket#close event.\n   */\n  private _onSocketClose = (event: CloseEvent): void => {\n    this._log.error(`Received websocket close event code: ${event.code}. Reason: ${event.reason}`);\n    // 1006: Abnormal close. When the server is unreacheable\n    // 1015: TLS Handshake error\n    if (event.code === 1006 || event.code === 1015) {\n      this.emit('error', {\n        code: 31005,\n        message: event.reason ||\n          'Websocket connection to Twilio\\'s signaling servers were ' +\n          'unexpectedly ended. If this is happening consistently, there may ' +\n          'be an issue resolving the hostname provided. If a region or an ' +\n          'edge is being specified in Device setup, ensure it is valid.',\n        twilioError: new SignalingErrors.ConnectionError(),\n      });\n\n      const wasConnected = (\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        this.state === WSTransportState.Open ||\n\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        this._previousState === WSTransportState.Open\n      );\n\n      // Only fallback if this is not the first error\n      // and if we were not connected previously\n      if (this._shouldFallback || !wasConnected) {\n        this._moveUriIndex();\n      }\n\n      this._shouldFallback = true;\n    }\n    this._closeSocket();\n  }\n\n  /**\n   * Called in response to WebSocket#error event.\n   */\n  private _onSocketError = (err: Error): void => {\n    this._log.error(`WebSocket received error: ${err.message}`);\n    this.emit('error', {\n      code: 31000,\n      message: err.message || 'WSTransport socket error',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    });\n  }\n\n  /**\n   * Called in response to WebSocket#message event.\n   */\n  private _onSocketMessage = (message: IMessageEvent): void => {\n    // Clear heartbeat timeout on any incoming message, as they\n    // all indicate an active connection.\n    this._setHeartbeatTimeout();\n\n    // Filter and respond to heartbeats\n    if (this._socket && message.data === '\\n') {\n      this._socket.send('\\n');\n      this._log.debug('heartbeat');\n      return;\n    }\n\n    if (message && typeof message.data === 'string') {\n      this._log.debug(`Received: ${message.data}`);\n    }\n\n    this.emit('message', message);\n  }\n\n  /**\n   * Called in response to WebSocket#open event.\n   */\n  private _onSocketOpen = (): void => {\n    this._log.info('WebSocket opened successfully.');\n    this._timeOpened = Date.now();\n    this._shouldFallback = false;\n    this._setState(WSTransportState.Open);\n    clearTimeout(this._connectTimeout);\n\n    this._resetBackoffs();\n\n    this._setHeartbeatTimeout();\n    this.emit('open');\n  }\n\n  /**\n   * Perform a backoff. If a preferred URI is set (not null), then backoff\n   * using the preferred mechanism. Otherwise, use the primary mechanism.\n   */\n  private _performBackoff(): void {\n    if (this._preferredUri) {\n      this._log.info('Preferred URI set; backing off.');\n      this._backoff.preferred.backoff();\n    } else {\n      this._log.info('Preferred URI not set; backing off.');\n      this._backoff.primary.backoff();\n    }\n  }\n\n  /**\n   * Reset both primary and preferred backoff mechanisms.\n   */\n  private _resetBackoffs() {\n    this._backoff.preferred.reset();\n    this._backoff.primary.reset();\n\n    this._backoffStartTime.preferred = null;\n    this._backoffStartTime.primary = null;\n  }\n\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  private _setHeartbeatTimeout(): void {\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(() => {\n      this._log.info(`No messages received in ${HEARTBEAT_TIMEOUT / 1000} seconds. Reconnecting...`);\n      this._shouldFallback = true;\n      this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  }\n\n  /**\n   * Set the current and previous state\n   */\n  private _setState(state: WSTransportState): void {\n    this._previousState = this.state;\n    this.state = state;\n  }\n\n  /**\n   * Set up the primary and preferred backoff mechanisms.\n   */\n  private _setupBackoffs(): typeof WSTransport.prototype._backoff {\n    const preferredBackoffConfig = {\n      factor: 2.0,\n      jitter: 0.40,\n      max: this._options.maxPreferredDelayMs,\n      min: 100,\n    };\n    this._log.info('Initializing preferred transport backoff using config: ', preferredBackoffConfig);\n    const preferredBackoff = new Backoff(preferredBackoffConfig);\n\n    preferredBackoff.on('backoff', (attempt: number, delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Preferred backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      this._log.info(`Will attempt to reconnect Websocket to preferred URI in ${delay}ms`);\n      if (attempt === 0) {\n        this._backoffStartTime.preferred = Date.now();\n        this._log.info(`Preferred backoff start; ${this._backoffStartTime.preferred}`);\n      }\n    });\n\n    preferredBackoff.on('ready', (attempt: number, _delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Preferred backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (this._backoffStartTime.preferred === null) {\n        this._log.info('Preferred backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - this._backoffStartTime.preferred > this._options.maxPreferredDurationMs) {\n        this._log.info('Max preferred backoff attempt time exceeded; falling back to primary backoff.');\n        this._preferredUri = null;\n        this._backoff.primary.backoff();\n        return;\n      }\n      if (typeof this._preferredUri !== 'string') {\n        this._log.info('Preferred URI cleared; falling back to primary backoff.');\n        this._preferredUri = null;\n        this._backoff.primary.backoff();\n        return;\n      }\n      this._connect(this._preferredUri, attempt + 1);\n    });\n\n    const primaryBackoffConfig = {\n      factor: 2.0,\n      jitter: 0.40,\n      max: this._options.maxPrimaryDelayMs,\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      min: this._uris && this._uris.length > 1\n        ? Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000\n        : 100,\n    };\n    this._log.info('Initializing primary transport backoff using config: ', primaryBackoffConfig);\n    const primaryBackoff = new Backoff(primaryBackoffConfig);\n\n    primaryBackoff.on('backoff', (attempt: number, delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Primary backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      this._log.info(`Will attempt to reconnect WebSocket in ${delay}ms`);\n      if (attempt === 0) {\n        this._backoffStartTime.primary = Date.now();\n        this._log.info(`Primary backoff start; ${this._backoffStartTime.primary}`);\n      }\n    });\n\n    primaryBackoff.on('ready', (attempt: number, _delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Primary backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (this._backoffStartTime.primary === null) {\n        this._log.info('Primary backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - this._backoffStartTime.primary > this._options.maxPrimaryDurationMs) {\n        this._log.info('Max primary backoff attempt time exceeded; not attempting a connection.');\n        return;\n      }\n      this._connect(this._uris[this._uriIndex], attempt + 1);\n    });\n\n    return {\n      preferred: preferredBackoff,\n      primary: primaryBackoff,\n    };\n  }\n\n  /**\n   * The uri the transport is currently connected to\n   */\n  get uri(): string | null {\n    return this._connectedUri;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}